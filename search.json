[
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Your Deep Learning Journey",
    "section": "",
    "text": "1.1 Deep Learning Is for Everyone\nA lot of people assume that you need all kinds of hard-to-find stuff to get great results with deep learning, but as you’ll see in this book, those people are wrong. Table 1.1 is a list of a few thing you absolutely don’t need to do world-class deep learning.\nDeep learning is a computer technique to extract and transform data–-with use cases ranging from human speech recognition to animal imagery classification–-by using multiple layers of neural networks. Each of these layers takes its inputs from previous layers and progressively refines them. The layers are trained by algorithms that minimize their errors and improve their accuracy. In this way, the network learns to perform a specified task. We will discuss training algorithms in detail in the next section.\nDeep learning has power, flexibility, and simplicity. That’s why we believe it should be applied across many disciplines. These include the social and physical sciences, the arts, medicine, finance, scientific research, and many more. To give a personal example, despite having no background in medicine, Jeremy started Enlitic, a company that uses deep learning algorithms to diagnose illness and disease. Within months of starting the company, it was announced that its algorithm could identify malignant tumors more accurately than radiologists.\nHere’s a list of some of the thousands of tasks in different areas at which deep learning, or methods heavily using deep learning, is now the best in the world:\nWhat is remarkable is that deep learning has such varied application yet nearly all of deep learning is based on a single type of model, the neural network.\nBut neural networks are not in fact completely new. In order to have a wider perspective on the field, it is worth it to start with a bit of history.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#deep-learning-is-for-everyone",
    "href": "intro.html#deep-learning-is-for-everyone",
    "title": "1  Your Deep Learning Journey",
    "section": "",
    "text": "Table 1.1: What you don’t need to do deep learning\n\n\n\n\n\n\n\n\n\nMyth (don’t need)\nTruth\n\n\n\n\nLots of math\nJust high school math is sufficient\n\n\nLots of data\nWe’ve seen record-breaking results with &lt;50 items of data\n\n\nLots of expensive computers\nYou can get what you need for state of the art work for free\n\n\n\n\n\n\n\n\n\n\nNatural language processing (NLP):: Answering questions; speech recognition; summarizing documents; classifying documents; finding names, dates, etc. in documents; searching for articles mentioning a concept\nComputer vision:: Satellite and drone imagery interpretation (e.g., for disaster resilience); face recognition; image captioning; reading traffic signs; locating pedestrians and vehicles in autonomous vehicles\nMedicine:: Finding anomalies in radiology images, including CT, MRI, and X-ray images; counting features in pathology slides; measuring features in ultrasounds; diagnosing diabetic retinopathy\nBiology:: Folding proteins; classifying proteins; many genomics tasks, such as tumor-normal sequencing and classifying clinically actionable genetic mutations; cell classification; analyzing protein/protein interactions\nImage generation:: Colorizing images; increasing image resolution; removing noise from images; converting images to art in the style of famous artists\nRecommendation systems:: Web search; product recommendations; home page layout\nPlaying games:: Chess, Go, most Atari video games, and many real-time strategy games\nRobotics:: Handling objects that are challenging to locate (e.g., transparent, shiny, lacking texture) or hard to pick up\nOther applications:: Financial and logistical forecasting, text to speech, and much more…",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#neural-networks-a-brief-history",
    "href": "intro.html#neural-networks-a-brief-history",
    "title": "1  Your Deep Learning Journey",
    "section": "1.2 Neural Networks: A Brief History",
    "text": "1.2 Neural Networks: A Brief History\nIn 1943 Warren McCulloch, a neurophysiologist, and Walter Pitts, a logician, teamed up to develop a mathematical model of an artificial neuron. In their paper “A Logical Calculus of the Ideas Immanent in Nervous Activity” they declared that:\n\nBecause of the “all-or-none” character of nervous activity, neural events and the relations among them can be treated by means of propositional logic. It is found that the behavior of every net can be described in these terms.\n\nMcCulloch and Pitts realized that a simplified model of a real neuron could be represented using simple addition and thresholding, as shown in Figure 1.1. Pitts was self-taught, and by age 12, had received an offer to study at Cambridge University with the great Bertrand Russell. He did not take up this invitation, and indeed throughout his life did not accept any offers of advanced degrees or positions of authority. Most of his famous work was done while he was homeless. Despite his lack of an officially recognized position and increasing social isolation, his work with McCulloch was influential, and was taken up by a psychologist named Frank Rosenblatt.\n\n\n\n\n\n\nFigure 1.1: Natural and artificial neurons\n\n\n\nRosenblatt further developed the artificial neuron to give it the ability to learn. Even more importantly, he worked on building the first device that actually used these principles, the Mark I Perceptron. In “The Design of an Intelligent Automaton” Rosenblatt wrote about this work: “We are now about to witness the birth of such a machine–-a machine capable of perceiving, recognizing and identifying its surroundings without any human training or control.” The perceptron was built, and was able to successfully recognize simple shapes.\nAn MIT professor named Marvin Minsky (who was a grade behind Rosenblatt at the same high school!), along with Seymour Papert, wrote a book called Perceptrons (MIT Press), about Rosenblatt’s invention. They showed that a single layer of these devices was unable to learn some simple but critical mathematical functions (such as XOR). In the same book, they also showed that using multiple layers of the devices would allow these limitations to be addressed. Unfortunately, only the first of these insights was widely recognized. As a result, the global academic community nearly entirely gave up on neural networks for the next two decades.\nPerhaps the most pivotal work in neural networks in the last 50 years was the multi-volume Parallel Distributed Processing (PDP) by David Rumelhart, James McClellan, and the PDP Research Group, released in 1986 by MIT Press. Chapter 1 lays out a similar hope to that shown by Rosenblatt:\n\nPeople are smarter than today’s computers because the brain employs a basic computational architecture that is more suited to deal with a central aspect of the natural information processing tasks that people are so good at. …We will introduce a computational framework for modeling cognitive processes that seems… closer than other frameworks to the style of computation as it might be done by the brain.\n\nThe premise that PDP is using here is that traditional computer programs work very differently to brains, and that might be why computer programs had been (at that point) so bad at doing things that brains find easy (such as recognizing objects in pictures). The authors claimed that the PDP approach was “closer than other frameworks” to how the brain works, and therefore it might be better able to handle these kinds of tasks.\nIn fact, the approach laid out in PDP is very similar to the approach used in today’s neural networks. The book defined parallel distributed processing as requiring:\n\nA set of processing units\nA state of activation\nAn output function for each unit\nA pattern of connectivity among units\nA propagation rule for propagating patterns of activities through the network of connectivities\nAn activation rule for combining the inputs impinging on a unit with the current state of that unit to produce an output for the unit\nA learning rule whereby patterns of connectivity are modified by experience\nAn environment within which the system must operate\n\nWe will see in this book that modern neural networks handle each of these requirements.\nIn the 1980’s most models were built with a second layer of neurons, thus avoiding the problem that had been identified by Minsky and Papert (this was their “pattern of connectivity among units,” to use the framework above). And indeed, neural networks were widely used during the ’80s and ’90s for real, practical projects. However, again a misunderstanding of the theoretical issues held back the field. In theory, adding just one extra layer of neurons was enough to allow any mathematical function to be approximated with these neural networks, but in practice such networks were often too big and too slow to be useful.\nAlthough researchers showed 30 years ago that to get practical good performance you need to use even more layers of neurons, it is only in the last decade that this principle has been more widely appreciated and applied. Neural networks are now finally living up to their potential, thanks to the use of more layers, coupled with the capacity to do so due to improvements in computer hardware, increases in data availability, and algorithmic tweaks that allow neural networks to be trained faster and more easily. We now have what Rosenblatt promised: “a machine capable of perceiving, recognizing, and identifying its surroundings without any human training or control.”\nThis is what you will learn how to build in this book. But first, since we are going to be spending a lot of time together, let’s get to know each other a bit…",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#who-we-are",
    "href": "intro.html#who-we-are",
    "title": "1  Your Deep Learning Journey",
    "section": "1.3 Who We Are",
    "text": "1.3 Who We Are\nWe are Sylvain and Jeremy, your guides on this journey. We hope that you will find us well suited for this position.\nJeremy has been using and teaching machine learning for around 30 years. He started using neural networks 25 years ago. During this time, he has led many companies and projects that have machine learning at their core, including founding the first company to focus on deep learning and medicine, Enlitic, and taking on the role of President and Chief Scientist of the world’s largest machine learning community, Kaggle. He is the co-founder, along with Dr. Rachel Thomas, of fast.ai, the organization that built the course this book is based on.\nFrom time to time you will hear directly from us, in sidebars like this one from Jeremy:\n\nJ: Hi everybody, I’m Jeremy! You might be interested to know that I do not have any formal technical education. I completed a BA, with a major in philosophy, and didn’t have great grades. I was much more interested in doing real projects, rather than theoretical studies, so I worked full time at a management consulting firm called McKinsey and Company throughout my university years. If you’re somebody who would rather get their hands dirty building stuff than spend years learning abstract concepts, then you will understand where I am coming from! Look out for sidebars from me to find information most suited to people with a less mathematical or formal technical background—that is, people like me…\n\nSylvain, on the other hand, knows a lot about formal technical education. In fact, he has written 10 math textbooks, covering the entire advanced French maths curriculum!\n\nS: Unlike Jeremy, I have not spent many years coding and applying machine learning algorithms. Rather, I recently came to the machine learning world, by watching Jeremy’s fast.ai course videos. So, if you are somebody who has not opened a terminal and written commands at the command line, then you will understand where I am coming from! Look out for sidebars from me to find information most suited to people with a more mathematical or formal technical background, but less real-world coding experience—that is, people like me…\n\nThe fast.ai course has been studied by hundreds of thousands of students, from all walks of life, from all parts of the world. Sylvain stood out as the most impressive student of the course that Jeremy had ever seen, which led to him joining fast.ai, and then becoming the coauthor, along with Jeremy, of the fastai software library.\nAll this means that between us you have the best of both worlds: the people who know more about the software than anybody else, because they wrote it; an expert on math, and an expert on coding and machine learning; and also people who understand both what it feels like to be a relative outsider in math, and a relative outsider in coding and machine learning.\nAnybody who has watched sports knows that if you have a two-person commentary team then you also need a third person to do “special comments.” Our special commentator is Alexis Gallagher. Alexis has a very diverse background: he has been a researcher in mathematical biology, a screenplay writer, an improv performer, a McKinsey consultant (like Jeremy!), a Swift coder, and a CTO.\n\nA: I’ve decided it’s time for me to learn about this AI stuff! After all, I’ve tried pretty much everything else… But I don’t really have a background in building machine learning models. Still… how hard can it be? I’m going to be learning throughout this book, just like you are. Look out for my sidebars for learning tips that I found helpful on my journey, and hopefully you will find helpful too.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#how-to-learn-deep-learning",
    "href": "intro.html#how-to-learn-deep-learning",
    "title": "1  Your Deep Learning Journey",
    "section": "1.4 How to Learn Deep Learning",
    "text": "1.4 How to Learn Deep Learning\nHarvard professor David Perkins, who wrote Making Learning Whole (Jossey-Bass), has much to say about teaching. The basic idea is to teach the whole game. That means that if you’re teaching baseball, you first take people to a baseball game or get them to play it. You don’t teach them how to wind twine to make a baseball from scratch, the physics of a parabola, or the coefficient of friction of a ball on a bat.\nPaul Lockhart, a Columbia math PhD, former Brown professor, and K-12 math teacher, imagines in the influential essay “A Mathematician’s Lament” a nightmare world where music and art are taught the way math is taught. Children are not allowed to listen to or play music until they have spent over a decade mastering music notation and theory, spending classes transposing sheet music into a different key. In art class, students study colors and applicators, but aren’t allowed to actually paint until college. Sound absurd? This is how math is taught–-we require students to spend years doing rote memorization and learning dry, disconnected fundamentals that we claim will pay off later, long after most of them quit the subject.\nUnfortunately, this is where many teaching resources on deep learning begin–-asking learners to follow along with the definition of the Hessian and theorems for the Taylor approximation of your loss functions, without ever giving examples of actual working code. We’re not knocking calculus. We love calculus, and Sylvain has even taught it at the college level, but we don’t think it’s the best place to start when learning deep learning!\nIn deep learning, it really helps if you have the motivation to fix your model to get it to do better. That’s when you start learning the relevant theory. But you need to have the model in the first place. We teach almost everything through real examples. As we build out those examples, we go deeper and deeper, and we’ll show you how to make your projects better and better. This means that you’ll be gradually learning all the theoretical foundations you need, in context, in such a way that you’ll see why it matters and how it works.\nSo, here’s our commitment to you. Throughout this book, we will follow these principles:\n\nTeaching the whole game. We’ll start by showing how to use a complete, working, very usable, state-of-the-art deep learning network to solve real-world problems, using simple, expressive tools. And then we’ll gradually dig deeper and deeper into understanding how those tools are made, and how the tools that make those tools are made, and so on…\nAlways teaching through examples. We’ll ensure that there is a context and a purpose that you can understand intuitively, rather than starting with algebraic symbol manipulation.\nSimplifying as much as possible. We’ve spent years building tools and teaching methods that make previously complex topics very simple.\nRemoving barriers. Deep learning has, until now, been a very exclusive game. We’re breaking it open, and ensuring that everyone can play.\n\nThe hardest part of deep learning is artisanal: how do you know if you’ve got enough data, whether it is in the right format, if your model is training properly, and, if it’s not, what you should do about it? That is why we believe in learning by doing. As with basic data science skills, with deep learning you only get better through practical experience. Trying to spend too much time on the theory can be counterproductive. The key is to just code and try to solve problems: the theory can come later, when you have context and motivation.\nThere will be times when the journey will feel hard. Times where you feel stuck. Don’t give up! Rewind through the book to find the last bit where you definitely weren’t stuck, and then read slowly through from there to find the first thing that isn’t clear. Then try some code experiments yourself, and Google around for more tutorials on whatever the issue you’re stuck with is—often you’ll find some different angle on the material might help it to click. Also, it’s expected and normal to not understand everything (especially the code) on first reading. Trying to understand the material serially before proceeding can sometimes be hard. Sometimes things click into place after you get more context from parts down the road, from having a bigger picture. So if you do get stuck on a section, try moving on anyway and make a note to come back to it later.\nRemember, you don’t need any particular academic background to succeed at deep learning. Many important breakthroughs are made in research and industry by folks without a PhD, such as “Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks”—one of the most influential papers of the last decade—with over 5,000 citations, which was written by Alec Radford when he was an undergraduate. Even at Tesla, where they’re trying to solve the extremely tough challenge of making a self-driving car, CEO Elon Musk says:\n\nA PhD is definitely not required. All that matters is a deep understanding of AI & ability to implement NNs in a way that is actually useful (latter point is what’s truly hard). Don’t care if you even graduated high school.\n\nWhat you will need to do to succeed however is to apply what you learn in this book to a personal project, and always persevere.\n\nYour Projects and Your Mindset\nWhether you’re excited to identify if plants are diseased from pictures of their leaves, auto-generate knitting patterns, diagnose TB from X-rays, or determine when a raccoon is using your cat door, we will get you using deep learning on your own problems (via pre-trained models from others) as quickly as possible, and then will progressively drill into more details. You’ll learn how to use deep learning to solve your own problems at state-of-the-art accuracy within the first 30 minutes of the next chapter! (And feel free to skip straight there now if you’re dying to get coding right away.) There is a pernicious myth out there that you need to have computing resources and datasets the size of those at Google to be able to do deep learning, but it’s not true.\nSo, what sorts of tasks make for good test cases? You could train your model to distinguish between Picasso and Monet paintings or to pick out pictures of your daughter instead of pictures of your son. It helps to focus on your hobbies and passions–-setting yourself four or five little projects rather than striving to solve a big, grand problem tends to work better when you’re getting started. Since it is easy to get stuck, trying to be too ambitious too early can often backfire. Then, once you’ve got the basics mastered, aim to complete something you’re really proud of!\n\nJ: Deep learning can be set to work on almost any problem. For instance, my first startup was a company called FastMail, which provided enhanced email services when it launched in 1999 (and still does to this day). In 2002 I set it up to use a primitive form of deep learning, single-layer neural networks, to help categorize emails and stop customers from receiving spam.\n\nCommon character traits in the people that do well at deep learning include playfulness and curiosity. The late physicist Richard Feynman is an example of someone who we’d expect to be great at deep learning: his development of an understanding of the movement of subatomic particles came from his amusement at how plates wobble when they spin in the air.\nLet’s now focus on what you will learn, starting with the software.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#the-software-pytorch-fastai-and-jupyter",
    "href": "intro.html#the-software-pytorch-fastai-and-jupyter",
    "title": "1  Your Deep Learning Journey",
    "section": "1.5 The Software: PyTorch, fastai, and Jupyter",
    "text": "1.5 The Software: PyTorch, fastai, and Jupyter\n(And Why It Doesn’t Matter)\nWe’ve completed hundreds of machine learning projects using dozens of different packages, and many different programming languages. At fast.ai, we have written courses using most of the main deep learning and machine learning packages used today. After PyTorch came out in 2017 we spent over a thousand hours testing it before deciding that we would use it for future courses, software development, and research. Since that time PyTorch has become the world’s fastest-growing deep learning library and is already used for most research papers at top conferences. This is generally a leading indicator of usage in industry, because these are the papers that end up getting used in products and services commercially. We have found that PyTorch is the most flexible and expressive library for deep learning. It does not trade off speed for simplicity, but provides both.\nPyTorch works best as a low-level foundation library, providing the basic operations for higher-level functionality. The fastai library is the most popular library for adding this higher-level functionality on top of PyTorch. It’s also particularly well suited to the purposes of this book, because it is unique in providing a deeply layered software architecture (there’s even a peer-reviewed academic paper about this layered API). In this book, as we go deeper and deeper into the foundations of deep learning, we will also go deeper and deeper into the layers of fastai. This book covers version 2 of the fastai library, which is a from-scratch rewrite providing many unique features.\nHowever, it doesn’t really matter what software you learn, because it takes only a few days to learn to switch from one library to another. What really matters is learning the deep learning foundations and techniques properly. Our focus will be on using code that clearly expresses the concepts that you need to learn. Where we are teaching high-level concepts, we will use high-level fastai code. Where we are teaching low-level concepts, we will use low-level PyTorch, or even pure Python code.\nIf it feels like new deep learning libraries are appearing at a rapid pace nowadays, then you need to be prepared for a much faster rate of change in the coming months and years. As more people enter the field, they will bring more skills and ideas, and try more things. You should assume that whatever specific libraries and software you learn today will be obsolete in a year or two. Just think about the number of changes in libraries and technology stacks that occur all the time in the world of web programming—a much more mature and slow-growing area than deep learning. We strongly believe that the focus in learning needs to be on understanding the underlying techniques and how to apply them in practice, and how to quickly build expertise in new tools and techniques as they are released.\nBy the end of the book, you’ll understand nearly all the code that’s inside fastai (and much of PyTorch too), because in each chapter we’ll be digging a level deeper to show you exactly what’s going on as we build and train our models. This means that you’ll have learned the most important best practices used in modern deep learning—not just how to use them, but how they really work and are implemented. If you want to use those approaches in another framework, you’ll have the knowledge you need to do so if needed.\nSince the most important thing for learning deep learning is writing code and experimenting, it’s important that you have a great platform for experimenting with code. The most popular programming experimentation platform is called Jupyter. This is what we will be using throughout this book. We will show you how you can use Jupyter to train and experiment with models and introspect every stage of the data pre-processing and model development pipeline. Jupyter Notebook is the most popular tool for doing data science in Python, for good reason. It is powerful, flexible, and easy to use. We think you will love it!\nLet’s see it in practice and train our first model.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#your-first-model",
    "href": "intro.html#your-first-model",
    "title": "1  Your Deep Learning Journey",
    "section": "1.6 Your First Model",
    "text": "1.6 Your First Model\nAs we said before, we will teach you how to do things before we explain why they work. Following this top-down approach, we will begin by actually training an image classifier to recognize dogs and cats with almost 100% accuracy. To train this model and run our experiments, you will need to do some initial setup. Don’t worry, it’s not as hard as it looks.\n\ns: Do not skip the setup part even if it looks intimidating at first, especially if you have little or no experience using things like a terminal or the command line. Most of that is actually not necessary and you will find that the easiest servers can be set up with just your usual web browser. It is crucial that you run your own experiments in parallel with this book in order to learn.\n\n\nGetting a GPU Deep Learning Server\nTo do nearly everything in this book, you’ll need access to a computer with an NVIDIA GPU (unfortunately other brands of GPU are not fully supported by the main deep learning libraries). However, we don’t recommend you buy one; in fact, even if you already have one, we don’t suggest you use it just yet! Setting up a computer takes time and energy, and you want all your energy to focus on deep learning right now. Therefore, we instead suggest you rent access to a computer that already has everything you need preinstalled and ready to go. Costs can be as little as US$0.25 per hour while you’re using it, and some options are even free.\n\njargon: Graphics Processing Unit (GPU): Also known as a graphics card. A special kind of processor in your computer that can handle thousands of single tasks at the same time, especially designed for displaying 3D environments on a computer for playing games. These same basic tasks are very similar to what neural networks do, such that GPUs can run neural networks hundreds of times faster than regular CPUs. All modern computers contain a GPU, but few contain the right kind of GPU necessary for deep learning.\n\nThe best choice of GPU servers to use with this book will change over time, as companies come and go and prices change. We maintain a list of our recommended options on the book’s website, so go there now and follow the instructions to get connected to a GPU deep learning server. Don’t worry, it only takes about two minutes to get set up on most platforms, and many don’t even require any payment, or even a credit card, to get started.\n\nA: My two cents: heed this advice! If you like computers you will be tempted to set up your own box. Beware! It is feasible but surprisingly involved and distracting. There is a good reason this book is not titled, Everything You Ever Wanted to Know About Ubuntu System Administration, NVIDIA Driver Installation, apt-get, conda, pip, and Jupyter Notebook Configuration. That would be a book of its own. Having designed and deployed our production machine learning infrastructure at work, I can testify it has its satisfactions, but it is as unrelated to modeling as maintaining an airplane is to flying one.\n\nEach option shown on the website includes a tutorial; after completing the tutorial, you will end up with a screen looking like Figure 1.2.\n\n\n\n\n\n\nFigure 1.2: Initial view of Jupyter Notebook\n\n\n\nYou are now ready to run your first Jupyter notebook!\n\njargon: Jupyter Notebook: A piece of software that allows you to include formatted text, code, images, videos, and much more, all within a single interactive document. Jupyter received the highest honor for software, the ACM Software System Award, thanks to its wide use and enormous impact in many academic fields and in industry. Jupyter Notebook is the software most widely used by data scientists for developing and interacting with deep learning models.\n\n\n\nRunning Your First Notebook\nThe notebooks are labeled by chapter and then by notebook number, so that they are in the same order as they are presented in this book. So, the very first notebook you will see listed is the notebook that you need to use now. You will be using this notebook to train a model that can recognize dog and cat photos. To do this, you’ll be downloading a dataset of dog and cat photos, and using that to train a model. A dataset is simply a bunch of data—it could be images, emails, financial indicators, sounds, or anything else. There are many datasets made freely available that are suitable for training models. Many of these datasets are created by academics to help advance research, many are made available for competitions (there are competitions where data scientists can compete to see who has the most accurate model!), and some are by-products of other processes (such as financial filings).\n\nnote: Full and Stripped Notebooks: There are two folders containing different versions of the notebooks. The full folder contains the exact notebooks used to create the book you’re reading now, with all the prose and outputs. The stripped version has the same headings and code cells, but all outputs and prose have been removed. After reading a section of the book, we recommend working through the stripped notebooks, with the book closed, and seeing if you can figure out what each cell will show before you execute it. Also try to recall what the code is demonstrating.\n\nTo open a notebook, just click on it. The notebook will open, and it will look something like Figure 1.3 (note that there may be slight differences in details across different platforms; you can ignore those differences).\n\n\n\n\n\n\nFigure 1.3: A Jupyter notebook\n\n\n\nA notebook consists of cells. There are two main types of cell:\n\nCells containing formatted text, images, and so forth. These use a format called markdown, which you will learn about soon.\nCells containing code that can be executed, and outputs will appear immediately underneath (which could be plain text, tables, images, animations, sounds, or even interactive applications).\n\nJupyter notebooks can be in one of two modes: edit mode or command mode. In edit mode typing on your keyboard enters the letters into the cell in the usual way. However, in command mode, you will not see any flashing cursor, and the keys on your keyboard will each have a special function.\nBefore continuing, press the Escape key on your keyboard to switch to command mode (if you are already in command mode, this does nothing, so press it now just in case). To see a complete list of all of the functions available, press H; press Escape to remove this help screen. Notice that in command mode, unlike most programs, commands do not require you to hold down Control, Alt, or similar—you simply press the required letter key.\nYou can make a copy of a cell by pressing C (the cell needs to be selected first, indicated with an outline around it; if it is not already selected, click on it once). Then press V to paste a copy of it.\nClick on the cell that begins with the line “# CLICK ME” to select it. The first character in that line indicates that what follows is a comment in Python, so it is ignored when executing the cell. The rest of the cell is, believe it or not, a complete system for creating and training a state-of-the-art model for recognizing cats versus dogs. So, let’s train it now! To do so, just press Shift-Enter on your keyboard, or press the Play button on the toolbar. Then wait a few minutes while the following things happen:\n\nA dataset called the Oxford-IIIT Pet Dataset that contains 7,349 images of cats and dogs from 37 different breeds will be downloaded from the fast.ai datasets collection to the GPU server you are using, and will then be extracted.\nA pretrained model that has already been trained on 1.3 million images, using a competition-winning model will be downloaded from the internet.\nThe pretrained model will be fine-tuned using the latest advances in transfer learning, to create a model that is specially customized for recognizing dogs and cats.\n\nThe first two steps only need to be run once on your GPU server. If you run the cell again, it will use the dataset and model that have already been downloaded, rather than downloading them again. Let’s take a look at the contents of the cell, and the results:\n\n# CLICK ME\nfrom fastai.vision.all import *\npath = untar_data(URLs.PETS)/'images'\n\ndef is_cat(x): return x[0].isupper()\ndls = ImageDataLoaders.from_name_func(\n    path, get_image_files(path), valid_pct=0.2, seed=42,\n    label_func=is_cat, item_tfms=Resize(224))\n\nlearn = vision_learner(dls, resnet34, metrics=error_rate)\nlearn.fine_tune(1)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.180385\n0.023942\n0.006766\n00:16\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.056023\n0.007580\n0.004060\n00:20\n\n\n\n\n\nYou will probably not see exactly the same results that are in the book. There are a lot of sources of small random variation involved in training models. We generally see an error rate of well less than 0.02 in this example, however.\n\nimportant: Training Time: Depending on your network speed, it might take a few minutes to download the pretrained model and dataset. Running fine_tune might take a minute or so. Often models in this book take a few minutes to train, as will your own models, so it’s a good idea to come up with good techniques to make the most of this time. For instance, keep reading the next section while your model trains, or open up another notebook and use it for some coding experiments.\n\n\n\nSidebar: This Book Was Written in Jupyter Notebooks\nWe wrote this book using Jupyter notebooks, so for nearly every chart, table, and calculation in this book, we’ll be showing you the exact code required to replicate it yourself. That’s why very often in this book, you will see some code immediately followed by a table, a picture or just some text. If you go on the book’s website you will find all the code, and you can try running and modifying every example yourself.\nYou just saw how a cell that outputs a table looks inside the book. Here is an example of a cell that outputs text:\n\n1+1\n\n2\n\n\nJupyter will always print or show the result of the last line (if there is one). For instance, here is an example of a cell that outputs an image:\n\nimg = PILImage.create(image_cat())\nimg.to_thumb(192)\n\n\n\n\n\n\n\n\n\n\nEnd sidebar\nSo, how do we know if this model is any good? In the last column of the table you can see the error rate, which is the proportion of images that were incorrectly identified. The error rate serves as our metric—our measure of model quality, chosen to be intuitive and comprehensible. As you can see, the model is nearly perfect, even though the training time was only a few seconds (not including the one-time downloading of the dataset and the pretrained model). In fact, the accuracy you’ve achieved already is far better than anybody had ever achieved just 10 years ago!\nFinally, let’s check that this model actually works. Go and get a photo of a dog, or a cat; if you don’t have one handy, just search Google Images and download an image that you find there. Now execute the cell with uploader defined. It will output a button you can click, so you can select the image you want to classify:\n\nuploader = widgets.FileUpload()\nuploader\n\n\n\n\n\n\n\n\n\n\nNow you can pass the uploaded file to the model. Make sure that it is a clear photo of a single dog or a cat, and not a line drawing, cartoon, or similar. The notebook will tell you whether it thinks it is a dog or a cat, and how confident it is. Hopefully, you’ll find that your model did a great job:\n\nimg = PILImage.create(uploader.data[0])\nis_cat,_,probs = learn.predict(img)\nprint(f\"Is this a cat?: {is_cat}.\")\nprint(f\"Probability it's a cat: {probs[1].item():.6f}\")\n\n\n\n\nIs this a cat?: True.\nProbability it's a cat: 1.000000\n\n\nCongratulations on your first classifier!\nBut what does this mean? What did you actually do? In order to explain this, let’s zoom out again to take in the big picture.\n\n\nWhat Is Machine Learning?\nYour classifier is a deep learning model. As was already mentioned, deep learning models use neural networks, which originally date from the 1950s and have become powerful very recently thanks to recent advancements.\nAnother key piece of context is that deep learning is just a modern area in the more general discipline of machine learning. To understand the essence of what you did when you trained your own classification model, you don’t need to understand deep learning. It is enough to see how your model and your training process are examples of the concepts that apply to machine learning in general.\nSo in this section, we will describe what machine learning is. We will look at the key concepts, and show how they can be traced back to the original essay that introduced them.\nMachine learning is, like regular programming, a way to get computers to complete a specific task. But how would we use regular programming to do what we just did in the last section: recognize dogs versus cats in photos? We would have to write down for the computer the exact steps necessary to complete the task.\nNormally, it’s easy enough for us to write down the steps to complete a task when we’re writing a program. We just think about the steps we’d take if we had to do the task by hand, and then we translate them into code. For instance, we can write a function that sorts a list. In general, we’d write a function that looks something like Figure 1.5 (where inputs might be an unsorted list, and results a sorted list).\n\n\n\n\n\n\n\n\nFigure 1.5: A traditional program\n\n\n\n\n\nBut for recognizing objects in a photo that’s a bit tricky; what are the steps we take when we recognize an object in a picture? We really don’t know, since it all happens in our brain without us being consciously aware of it!\nRight back at the dawn of computing, in 1949, an IBM researcher named Arthur Samuel started working on a different way to get computers to complete tasks, which he called machine learning. In his classic 1962 essay “Artificial Intelligence: A Frontier of Automation”, he wrote:\n\nProgramming a computer for such computations is, at best, a difficult task, not primarily because of any inherent complexity in the computer itself but, rather, because of the need to spell out every minute step of the process in the most exasperating detail. Computers, as any programmer will tell you, are giant morons, not giant brains.\n\nHis basic idea was this: instead of telling the computer the exact steps required to solve a problem, show it examples of the problem to solve, and let it figure out how to solve it itself. This turned out to be very effective: by 1961 his checkers-playing program had learned so much that it beat the Connecticut state champion! Here’s how he described his idea (from the same essay as above):\n\nSuppose we arrange for some automatic means of testing the effectiveness of any current weight assignment in terms of actual performance and provide a mechanism for altering the weight assignment so as to maximize the performance. We need not go into the details of such a procedure to see that it could be made entirely automatic and to see that a machine so programmed would “learn” from its experience.\n\nThere are a number of powerful concepts embedded in this short statement:\n\nThe idea of a “weight assignment”\nThe fact that every weight assignment has some “actual performance”\nThe requirement that there be an “automatic means” of testing that performance,\n\nThe need for a “mechanism” (i.e., another automatic process) for improving the performance by changing the weight assignments\n\nLet us take these concepts one by one, in order to understand how they fit together in practice. First, we need to understand what Samuel means by a weight assignment.\nWeights are just variables, and a weight assignment is a particular choice of values for those variables. The program’s inputs are values that it processes in order to produce its results—for instance, taking image pixels as inputs, and returning the classification “dog” as a result. The program’s weight assignments are other values that define how the program will operate.\nSince they will affect the program they are in a sense another kind of input, so we will update our basic picture in Figure 1.5 and replace it with Figure 1.6 in order to take this into account.\n\n\n\n\n\n\n\n\nFigure 1.6: A program using weight assignment\n\n\n\n\n\nWe’ve changed the name of our box from program to model. This is to follow modern terminology and to reflect that the model is a special kind of program: it’s one that can do many different things, depending on the weights. It can be implemented in many different ways. For instance, in Samuel’s checkers program, different values of the weights would result in different checkers-playing strategies.\n(By the way, what Samuel called “weights” are most generally referred to as model parameters these days, in case you have encountered that term. The term weights is reserved for a particular type of model parameter.)\nNext, Samuel said we need an automatic means of testing the effectiveness of any current weight assignment in terms of actual performance. In the case of his checkers program, the “actual performance” of a model would be how well it plays. And you could automatically test the performance of two models by setting them to play against each other, and seeing which one usually wins.\nFinally, he says we need a mechanism for altering the weight assignment so as to maximize the performance. For instance, we could look at the difference in weights between the winning model and the losing model, and adjust the weights a little further in the winning direction.\nWe can now see why he said that such a procedure could be made entirely automatic and… a machine so programmed would “learn” from its experience. Learning would become entirely automatic when the adjustment of the weights was also automatic—when instead of us improving a model by adjusting its weights manually, we relied on an automated mechanism that produced adjustments based on performance.\nFigure 1.7 shows the full picture of Samuel’s idea of training a machine learning model.\n\n\n\n\n\n\n\n\nFigure 1.7: Training a machine learning model\n\n\n\n\n\nNotice the distinction between the model’s results (e.g., the moves in a checkers game) and its performance (e.g., whether it wins the game, or how quickly it wins).\nAlso note that once the model is trained—that is, once we’ve chosen our final, best, favorite weight assignment—then we can think of the weights as being part of the model, since we’re not varying them any more.\nTherefore, actually using a model after it’s trained looks like Figure 1.8.\n\n\n\n\n\n\n\n\nFigure 1.8: Using a trained model as a program\n\n\n\n\n\nThis looks identical to our original diagram in Figure 1.5, just with the word program replaced with model. This is an important insight: a trained model can be treated just like a regular computer program.\n\njargon: Machine Learning: The training of programs developed by allowing a computer to learn from its experience, rather than through manually coding the individual steps.\n\n\n\nWhat Is a Neural Network?\nIt’s not too hard to imagine what the model might look like for a checkers program. There might be a range of checkers strategies encoded, and some kind of search mechanism, and then the weights could vary how strategies are selected, what parts of the board are focused on during a search, and so forth. But it’s not at all obvious what the model might look like for an image recognition program, or for understanding text, or for many other interesting problems we might imagine.\nWhat we would like is some kind of function that is so flexible that it could be used to solve any given problem, just by varying its weights. Amazingly enough, this function actually exists! It’s the neural network, which we already discussed. That is, if you regard a neural network as a mathematical function, it turns out to be a function which is extremely flexible depending on its weights. A mathematical proof called the universal approximation theorem shows that this function can solve any problem to any level of accuracy, in theory. The fact that neural networks are so flexible means that, in practice, they are often a suitable kind of model, and you can focus your effort on the process of training them—that is, of finding good weight assignments.\nBut what about that process? One could imagine that you might need to find a new “mechanism” for automatically updating weights for every problem. This would be laborious. What we’d like here as well is a completely general way to update the weights of a neural network, to make it improve at any given task. Conveniently, this also exists!\nThis is called stochastic gradient descent (SGD). We’ll see how neural networks and SGD work in detail in Chapter 4, as well as explaining the universal approximation theorem. For now, however, we will instead use Samuel’s own words: We need not go into the details of such a procedure to see that it could be made entirely automatic and to see that a machine so programmed would “learn” from its experience.\n\nJ: Don’t worry, neither SGD nor neural nets are mathematically complex. Both nearly entirely rely on addition and multiplication to do their work (but they do a lot of addition and multiplication!). The main reaction we hear from students when they see the details is: “Is that all it is?”\n\nIn other words, to recap, a neural network is a particular kind of machine learning model, which fits right in to Samuel’s original conception. Neural networks are special because they are highly flexible, which means they can solve an unusually wide range of problems just by finding the right weights. This is powerful, because stochastic gradient descent provides us a way to find those weight values automatically.\nHaving zoomed out, let’s now zoom back in and revisit our image classification problem using Samuel’s framework.\nOur inputs are the images. Our weights are the weights in the neural net. Our model is a neural net. Our results are the values that are calculated by the neural net, like “dog” or “cat.”\nWhat about the next piece, an automatic means of testing the effectiveness of any current weight assignment in terms of actual performance? Determining “actual performance” is easy enough: we can simply define our model’s performance as its accuracy at predicting the correct answers.\nPutting this all together, and assuming that SGD is our mechanism for updating the weight assignments, we can see how our image classifier is a machine learning model, much like Samuel envisioned.\n\n\nA Bit of Deep Learning Jargon\nSamuel was working in the 1960s, and since then terminology has changed. Here is the modern deep learning terminology for all the pieces we have discussed:\n\nThe functional form of the model is called its architecture (but be careful—sometimes people use model as a synonym of architecture, so this can get confusing).\nThe weights are called parameters.\nThe predictions are calculated from the independent variable, which is the data not including the labels.\nThe results of the model are called predictions.\nThe measure of performance is called the loss.\nThe loss depends not only on the predictions, but also the correct labels (also known as targets or the dependent variable); e.g., “dog” or “cat.”\n\nAfter making these changes, our diagram in Figure 1.7 looks like Figure 1.9.\n\n\n\n\n\n\n\n\nFigure 1.9: Detailed training loop\n\n\n\n\n\n\n\nLimitations Inherent To Machine Learning\nFrom this picture we can now see some fundamental things about training a deep learning model:\n\nA model cannot be created without data.\nA model can only learn to operate on the patterns seen in the input data used to train it.\nThis learning approach only creates predictions, not recommended actions.\nIt’s not enough to just have examples of input data; we need labels for that data too (e.g., pictures of dogs and cats aren’t enough to train a model; we need a label for each one, saying which ones are dogs, and which are cats).\n\nGenerally speaking, we’ve seen that most organizations that say they don’t have enough data, actually mean they don’t have enough labeled data. If any organization is interested in doing something in practice with a model, then presumably they have some inputs they plan to run their model against. And presumably they’ve been doing that some other way for a while (e.g., manually, or with some heuristic program), so they have data from those processes! For instance, a radiology practice will almost certainly have an archive of medical scans (since they need to be able to check how their patients are progressing over time), but those scans may not have structured labels containing a list of diagnoses or interventions (since radiologists generally create free-text natural language reports, not structured data). We’ll be discussing labeling approaches a lot in this book, because it’s such an important issue in practice.\nSince these kinds of machine learning models can only make predictions (i.e., attempt to replicate labels), this can result in a significant gap between organizational goals and model capabilities. For instance, in this book you’ll learn how to create a recommendation system that can predict what products a user might purchase. This is often used in e-commerce, such as to customize products shown on a home page by showing the highest-ranked items. But such a model is generally created by looking at a user and their buying history (inputs) and what they went on to buy or look at (labels), which means that the model is likely to tell you about products the user already has or already knows about, rather than new products that they are most likely to be interested in hearing about. That’s very different to what, say, an expert at your local bookseller might do, where they ask questions to figure out your taste, and then tell you about authors or series that you’ve never heard of before.\nAnother critical insight comes from considering how a model interacts with its environment. This can create feedback loops, as described here:\n\nA predictive policing model is created based on where arrests have been made in the past. In practice, this is not actually predicting crime, but rather predicting arrests, and is therefore partially simply reflecting biases in existing policing processes.\nLaw enforcement officers then might use that model to decide where to focus their police activity, resulting in increased arrests in those areas.\nData on these additional arrests would then be fed back in to retrain future versions of the model.\n\nThis is a positive feedback loop, where the more the model is used, the more biased the data becomes, making the model even more biased, and so forth.\nFeedback loops can also create problems in commercial settings. For instance, a video recommendation system might be biased toward recommending content consumed by the biggest watchers of video (e.g., conspiracy theorists and extremists tend to watch more online video content than the average), resulting in those users increasing their video consumption, resulting in more of those kinds of videos being recommended. We’ll consider this topic more in detail in Chapter 3.\nNow that you have seen the base of the theory, let’s go back to our code example and see in detail how the code corresponds to the process we just described.\n\n\nHow Our Image Recognizer Works\nLet’s see just how our image recognizer code maps to these ideas. We’ll put each line into a separate cell, and look at what each one is doing (we won’t explain every detail of every parameter yet, but will give a description of the important bits; full details will come later in the book).\nThe first line imports all of the fastai.vision library.\nfrom fastai.vision.all import *\nThis gives us all of the functions and classes we will need to create a wide variety of computer vision models.\n\nJ: A lot of Python coders recommend avoiding importing a whole library like this (using the import * syntax), because in large software projects it can cause problems. However, for interactive work such as in a Jupyter notebook, it works great. The fastai library is specially designed to support this kind of interactive use, and it will only import the necessary pieces into your environment.\n\nThe second line downloads a standard dataset from the fast.ai datasets collection (if not previously downloaded) to your server, extracts it (if not previously extracted), and returns a Path object with the extracted location:\npath = untar_data(URLs.PETS)/'images'\n\nS: Throughout my time studying at fast.ai, and even still today, I’ve learned a lot about productive coding practices. The fastai library and fast.ai notebooks are full of great little tips that have helped make me a better programmer. For instance, notice that the fastai library doesn’t just return a string containing the path to the dataset, but a Path object. This is a really useful class from the Python 3 standard library that makes accessing files and directories much easier. If you haven’t come across it before, be sure to check out its documentation or a tutorial and try it out. Note that the https://book.fast.ai[website] contains links to recommended tutorials for each chapter. I’ll keep letting you know about little coding tips I’ve found useful as we come across them.\n\nIn the third line we define a function, is_cat, which labels cats based on a filename rule provided by the dataset creators:\ndef is_cat(x): return x[0].isupper()\nWe use that function in the fourth line, which tells fastai what kind of dataset we have and how it is structured:\ndls = ImageDataLoaders.from_name_func(\n    path, get_image_files(path), valid_pct=0.2, seed=42,\n    label_func=is_cat, item_tfms=Resize(224))\nThere are various different classes for different kinds of deep learning datasets and problems—here we’re using ImageDataLoaders. The first part of the class name will generally be the type of data you have, such as image, or text.\nThe other important piece of information that we have to tell fastai is how to get the labels from the dataset. Computer vision datasets are normally structured in such a way that the label for an image is part of the filename, or path—most commonly the parent folder name. fastai comes with a number of standardized labeling methods, and ways to write your own. Here we’re telling fastai to use the is_cat function we just defined.\nFinally, we define the Transforms that we need. A Transform contains code that is applied automatically during training; fastai includes many predefined Transforms, and adding new ones is as simple as creating a Python function. There are two kinds: item_tfms are applied to each item (in this case, each item is resized to a 224-pixel square), while batch_tfms are applied to a batch of items at a time using the GPU, so they’re particularly fast (we’ll see many examples of these throughout this book).\nWhy 224 pixels? This is the standard size for historical reasons (old pretrained models require this size exactly), but you can pass pretty much anything. If you increase the size, you’ll often get a model with better results (since it will be able to focus on more details), but at the price of speed and memory consumption; the opposite is true if you decrease the size.\n\nNote: Classification and Regression: classification and regression have very specific meanings in machine learning. These are the two main types of model that we will be investigating in this book. A classification model is one which attempts to predict a class, or category. That is, it’s predicting from a number of discrete possibilities, such as “dog” or “cat.” A regression model is one which attempts to predict one or more numeric quantities, such as a temperature or a location. Sometimes people use the word regression to refer to a particular kind of model called a linear regression model; this is a bad practice, and we won’t be using that terminology in this book!\n\nThe Pet dataset contains 7,390 pictures of dogs and cats, consisting of 37 different breeds. Each image is labeled using its filename: for instance the file great_pyrenees_173.jpg is the 173rd example of an image of a Great Pyrenees breed dog in the dataset. The filenames start with an uppercase letter if the image is a cat, and a lowercase letter otherwise. We have to tell fastai how to get labels from the filenames, which we do by calling from_name_func (which means that labels can be extracted using a function applied to the filename), and passing is_cat, which returns x[0].isupper(), which evaluates to True if the first letter is uppercase (i.e., it’s a cat).\nThe most important parameter to mention here is valid_pct=0.2. This tells fastai to hold out 20% of the data and not use it for training the model at all. This 20% of the data is called the validation set; the remaining 80% is called the training set. The validation set is used to measure the accuracy of the model. By default, the 20% that is held out is selected randomly. The parameter seed=42 sets the random seed to the same value every time we run this code, which means we get the same validation set every time we run it—this way, if we change our model and retrain it, we know that any differences are due to the changes to the model, not due to having a different random validation set.\nfastai will always show you your model’s accuracy using only the validation set, never the training set. This is absolutely critical, because if you train a large enough model for a long enough time, it will eventually memorize the label of every item in your dataset! The result will not actually be a useful model, because what we care about is how well our model works on previously unseen images. That is always our goal when creating a model: for it to be useful on data that the model only sees in the future, after it has been trained.\nEven when your model has not fully memorized all your data, earlier on in training it may have memorized certain parts of it. As a result, the longer you train for, the better your accuracy will get on the training set; the validation set accuracy will also improve for a while, but eventually it will start getting worse as the model starts to memorize the training set, rather than finding generalizable underlying patterns in the data. When this happens, we say that the model is overfitting.\nFigure 1.10 shows what happens when you overfit, using a simplified example where we have just one parameter, and some randomly generated data based on the function x**2. As you can see, although the predictions in the overfit model are accurate for data near the observed data points, they are way off when outside of that range.\n\n\n\n\n\n\nFigure 1.10: Example of overfitting\n\n\n\nOverfitting is the single most important and challenging issue when training for all machine learning practitioners, and all algorithms. As you will see, it is very easy to create a model that does a great job at making predictions on the exact data it has been trained on, but it is much harder to make accurate predictions on data the model has never seen before. And of course, this is the data that will actually matter in practice. For instance, if you create a handwritten digit classifier (as we will very soon!) and use it to recognize numbers written on checks, then you are never going to see any of the numbers that the model was trained on—checks will have slightly different variations of writing to deal with. You will learn many methods to avoid overfitting in this book. However, you should only use those methods after you have confirmed that overfitting is actually occurring (i.e., you have actually observed the validation accuracy getting worse during training). We often see practitioners using over-fitting avoidance techniques even when they have enough data that they didn’t need to do so, ending up with a model that may be less accurate than what they could have achieved.\n\nimportant: Validation Set: When you train a model, you must always have both a training set and a validation set, and must measure the accuracy of your model only on the validation set. If you train for too long, with not enough data, you will see the accuracy of your model start to get worse; this is called overfitting. fastai defaults valid_pct to 0.2, so even if you forget, fastai will create a validation set for you!\n\nThe fifth line of the code training our image recognizer tells fastai to create a convolutional neural network (CNN) and specifies what architecture to use (i.e. what kind of model to create), what data we want to train it on, and what metric to use:\nlearn = vision_learner(dls, resnet34, metrics=error_rate)\nWhy a CNN? It’s the current state-of-the-art approach to creating computer vision models. We’ll be learning all about how CNNs work in this book. Their structure is inspired by how the human vision system works.\nThere are many different architectures in fastai, which we will introduce in this book (as well as discussing how to create your own). Most of the time, however, picking an architecture isn’t a very important part of the deep learning process. It’s something that academics love to talk about, but in practice it is unlikely to be something you need to spend much time on. There are some standard architectures that work most of the time, and in this case we’re using one called ResNet that we’ll be talking a lot about during the book; it is both fast and accurate for many datasets and problems. The 34 in resnet34 refers to the number of layers in this variant of the architecture (other options are 18, 50, 101, and 152). Models using architectures with more layers take longer to train, and are more prone to overfitting (i.e. you can’t train them for as many epochs before the accuracy on the validation set starts getting worse). On the other hand, when using more data, they can be quite a bit more accurate.\nWhat is a metric? A metric is a function that measures the quality of the model’s predictions using the validation set, and will be printed at the end of each epoch. In this case, we’re using error_rate, which is a function provided by fastai that does just what it says: tells you what percentage of images in the validation set are being classified incorrectly. Another common metric for classification is accuracy (which is just 1.0 - error_rate). fastai provides many more, which will be discussed throughout this book.\nThe concept of a metric may remind you of loss, but there is an important distinction. The entire purpose of loss is to define a “measure of performance” that the training system can use to update weights automatically. In other words, a good choice for loss is a choice that is easy for stochastic gradient descent to use. But a metric is defined for human consumption, so a good metric is one that is easy for you to understand, and that hews as closely as possible to what you want the model to do. At times, you might decide that the loss function is a suitable metric, but that is not necessarily the case.\nvision_learner also has a parameter pretrained, which defaults to True (so it’s used in this case, even though we haven’t specified it), which sets the weights in your model to values that have already been trained by experts to recognize a thousand different categories across 1.3 million photos (using the famous ImageNet dataset). A model that has weights that have already been trained on some other dataset is called a pretrained model. You should nearly always use a pretrained model, because it means that your model, before you’ve even shown it any of your data, is already very capable. And, as you’ll see, in a deep learning model many of these capabilities are things you’ll need, almost regardless of the details of your project. For instance, parts of pretrained models will handle edge, gradient, and color detection, which are needed for many tasks.\nWhen using a pretrained model, vision_learner will remove the last layer, since that is always specifically customized to the original training task (i.e. ImageNet dataset classification), and replace it with one or more new layers with randomized weights, of an appropriate size for the dataset you are working with. This last part of the model is known as the head.\nUsing pretrained models is the most important method we have to allow us to train more accurate models, more quickly, with less data, and less time and money. You might think that would mean that using pretrained models would be the most studied area in academic deep learning… but you’d be very, very wrong! The importance of pretrained models is generally not recognized or discussed in most courses, books, or software library features, and is rarely considered in academic papers. As we write this at the start of 2020, things are just starting to change, but it’s likely to take a while. So be careful: most people you speak to will probably greatly underestimate what you can do in deep learning with few resources, because they probably won’t deeply understand how to use pretrained models.\nUsing a pretrained model for a task different to what it was originally trained for is known as transfer learning. Unfortunately, because transfer learning is so under-studied, few domains have pretrained models available. For instance, there are currently few pretrained models available in medicine, making transfer learning challenging to use in that domain. In addition, it is not yet well understood how to use transfer learning for tasks such as time series analysis.\n\njargon: Transfer learning: Using a pretrained model for a task different to what it was originally trained for.\n\nThe sixth line of our code tells fastai how to fit the model:\nlearn.fine_tune(1)\nAs we’ve discussed, the architecture only describes a template for a mathematical function; it doesn’t actually do anything until we provide values for the millions of parameters it contains.\nThis is the key to deep learning—determining how to fit the parameters of a model to get it to solve your problem. In order to fit a model, we have to provide at least one piece of information: how many times to look at each image (known as number of epochs). The number of epochs you select will largely depend on how much time you have available, and how long you find it takes in practice to fit your model. If you select a number that is too small, you can always train for more epochs later.\nBut why is the method called fine_tune, and not fit? fastai actually does have a method called fit, which does indeed fit a model (i.e. look at images in the training set multiple times, each time updating the parameters to make the predictions closer and closer to the target labels). But in this case, we’ve started with a pretrained model, and we don’t want to throw away all those capabilities that it already has. As you’ll learn in this book, there are some important tricks to adapt a pretrained model for a new dataset—a process called fine-tuning.\n\njargon: Fine-tuning: A transfer learning technique where the parameters of a pretrained model are updated by training for additional epochs using a different task to that used for pretraining.\n\nWhen you use the fine_tune method, fastai will use these tricks for you. There are a few parameters you can set (which we’ll discuss later), but in the default form shown here, it does two steps:\n\nUse one epoch to fit just those parts of the model necessary to get the new random head to work correctly with your dataset.\nUse the number of epochs requested when calling the method to fit the entire model, updating the weights of the later layers (especially the head) faster than the earlier layers (which, as we’ll see, generally don’t require many changes from the pretrained weights).\n\nThe head of a model is the part that is newly added to be specific to the new dataset. An epoch is one complete pass through the dataset. After calling fit, the results after each epoch are printed, showing the epoch number, the training and validation set losses (the “measure of performance” used for training the model), and any metrics you’ve requested (error rate, in this case).\nSo, with all this code our model learned to recognize cats and dogs just from labeled examples. But how did it do it?\n\n\nWhat Our Image Recognizer Learned\nAt this stage we have an image recognizer that is working very well, but we have no idea what it is actually doing! Although many people complain that deep learning results in impenetrable “black box” models (that is, something that gives predictions but that no one can understand), this really couldn’t be further from the truth. There is a vast body of research showing how to deeply inspect deep learning models, and get rich insights from them. Having said that, all kinds of machine learning models (including deep learning, and traditional statistical models) can be challenging to fully understand, especially when considering how they will behave when coming across data that is very different to the data used to train them. We’ll be discussing this issue throughout this book.\nIn 2013 a PhD student, Matt Zeiler, and his supervisor, Rob Fergus, published the paper “Visualizing and Understanding Convolutional Networks”, which showed how to visualize the neural network weights learned in each layer of a model. They carefully analyzed the model that won the 2012 ImageNet competition, and used this analysis to greatly improve the model, such that they were able to go on to win the 2013 competition! Figure 1.11 is the picture that they published of the first layer’s weights.\n\n\n\n\n\n\nFigure 1.11: Activations of the first layer of a CNN (courtesy of Matthew D. Zeiler and Rob Fergus)\n\n\n\nThis picture requires some explanation. For each layer, the image part with the light gray background shows the reconstructed weights pictures, and the larger section at the bottom shows the parts of the training images that most strongly matched each set of weights. For layer 1, what we can see is that the model has discovered weights that represent diagonal, horizontal, and vertical edges, as well as various different gradients. (Note that for each layer only a subset of the features are shown; in practice there are thousands across all of the layers.) These are the basic building blocks that the model has learned for computer vision. They have been widely analyzed by neuroscientists and computer vision researchers, and it turns out that these learned building blocks are very similar to the basic visual machinery in the human eye, as well as the handcrafted computer vision features that were developed prior to the days of deep learning. The next layer is represented in Figure 1.12.\n\n\n\n\n\n\nFigure 1.12: Activations of the second layer of a CNN (courtesy of Matthew D. Zeiler and Rob Fergus)\n\n\n\nFor layer 2, there are nine examples of weight reconstructions for each of the features found by the model. We can see that the model has learned to create feature detectors that look for corners, repeating lines, circles, and other simple patterns. These are built from the basic building blocks developed in the first layer. For each of these, the right-hand side of the picture shows small patches from actual images which these features most closely match. For instance, the particular pattern in row 2, column 1 matches the gradients and textures associated with sunsets.\nFigure 1.13 shows the image from the paper showing the results of reconstructing the features of layer 3.\n\n\n\n\n\n\nFigure 1.13: Activations of the third layer of a CNN (courtesy of Matthew D. Zeiler and Rob Fergus)\n\n\n\nAs you can see by looking at the righthand side of this picture, the features are now able to identify and match with higher-level semantic components, such as car wheels, text, and flower petals. Using these components, layers four and five can identify even higher-level concepts, as shown in Figure 1.14.\n\n\n\n\n\n\nFigure 1.14: Activations of layers 4 and 5 of a CNN (courtesy of Matthew D. Zeiler and Rob Fergus)\n\n\n\nThis article was studying an older model called AlexNet that only contained five layers. Networks developed since then can have hundreds of layers—so you can imagine how rich the features developed by these models can be!\nWhen we fine-tuned our pretrained model earlier, we adapted what those last layers focus on (flowers, humans, animals) to specialize on the cats versus dogs problem. More generally, we could specialize such a pretrained model on many different tasks. Let’s have a look at some examples.\n\n\nImage Recognizers Can Tackle Non-Image Tasks\nAn image recognizer can, as its name suggests, only recognize images. But a lot of things can be represented as images, which means that an image recogniser can learn to complete many tasks.\nFor instance, a sound can be converted to a spectrogram, which is a chart that shows the amount of each frequency at each time in an audio file. Fast.ai student Ethan Sutin used this approach to easily beat the published accuracy of a state-of-the-art environmental sound detection model using a dataset of 8,732 urban sounds. fastai’s show_batch clearly shows how each different sound has a quite distinctive spectrogram, as you can see in Figure 1.15.\n\n\n\n\n\n\nFigure 1.15: show_batch with spectrograms of sounds\n\n\n\nA time series can easily be converted into an image by simply plotting the time series on a graph. However, it is often a good idea to try to represent your data in a way that makes it as easy as possible to pull out the most important components. In a time series, things like seasonality and anomalies are most likely to be of interest. There are various transformations available for time series data. For instance, fast.ai student Ignacio Oguiza created images from a time series dataset for olive oil classification, using a technique called Gramian Angular Difference Field (GADF); you can see the result in Figure 1.16. He then fed those images to an image classification model just like the one you see in this chapter. His results, despite having only 30 training set images, were well over 90% accurate, and close to the state of the art.\n\n\n\n\n\n\nFigure 1.16: Converting a time series into an image\n\n\n\nAnother interesting fast.ai student project example comes from Gleb Esman. He was working on fraud detection at Splunk, using a dataset of users’ mouse movements and mouse clicks. He turned these into pictures by drawing an image where the position, speed, and acceleration of the mouse pointer was displayed using coloured lines, and the clicks were displayed using small colored circles, as shown in Figure 1.17. He then fed this into an image recognition model just like the one we’ve used in this chapter, and it worked so well that it led to a patent for this approach to fraud analytics!\n\n\n\n\n\n\nFigure 1.17: Converting computer mouse behavior to an image\n\n\n\nAnother example comes from the paper “Malware Classification with Deep Convolutional Neural Networks” by Mahmoud Kalash et al., which explains that “the malware binary file is divided into 8-bit sequences which are then converted to equivalent decimal values. This decimal vector is reshaped and a gray-scale image is generated that represents the malware sample,” like in Figure 1.18.\n\n\n\n\n\n\nFigure 1.18: Malware classification process\n\n\n\nThe authors then show “pictures” generated through this process of malware in different categories, as shown in Figure 1.19.\n\n\n\n\n\n\nFigure 1.19: Malware examples\n\n\n\nAs you can see, the different types of malware look very distinctive to the human eye. The model the researchers trained based on this image representation was more accurate at malware classification than any previous approach shown in the academic literature. This suggests a good rule of thumb for converting a dataset into an image representation: if the human eye can recognize categories from the images, then a deep learning model should be able to do so too.\nIn general, you’ll find that a small number of general approaches in deep learning can go a long way, if you’re a bit creative in how you represent your data! You shouldn’t think of approaches like the ones described here as “hacky workarounds,” because actually they often (as here) beat previously state-of-the-art results. These really are the right ways to think about these problem domains.\n\n\nJargon Recap\nWe just covered a lot of information so let’s recap briefly, Table 1.2 provides a handy vocabulary.\n\n\n\nTable 1.2: Deep learning vocabulary\n\n\n\n\n\n\n\n\n\nTerm\nMeaning\n\n\n\n\nLabel\nThe data that we’re trying to predict, such as “dog” or “cat”\n\n\nArchitecture\nThe template of the model that we’re trying to fit; the actual mathematical function that we’re passing the input data and parameters to\n\n\nModel\nThe combination of the architecture with a particular set of parameters\n\n\nParameters\nThe values in the model that change what task it can do, and are updated through model training\n\n\nFit\nUpdate the parameters of the model such that the predictions of the model using the input data match the target labels\n\n\nTrain\nA synonym for fit\n\n\nPretrained model\nA model that has already been trained, generally using a large dataset, and will be fine-tuned\n\n\nFine-tune\nUpdate a pretrained model for a different task\n\n\nEpoch\nOne complete pass through the input data\n\n\nLoss\nA measure of how good the model is, chosen to drive training via SGD\n\n\nMetric\nA measurement of how good the model is, using the validation set, chosen for human consumption\n\n\nValidation set\nA set of data held out from training, used only for measuring how good the model is\n\n\nTraining set\nThe data used for fitting the model; does not include any data from the validation set\n\n\nOverfitting\nTraining a model in such a way that it remembers specific features of the input data, rather than generalizing well to data not seen during training\n\n\nCNN\nConvolutional neural network; a type of neural network that works particularly well for computer vision tasks\n\n\n\n\n\n\nWith this vocabulary in hand, we are now in a position to bring together all the key concepts introduced so far. Take a moment to review those definitions and read the following summary. If you can follow the explanation, then you’re well equipped to understand the discussions to come.\nMachine learning is a discipline where we define a program not by writing it entirely ourselves, but by learning from data. Deep learning is a specialty within machine learning that uses neural networks with multiple layers. Image classification is a representative example (also known as image recognition). We start with labeled data; that is, a set of images where we have assigned a label to each image indicating what it represents. Our goal is to produce a program, called a model, which, given a new image, will make an accurate prediction regarding what that new image represents.\nEvery model starts with a choice of architecture, a general template for how that kind of model works internally. The process of training (or fitting) the model is the process of finding a set of parameter values (or weights) that specialize that general architecture into a model that works well for our particular kind of data. In order to define how well a model does on a single prediction, we need to define a loss function, which determines how we score a prediction as good or bad.\nTo make the training process go faster, we might start with a pretrained model—a model that has already been trained on someone else’s data. We can then adapt it to our data by training it a bit more on our data, a process called fine-tuning.\nWhen we train a model, a key concern is to ensure that our model generalizes—that is, that it learns general lessons from our data which also apply to new items it will encounter, so that it can make good predictions on those items. The risk is that if we train our model badly, instead of learning general lessons it effectively memorizes what it has already seen, and then it will make poor predictions about new images. Such a failure is called overfitting. In order to avoid this, we always divide our data into two parts, the training set and the validation set. We train the model by showing it only the training set and then we evaluate how well the model is doing by seeing how well it performs on items from the validation set. In this way, we check if the lessons the model learns from the training set are lessons that generalize to the validation set. In order for a person to assess how well the model is doing on the validation set overall, we define a metric. During the training process, when the model has seen every item in the training set, we call that an epoch.\nAll these concepts apply to machine learning in general. That is, they apply to all sorts of schemes for defining a model by training it with data. What makes deep learning distinctive is a particular class of architectures: the architectures based on neural networks. In particular, tasks like image classification rely heavily on convolutional neural networks, which we will discuss shortly.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#deep-learning-is-not-just-for-image-classification",
    "href": "intro.html#deep-learning-is-not-just-for-image-classification",
    "title": "1  Your Deep Learning Journey",
    "section": "1.7 Deep Learning Is Not Just for Image Classification",
    "text": "1.7 Deep Learning Is Not Just for Image Classification\nDeep learning’s effectiveness for classifying images has been widely discussed in recent years, even showing superhuman results on complex tasks like recognizing malignant tumors in CT scans. But it can do a lot more than this, as we will show here.\nFor instance, let’s talk about something that is critically important for autonomous vehicles: localizing objects in a picture. If a self-driving car doesn’t know where a pedestrian is, then it doesn’t know how to avoid one! Creating a model that can recognize the content of every individual pixel in an image is called segmentation. Here is how we can train a segmentation model with fastai, using a subset of the Camvid dataset from the paper “Semantic Object Classes in Video: A High-Definition Ground Truth Database” by Gabruel J. Brostow, Julien Fauqueur, and Roberto Cipolla:\n\npath = untar_data(URLs.CAMVID_TINY)\ndls = SegmentationDataLoaders.from_label_func(\n    path, bs=8, fnames = get_image_files(path/\"images\"),\n    label_func = lambda o: path/'labels'/f'{o.stem}_P{o.suffix}',\n    codes = np.loadtxt(path/'codes.txt', dtype=str)\n)\n\nlearn = unet_learner(dls, resnet34)\nlearn.fine_tune(8)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n2.641862\n2.140568\n00:02\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n1.624964\n1.464210\n00:02\n\n\n1\n1.454148\n1.284032\n00:02\n\n\n2\n1.342955\n1.048562\n00:02\n\n\n3\n1.199765\n0.852787\n00:02\n\n\n4\n1.078090\n0.838206\n00:02\n\n\n5\n0.975496\n0.746806\n00:02\n\n\n6\n0.892793\n0.725384\n00:02\n\n\n7\n0.827645\n0.726778\n00:02\n\n\n\n\n\nWe are not even going to walk through this code line by line, because it is nearly identical to our previous example! (Although we will be doing a deep dive into segmentation models in Chapter 15, along with all of the other models that we are briefly introducing in this chapter, and many, many more.)\nWe can visualize how well it achieved its task, by asking the model to color-code each pixel of an image. As you can see, it nearly perfectly classifies every pixel in every object. For instance, notice that all of the cars are overlaid with the same color and all of the trees are overlaid with the same color (in each pair of images, the lefthand image is the ground truth label and the right is the prediction from the model):\n\nlearn.show_results(max_n=6, figsize=(7,8))\n\n\n\n\n\n\n\n\n\n\n\nOne other area where deep learning has dramatically improved in the last couple of years is natural language processing (NLP). Computers can now generate text, translate automatically from one language to another, analyze comments, label words in sentences, and much more. Here is all of the code necessary to train a model that can classify the sentiment of a movie review better than anything that existed in the world just five years ago:\n\nfrom fastai.text.all import *\n\ndls = TextDataLoaders.from_folder(untar_data(URLs.IMDB), valid='test')\nlearn = text_classifier_learner(dls, AWD_LSTM, drop_mult=0.5, metrics=accuracy)\nlearn.fine_tune(4, 1e-2)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.878776\n0.748753\n0.500400\n01:27\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.679118\n0.674778\n0.584040\n02:45\n\n\n1\n0.653671\n0.670396\n0.618040\n02:55\n\n\n2\n0.598665\n0.551815\n0.718920\n05:28\n\n\n3\n0.556812\n0.507450\n0.752480\n03:11\n\n\n\n\n\n#clean If you hit a “CUDA out of memory error” after running this cell, click on the menu Kernel, then restart. Instead of executing the cell above, copy and paste the following code in it:\nfrom fastai.text.all import *\n\ndls = TextDataLoaders.from_folder(untar_data(URLs.IMDB), valid='test', bs=32)\nlearn = text_classifier_learner(dls, AWD_LSTM, drop_mult=0.5, metrics=accuracy)\nlearn.fine_tune(4, 1e-2)\nThis reduces the batch size to 32 (we will explain this later). If you keep hitting the same error, change 32 to 16.\nThis model is using the “IMDb Large Movie Review dataset” from the paper “Learning Word Vectors for Sentiment Analysis” by Andrew Maas et al. It works well with movie reviews of many thousands of words, but let’s test it out on a very short one to see how it does its thing:\n\nlearn.predict(\"I really liked that movie!\")\n\n\n\n\n('neg', tensor(0), tensor([0.8786, 0.1214]))\n\n\nHere we can see the model has considered the review to be positive. The second part of the result is the index of “pos” in our data vocabulary and the last part is the probabilities attributed to each class (99.6% for “pos” and 0.4% for “neg”).\nNow it’s your turn! Write your own mini movie review, or copy one from the internet, and you can see what this model thinks about it.\n\nSidebar: The Order Matters\nIn a Jupyter notebook, the order in which you execute each cell is very important. It’s not like Excel, where everything gets updated as soon as you type something anywhere—it has an inner state that gets updated each time you execute a cell. For instance, when you run the first cell of the notebook (with the “CLICK ME” comment), you create an object called learn that contains a model and data for an image classification problem. If we were to run the cell just shown in the text (the one that predicts if a review is good or not) straight after, we would get an error as this learn object does not contain a text classification model. This cell needs to be run after the one containing:\nfrom fastai.text.all import *\n\ndls = TextDataLoaders.from_folder(untar_data(URLs.IMDB), valid='test')\nlearn = text_classifier_learner(dls, AWD_LSTM, drop_mult=0.5, \n                                metrics=accuracy)\nlearn.fine_tune(4, 1e-2)\nThe outputs themselves can be deceiving, because they include the results of the last time the cell was executed; if you change the code inside a cell without executing it, the old (misleading) results will remain.\nExcept when we mention it explicitly, the notebooks provided on the book website are meant to be run in order, from top to bottom. In general, when experimenting, you will find yourself executing cells in any order to go fast (which is a super neat feature of Jupyter Notebook), but once you have explored and arrived at the final version of your code, make sure you can run the cells of your notebooks in order (your future self won’t necessarily remember the convoluted path you took otherwise!).\nIn command mode, pressing 0 twice will restart the kernel (which is the engine powering your notebook). This will wipe your state clean and make it as if you had just started in the notebook. Choose Run All Above from the Cell menu to run all cells above the point where you are. We have found this to be very useful when developing the fastai library.\n\n\nEnd sidebar\nIf you ever have any questions about a fastai method, you should use the function doc, passing it the method name:\ndoc(learn.predict)\nThis will make a small window pop up with content like this:\n\nA brief one-line explanation is provided by doc. The “Show in docs” link takes you to the full documentation, where you’ll find all the details and lots of examples. Also, most of fastai’s methods are just a handful of lines, so you can click the “source” link to see exactly what’s going on behind the scenes.\nLet’s move on to something much less sexy, but perhaps significantly more widely commercially useful: building models from plain tabular data.\n\njargon: Tabular: Data that is in the form of a table, such as from a spreadsheet, database, or CSV file. A tabular model is a model that tries to predict one column of a table based on information in other columns of the table.\n\nIt turns out that looks very similar too. Here is the code necessary to train a model that will predict whether a person is a high-income earner, based on their socioeconomic background:\n\nfrom fastai.tabular.all import *\npath = untar_data(URLs.ADULT_SAMPLE)\n\ndls = TabularDataLoaders.from_csv(path/'adult.csv', path=path, y_names=\"salary\",\n    cat_names = ['workclass', 'education', 'marital-status', 'occupation',\n                 'relationship', 'race'],\n    cont_names = ['age', 'fnlwgt', 'education-num'],\n    procs = [Categorify, FillMissing, Normalize])\n\nlearn = tabular_learner(dls, metrics=accuracy)\n\nAs you see, we had to tell fastai which columns are categorical (that is, contain values that are one of a discrete set of choices, such as occupation) and which are continuous (that is, contain a number that represents a quantity, such as age).\nThere is no pretrained model available for this task (in general, pretrained models are not widely available for any tabular modeling tasks, although some organizations have created them for internal use), so we don’t use fine_tune in this case. Instead we use fit_one_cycle, the most commonly used method for training fastai models from scratch (i.e. without transfer learning):\n\nlearn.fit_one_cycle(3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.372397\n0.357177\n0.832463\n00:08\n\n\n1\n0.351544\n0.341505\n0.841523\n00:08\n\n\n2\n0.338763\n0.339184\n0.845670\n00:08\n\n\n\n\n\nThis model is using the Adult dataset, from the paper “Scaling Up the Accuracy of Naive-Bayes Classifiers: a Decision-Tree Hybrid” by Rob Kohavi, which contains some demographic data about individuals (like their education, marital status, race, sex, and whether or not they have an annual income greater than $50k). The model is over 80% accurate, and took around 30 seconds to train.\nLet’s look at one more. Recommendation systems are very important, particularly in e-commerce. Companies like Amazon and Netflix try hard to recommend products or movies that users might like. Here’s how to train a model that will predict movies people might like, based on their previous viewing habits, using the MovieLens dataset:\n\nfrom fastai.collab import *\npath = untar_data(URLs.ML_SAMPLE)\ndls = CollabDataLoaders.from_csv(path/'ratings.csv')\nlearn = collab_learner(dls, y_range=(0.5,5.5))\nlearn.fine_tune(10)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n1.510897\n1.410028\n00:00\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\ntime\n\n\n\n\n0\n1.375435\n1.350930\n00:00\n\n\n1\n1.270062\n1.173962\n00:00\n\n\n2\n1.023159\n0.879298\n00:00\n\n\n3\n0.797398\n0.739787\n00:00\n\n\n4\n0.685500\n0.700903\n00:00\n\n\n5\n0.646508\n0.686387\n00:00\n\n\n6\n0.623985\n0.681087\n00:00\n\n\n7\n0.606319\n0.676885\n00:00\n\n\n8\n0.606975\n0.675833\n00:00\n\n\n9\n0.602670\n0.675682\n00:00\n\n\n\n\n\nThis model is predicting movie ratings on a scale of 0.5 to 5.0 to within around 0.6 average error. Since we’re predicting a continuous number, rather than a category, we have to tell fastai what range our target has, using the y_range parameter.\nAlthough we’re not actually using a pretrained model (for the same reason that we didn’t for the tabular model), this example shows that fastai lets us use fine_tune anyway in this case (you’ll learn how and why this works in Chapter 5). Sometimes it’s best to experiment with fine_tune versus fit_one_cycle to see which works best for your dataset.\nWe can use the same show_results call we saw earlier to view a few examples of user and movie IDs, actual ratings, and predictions:\n\nlearn.show_results()\n\n\n\n\n\n\n\n\nuserId\nmovieId\nrating\nrating_pred\n\n\n\n\n0\n66.0\n79.0\n4.0\n3.978900\n\n\n1\n97.0\n15.0\n4.0\n3.851795\n\n\n2\n55.0\n79.0\n3.5\n3.945623\n\n\n3\n98.0\n91.0\n4.0\n4.458704\n\n\n4\n53.0\n7.0\n5.0\n4.670005\n\n\n5\n26.0\n69.0\n5.0\n4.319870\n\n\n6\n81.0\n16.0\n4.5\n4.426761\n\n\n7\n80.0\n7.0\n4.0\n4.046183\n\n\n8\n51.0\n94.0\n5.0\n3.499996\n\n\n\n\n\n\n\nSidebar: Datasets: Food for Models\nYou’ve already seen quite a few models in this section, each one trained using a different dataset to do a different task. In machine learning and deep learning, we can’t do anything without data. So, the people that create datasets for us to train our models on are the (often underappreciated) heroes. Some of the most useful and important datasets are those that become important academic baselines; that is, datasets that are widely studied by researchers and used to compare algorithmic changes. Some of these become household names (at least, among households that train models!), such as MNIST, CIFAR-10, and ImageNet.\nThe datasets used in this book have been selected because they provide great examples of the kinds of data that you are likely to encounter, and the academic literature has many examples of model results using these datasets to which you can compare your work.\nMost datasets used in this book took the creators a lot of work to build. For instance, later in the book we’ll be showing you how to create a model that can translate between French and English. The key input to this is a French/English parallel text corpus prepared back in 2009 by Professor Chris Callison-Burch of the University of Pennsylvania. This dataset contains over 20 million sentence pairs in French and English. He built the dataset in a really clever way: by crawling millions of Canadian web pages (which are often multilingual) and then using a set of simple heuristics to transform URLs of French content onto URLs pointing to the same content in English.\nAs you look at datasets throughout this book, think about where they might have come from, and how they might have been curated. Then think about what kinds of interesting datasets you could create for your own projects. (We’ll even take you step by step through the process of creating your own image dataset soon.)\nfast.ai has spent a lot of time creating cut-down versions of popular datasets that are specially designed to support rapid prototyping and experimentation, and to be easier to learn with. In this book we will often start by using one of the cut-down versions and later scale up to the full-size version (just as we’re doing in this chapter!). In fact, this is how the world’s top practitioners do their modeling in practice; they do most of their experimentation and prototyping with subsets of their data, and only use the full dataset when they have a good understanding of what they have to do.\n\n\nEnd sidebar\nEach of the models we trained showed a training and validation loss. A good validation set is one of the most important pieces of the training process. Let’s see why and learn how to create one.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#validation-sets-and-test-sets",
    "href": "intro.html#validation-sets-and-test-sets",
    "title": "1  Your Deep Learning Journey",
    "section": "1.8 Validation Sets and Test Sets",
    "text": "1.8 Validation Sets and Test Sets\nAs we’ve discussed, the goal of a model is to make predictions about data. But the model training process is fundamentally dumb. If we trained a model with all our data, and then evaluated the model using that same data, we would not be able to tell how well our model can perform on data it hasn’t seen. Without this very valuable piece of information to guide us in training our model, there is a very good chance it would become good at making predictions about that data but would perform poorly on new data.\nTo avoid this, our first step was to split our dataset into two sets: the training set (which our model sees in training) and the validation set, also known as the development set (which is used only for evaluation). This lets us test that the model learns lessons from the training data that generalize to new data, the validation data.\nOne way to understand this situation is that, in a sense, we don’t want our model to get good results by “cheating.” If it makes an accurate prediction for a data item, that should be because it has learned characteristics of that kind of item, and not because the model has been shaped by actually having seen that particular item.\nSplitting off our validation data means our model never sees it in training and so is completely untainted by it, and is not cheating in any way. Right?\nIn fact, not necessarily. The situation is more subtle. This is because in realistic scenarios we rarely build a model just by training its weight parameters once. Instead, we are likely to explore many versions of a model through various modeling choices regarding network architecture, learning rates, data augmentation strategies, and other factors we will discuss in upcoming chapters. Many of these choices can be described as choices of hyperparameters. The word reflects that they are parameters about parameters, since they are the higher-level choices that govern the meaning of the weight parameters.\nThe problem is that even though the ordinary training process is only looking at predictions on the training data when it learns values for the weight parameters, the same is not true of us. We, as modelers, are evaluating the model by looking at predictions on the validation data when we decide to explore new hyperparameter values! So subsequent versions of the model are, indirectly, shaped by us having seen the validation data. Just as the automatic training process is in danger of overfitting the training data, we are in danger of overfitting the validation data through human trial and error and exploration.\nThe solution to this conundrum is to introduce another level of even more highly reserved data, the test set. Just as we hold back the validation data from the training process, we must hold back the test set data even from ourselves. It cannot be used to improve the model; it can only be used to evaluate the model at the very end of our efforts. In effect, we define a hierarchy of cuts of our data, based on how fully we want to hide it from training and modeling processes: training data is fully exposed, the validation data is less exposed, and test data is totally hidden. This hierarchy parallels the different kinds of modeling and evaluation processes themselves—the automatic training process with back propagation, the more manual process of trying different hyper-parameters between training sessions, and the assessment of our final result.\nThe test and validation sets should have enough data to ensure that you get a good estimate of your accuracy. If you’re creating a cat detector, for instance, you generally want at least 30 cats in your validation set. That means that if you have a dataset with thousands of items, using the default 20% validation set size may be more than you need. On the other hand, if you have lots of data, using some of it for validation probably doesn’t have any downsides.\nHaving two levels of “reserved data”—a validation set and a test set, with one level representing data that you are virtually hiding from yourself—may seem a bit extreme. But the reason it is often necessary is because models tend to gravitate toward the simplest way to do good predictions (memorization), and we as fallible humans tend to gravitate toward fooling ourselves about how well our models are performing. The discipline of the test set helps us keep ourselves intellectually honest. That doesn’t mean we always need a separate test set—if you have very little data, you may need to just have a validation set—but generally it’s best to use one if at all possible.\nThis same discipline can be critical if you intend to hire a third party to perform modeling work on your behalf. A third party might not understand your requirements accurately, or their incentives might even encourage them to misunderstand them. A good test set can greatly mitigate these risks and let you evaluate whether their work solves your actual problem.\nTo put it bluntly, if you’re a senior decision maker in your organization (or you’re advising senior decision makers), the most important takeaway is this: if you ensure that you really understand what test and validation sets are and why they’re important, then you’ll avoid the single biggest source of failures we’ve seen when organizations decide to use AI. For instance, if you’re considering bringing in an external vendor or service, make sure that you hold out some test data that the vendor never gets to see. Then you check their model on your test data, using a metric that you choose based on what actually matters to you in practice, and you decide what level of performance is adequate. (It’s also a good idea for you to try out some simple baseline yourself, so you know what a really simple model can achieve. Often it’ll turn out that your simple model performs just as well as one produced by an external “expert”!)\n\nUse Judgment in Defining Test Sets\nTo do a good job of defining a validation set (and possibly a test set), you will sometimes want to do more than just randomly grab a fraction of your original dataset. Remember: a key property of the validation and test sets is that they must be representative of the new data you will see in the future. This may sound like an impossible order! By definition, you haven’t seen this data yet. But you usually still do know some things.\nIt’s instructive to look at a few example cases. Many of these examples come from predictive modeling competitions on the Kaggle platform, which is a good representation of problems and methods you might see in practice.\nOne case might be if you are looking at time series data. For a time series, choosing a random subset of the data will be both too easy (you can look at the data both before and after the dates you are trying to predict) and not representative of most business use cases (where you are using historical data to build a model for use in the future). If your data includes the date and you are building a model to use in the future, you will want to choose a continuous section with the latest dates as your validation set (for instance, the last two weeks or last month of available data).\nSuppose you want to split the time series data in Figure 1.20 into training and validation sets.\n\n\n\n\n\n\nFigure 1.20: A time series\n\n\n\nA random subset is a poor choice (too easy to fill in the gaps, and not indicative of what you’ll need in production), as we can see in Figure 1.21.\n\n\n\n\n\n\nFigure 1.21: A poor training subset\n\n\n\nInstead, use the earlier data as your training set (and the later data for the validation set), as shown in Figure 1.22.\n\n\n\n\n\n\nFigure 1.22: A good training subset\n\n\n\nFor example, Kaggle had a competition to predict the sales in a chain of Ecuadorian grocery stores. Kaggle’s training data ran from Jan 1 2013 to Aug 15 2017, and the test data spanned Aug 16 2017 to Aug 31 2017. That way, the competition organizer ensured that entrants were making predictions for a time period that was in the future, from the perspective of their model. This is similar to the way quant hedge fund traders do back-testing to check whether their models are predictive of future periods, based on past data.\nA second common case is when you can easily anticipate ways the data you will be making predictions for in production may be qualitatively different from the data you have to train your model with.\nIn the Kaggle distracted driver competition, the independent variables are pictures of drivers at the wheel of a car, and the dependent variables are categories such as texting, eating, or safely looking ahead. Lots of pictures are of the same drivers in different positions, as we can see in Figure 1.23. If you were an insurance company building a model from this data, note that you would be most interested in how the model performs on drivers it hasn’t seen before (since you would likely have training data only for a small group of people). In recognition of this, the test data for the competition consists of images of people that don’t appear in the training set.\n\n\n\n\n\n\nFigure 1.23: Two pictures from the training data\n\n\n\nIf you put one of the images in Figure 1.23 in your training set and one in the validation set, your model will have an easy time making a prediction for the one in the validation set, so it will seem to be performing better than it would on new people. Another perspective is that if you used all the people in training your model, your model might be overfitting to particularities of those specific people, and not just learning the states (texting, eating, etc.).\nA similar dynamic was at work in the Kaggle fisheries competition to identify the species of fish caught by fishing boats in order to reduce illegal fishing of endangered populations. The test set consisted of boats that didn’t appear in the training data. This means that you’d want your validation set to include boats that are not in the training set.\nSometimes it may not be clear how your validation data will differ. For instance, for a problem using satellite imagery, you’d need to gather more information on whether the training set just contained certain geographic locations, or if it came from geographically scattered data.\nNow that you have gotten a taste of how to build a model, you can decide what you want to dig into next.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#a-choose-your-own-adventure-moment",
    "href": "intro.html#a-choose-your-own-adventure-moment",
    "title": "1  Your Deep Learning Journey",
    "section": "1.9 A Choose Your Own Adventure moment",
    "text": "1.9 A Choose Your Own Adventure moment\nIf you would like to learn more about how to use deep learning models in practice, including how to identify and fix errors, create a real working web application, and avoid your model causing unexpected harm to your organization or society more generally, then keep reading the next two chapters. If you would like to start learning the foundations of how deep learning works under the hood, skip to Chapter 4. (Did you ever read Choose Your Own Adventure books as a kid? Well, this is kind of like that… except with more deep learning than that book series contained.)\nYou will need to read all these chapters to progress further in the book, but it is totally up to you which order you read them in. They don’t depend on each other. If you skip ahead to Chapter 4, we will remind you at the end to come back and read the chapters you skipped over before you go any further.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "intro.html#questionnaire",
    "href": "intro.html#questionnaire",
    "title": "1  Your Deep Learning Journey",
    "section": "1.10 Questionnaire",
    "text": "1.10 Questionnaire\nIt can be hard to know in pages and pages of prose what the key things are that you really need to focus on and remember. So, we’ve prepared a list of questions and suggested steps to complete at the end of each chapter. All the answers are in the text of the chapter, so if you’re not sure about anything here, reread that part of the text and make sure you understand it. Answers to all these questions are also available on the book’s website. You can also visit the forums if you get stuck to get help from other folks studying this material.\nFor more questions, including detailed answers and links to the video timeline, have a look at Radek Osmulski’s aiquizzes.\n\nDo you need these for deep learning?\n\nLots of math T / F\nLots of data T / F\nLots of expensive computers T / F\nA PhD T / F\n\nName five areas where deep learning is now the best in the world.\nWhat was the name of the first device that was based on the principle of the artificial neuron?\nBased on the book of the same name, what are the requirements for parallel distributed processing (PDP)?\nWhat were the two theoretical misunderstandings that held back the field of neural networks?\nWhat is a GPU?\nOpen a notebook and execute a cell containing: 1+1. What happens?\nFollow through each cell of the stripped version of the notebook for this chapter. Before executing each cell, guess what will happen.\nComplete the Jupyter Notebook online appendix.\nWhy is it hard to use a traditional computer program to recognize images in a photo?\nWhat did Samuel mean by “weight assignment”?\nWhat term do we normally use in deep learning for what Samuel called “weights”?\nDraw a picture that summarizes Samuel’s view of a machine learning model.\nWhy is it hard to understand why a deep learning model makes a particular prediction?\nWhat is the name of the theorem that shows that a neural network can solve any mathematical problem to any level of accuracy?\nWhat do you need in order to train a model?\nHow could a feedback loop impact the rollout of a predictive policing model?\nDo we always have to use 224×224-pixel images with the cat recognition model?\nWhat is the difference between classification and regression?\nWhat is a validation set? What is a test set? Why do we need them?\nWhat will fastai do if you don’t provide a validation set?\nCan we always use a random sample for a validation set? Why or why not?\nWhat is overfitting? Provide an example.\nWhat is a metric? How does it differ from “loss”?\nHow can pretrained models help?\nWhat is the “head” of a model?\nWhat kinds of features do the early layers of a CNN find? How about the later layers?\nAre image models only useful for photos?\nWhat is an “architecture”?\nWhat is segmentation?\nWhat is y_range used for? When do we need it?\nWhat are “hyperparameters”?\nWhat’s the best way to avoid failures when using AI in an organization?\n\n\nFurther Research\nEach chapter also has a “Further Research” section that poses questions that aren’t fully answered in the text, or gives more advanced assignments. Answers to these questions aren’t on the book’s website; you’ll need to do your own research!\n\nWhy is a GPU useful for deep learning? How is a CPU different, and why is it less effective for deep learning?\nTry to think of three areas where feedback loops might impact the use of machine learning. See if you can find documented examples of that happening in practice.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Your Deep Learning Journey</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html",
    "href": "mnist_basics.html",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "",
    "text": "4.1 Pixels: The Foundations of Computer Vision\nIn order to understand what happens in a computer vision model, we first have to understand how computers handle images. We’ll use one of the most famous datasets in computer vision, MNIST, for our experiments. MNIST contains images of handwritten digits, collected by the National Institute of Standards and Technology and collated into a machine learning dataset by Yann Lecun and his colleagues. Lecun used MNIST in 1998 in Lenet-5, the first computer system to demonstrate practically useful recognition of handwritten digit sequences. This was one of the most important breakthroughs in the history of AI.",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#sidebar-tenacity-and-deep-learning",
    "href": "mnist_basics.html#sidebar-tenacity-and-deep-learning",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.2 Sidebar: Tenacity and Deep Learning",
    "text": "4.2 Sidebar: Tenacity and Deep Learning\nThe story of deep learning is one of tenacity and grit by a handful of dedicated researchers. After early hopes (and hype!) neural networks went out of favor in the 1990’s and 2000’s, and just a handful of researchers kept trying to make them work well. Three of them, Yann Lecun, Yoshua Bengio, and Geoffrey Hinton, were awarded the highest honor in computer science, the Turing Award (generally considered the “Nobel Prize of computer science”), in 2018 after triumphing despite the deep skepticism and disinterest of the wider machine learning and statistics community.\nGeoff Hinton has told of how even academic papers showing dramatically better results than anything previously published would be rejected by top journals and conferences, just because they used a neural network. Yann Lecun’s work on convolutional neural networks, which we will study in the next section, showed that these models could read handwritten text—something that had never been achieved before. However, his breakthrough was ignored by most researchers, even as it was used commercially to read 10% of the checks in the US!\nIn addition to these three Turing Award winners, there are many other researchers who have battled to get us to where we are today. For instance, Jurgen Schmidhuber (who many believe should have shared in the Turing Award) pioneered many important ideas, including working with his student Sepp Hochreiter on the long short-term memory (LSTM) architecture (widely used for speech recognition and other text modeling tasks, and used in the IMDb example in Chapter 1). Perhaps most important of all, Paul Werbos in 1974 invented back-propagation for neural networks, the technique shown in this chapter and used universally for training neural networks (Werbos 1994). His development was almost entirely ignored for decades, but today it is considered the most important foundation of modern AI.\nThere is a lesson here for all of us! On your deep learning journey you will face many obstacles, both technical, and (even more difficult) posed by people around you who don’t believe you’ll be successful. There’s one guaranteed way to fail, and that’s to stop trying. We’ve seen that the only consistent trait amongst every fast.ai student that’s gone on to be a world-class practitioner is that they are all very tenacious.",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#end-sidebar",
    "href": "mnist_basics.html#end-sidebar",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.3 End sidebar",
    "text": "4.3 End sidebar\nFor this initial tutorial we are just going to try to create a model that can classify any image as a 3 or a 7. So let’s download a sample of MNIST that contains images of just these digits:\n\npath = untar_data(URLs.MNIST_SAMPLE)\n\nWe can see what’s in this directory by using ls, a method added by fastai. This method returns an object of a special fastai class called L, which has all the same functionality of Python’s built-in list, plus a lot more. One of its handy features is that, when printed, it displays the count of items, before listing the items themselves (if there are more than 10 items, it just shows the first few):\n\npath.ls()\n\n(#3) [Path('valid'),Path('labels.csv'),Path('train')]\n\n\nThe MNIST dataset follows a common layout for machine learning datasets: separate folders for the training set and the validation set (and/or test set). Let’s see what’s inside the training set:\n\n(path/'train').ls()\n\n(#2) [Path('train/7'),Path('train/3')]\n\n\nThere’s a folder of 3s, and a folder of 7s. In machine learning parlance, we say that “3” and “7” are the labels (or targets) in this dataset. Let’s take a look in one of these folders (using sorted to ensure we all get the same order of files):\n\nthrees = (path/'train'/'3').ls().sorted()\nsevens = (path/'train'/'7').ls().sorted()\nthrees\n\n(#6131) [Path('train/3/10.png'),Path('train/3/10000.png'),Path('train/3/10011.png'),Path('train/3/10031.png'),Path('train/3/10034.png'),Path('train/3/10042.png'),Path('train/3/10052.png'),Path('train/3/1007.png'),Path('train/3/10074.png'),Path('train/3/10091.png')...]\n\n\nAs we might expect, it’s full of image files. Let’s take a look at one now. Here’s an image of a handwritten number 3, taken from the famous MNIST dataset of handwritten numbers:\n\nim3_path = threes[1]\nim3 = Image.open(im3_path)\nim3\n\n\n\n\n\n\n\n\nHere we are using the Image class from the Python Imaging Library (PIL), which is the most widely used Python package for opening, manipulating, and viewing images. Jupyter knows about PIL images, so it displays the image for us automatically.\nIn a computer, everything is represented as a number. To view the numbers that make up this image, we have to convert it to a NumPy array or a PyTorch tensor. For instance, here’s what a section of the image looks like, converted to a NumPy array:\n\narray(im3)[4:10,4:10]\n\narray([[  0,   0,   0,   0,   0,   0],\n       [  0,   0,   0,   0,   0,  29],\n       [  0,   0,   0,  48, 166, 224],\n       [  0,  93, 244, 249, 253, 187],\n       [  0, 107, 253, 253, 230,  48],\n       [  0,   3,  20,  20,  15,   0]], dtype=uint8)\n\n\nThe 4:10 indicates we requested the rows from index 4 (included) to 10 (not included) and the same for the columns. NumPy indexes from top to bottom and left to right, so this section is located in the top-left corner of the image. Here’s the same thing as a PyTorch tensor:\n\ntensor(im3)[4:10,4:10]\n\ntensor([[  0,   0,   0,   0,   0,   0],\n        [  0,   0,   0,   0,   0,  29],\n        [  0,   0,   0,  48, 166, 224],\n        [  0,  93, 244, 249, 253, 187],\n        [  0, 107, 253, 253, 230,  48],\n        [  0,   3,  20,  20,  15,   0]], dtype=torch.uint8)\n\n\nWe can slice the array to pick just the part with the top of the digit in it, and then use a Pandas DataFrame to color-code the values using a gradient, which shows us clearly how the image is created from the pixel values:\n\nim3_t = tensor(im3)\ndf = pd.DataFrame(im3_t[4:15,4:22])\ndf.style.set_properties(**{'font-size':'6pt'}).background_gradient('Greys')\n\n\n\n\n\n\n\n\n\n\nYou can see that the background white pixels are stored as the number 0, black is the number 255, and shades of gray are between the two. The entire image contains 28 pixels across and 28 pixels down, for a total of 784 pixels. (This is much smaller than an image that you would get from a phone camera, which has millions of pixels, but is a convenient size for our initial learning and experiments. We will build up to bigger, full-color images soon.)\nSo, now you’ve seen what an image looks like to a computer, let’s recall our goal: create a model that can recognize 3s and 7s. How might you go about getting a computer to do that?\n\nWarning: Stop and Think!: Before you read on, take a moment to think about how a computer might be able to recognize these two different digits. What kinds of features might it be able to look at? How might it be able to identify these features? How could it combine them together? Learning works best when you try to solve problems yourself, rather than just reading somebody else’s answers; so step away from this book for a few minutes, grab a piece of paper and pen, and jot some ideas down…",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#first-try-pixel-similarity",
    "href": "mnist_basics.html#first-try-pixel-similarity",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.4 First Try: Pixel Similarity",
    "text": "4.4 First Try: Pixel Similarity\nSo, here is a first idea: how about we find the average pixel value for every pixel of the 3s, then do the same for the 7s. This will give us two group averages, defining what we might call the “ideal” 3 and 7. Then, to classify an image as one digit or the other, we see which of these two ideal digits the image is most similar to. This certainly seems like it should be better than nothing, so it will make a good baseline.\n\njargon: Baseline: A simple model which you are confident should perform reasonably well. It should be very simple to implement, and very easy to test, so that you can then test each of your improved ideas, and make sure they are always better than your baseline. Without starting with a sensible baseline, it is very difficult to know whether your super-fancy models are actually any good. One good approach to creating a baseline is doing what we have done here: think of a simple, easy-to-implement model. Another good approach is to search around to find other people that have solved similar problems to yours, and download and run their code on your dataset. Ideally, try both of these!\n\nStep one for our simple model is to get the average of pixel values for each of our two groups. In the process of doing this, we will learn a lot of neat Python numeric programming tricks!\nLet’s create a tensor containing all of our 3s stacked together. We already know how to create a tensor containing a single image. To create a tensor containing all the images in a directory, we will first use a Python list comprehension to create a plain list of the single image tensors.\nWe will use Jupyter to do some little checks of our work along the way—in this case, making sure that the number of returned items seems reasonable:\n\nseven_tensors = [tensor(Image.open(o)) for o in sevens]\nthree_tensors = [tensor(Image.open(o)) for o in threes]\nlen(three_tensors),len(seven_tensors)\n\n(6131, 6265)\n\n\n\nnote: List Comprehensions: List and dictionary comprehensions are a wonderful feature of Python. Many Python programmers use them every day, including the authors of this book—they are part of “idiomatic Python.” But programmers coming from other languages may have never seen them before. There are a lot of great tutorials just a web search away, so we won’t spend a long time discussing them now. Here is a quick explanation and example to get you started. A list comprehension looks like this: new_list = [f(o) for o in a_list if o&gt;0]. This will return every element of a_list that is greater than 0, after passing it to the function f. There are three parts here: the collection you are iterating over (a_list), an optional filter (if o&gt;0), and something to do to each element (f(o)). It’s not only shorter to write but way faster than the alternative ways of creating the same list with a loop.\n\nWe’ll also check that one of the images looks okay. Since we now have tensors (which Jupyter by default will print as values), rather than PIL images (which Jupyter by default will display as images), we need to use fastai’s show_image function to display it:\n\nshow_image(three_tensors[1]);\n\n\n\n\n\n\n\n\nFor every pixel position, we want to compute the average over all the images of the intensity of that pixel. To do this we first combine all the images in this list into a single three-dimensional tensor. The most common way to describe such a tensor is to call it a rank-3 tensor. We often need to stack up individual tensors in a collection into a single tensor. Unsurprisingly, PyTorch comes with a function called stack that we can use for this purpose.\nSome operations in PyTorch, such as taking a mean, require us to cast our integer types to float types. Since we’ll be needing this later, we’ll also cast our stacked tensor to float now. Casting in PyTorch is as simple as typing the name of the type you wish to cast to, and treating it as a method.\nGenerally when images are floats, the pixel values are expected to be between 0 and 1, so we will also divide by 255 here:\n\nstacked_sevens = torch.stack(seven_tensors).float()/255\nstacked_threes = torch.stack(three_tensors).float()/255\nstacked_threes.shape\n\ntorch.Size([6131, 28, 28])\n\n\nPerhaps the most important attribute of a tensor is its shape. This tells you the length of each axis. In this case, we can see that we have 6,131 images, each of size 28×28 pixels. There is nothing specifically about this tensor that says that the first axis is the number of images, the second is the height, and the third is the width—the semantics of a tensor are entirely up to us, and how we construct it. As far as PyTorch is concerned, it is just a bunch of numbers in memory.\nThe length of a tensor’s shape is its rank:\n\nlen(stacked_threes.shape)\n\n3\n\n\nIt is really important for you to commit to memory and practice these bits of tensor jargon: rank is the number of axes or dimensions in a tensor; shape is the size of each axis of a tensor.\n\nA: Watch out because the term “dimension” is sometimes used in two ways. Consider that we live in “three-dimensonal space” where a physical position can be described by a 3-vector v. But according to PyTorch, the attribute v.ndim (which sure looks like the “number of dimensions” of v) equals one, not three! Why? Because v is a vector, which is a tensor of rank one, meaning that it has only one axis (even if that axis has a length of three). In other words, sometimes dimension is used for the size of an axis (“space is three-dimensional”); other times, it is used for the rank, or the number of axes (“a matrix has two dimensions”). When confused, I find it helpful to translate all statements into terms of rank, axis, and length, which are unambiguous terms.\n\nWe can also get a tensor’s rank directly with ndim:\n\nstacked_threes.ndim\n\n3\n\n\nFinally, we can compute what the ideal 3 looks like. We calculate the mean of all the image tensors by taking the mean along dimension 0 of our stacked, rank-3 tensor. This is the dimension that indexes over all the images.\nIn other words, for every pixel position, this will compute the average of that pixel over all images. The result will be one value for every pixel position, or a single image. Here it is:\n\nmean3 = stacked_threes.mean(0)\nshow_image(mean3);\n\n\n\n\n\n\n\n\nAccording to this dataset, this is the ideal number 3! (You may not like it, but this is what peak number 3 performance looks like.) You can see how it’s very dark where all the images agree it should be dark, but it becomes wispy and blurry where the images disagree.\nLet’s do the same thing for the 7s, but put all the steps together at once to save some time:\n\nmean7 = stacked_sevens.mean(0)\nshow_image(mean7);\n\n\n\n\n\n\n\n\nLet’s now pick an arbitrary 3 and measure its distance from our “ideal digits.”\n\nstop: Stop and Think!: How would you calculate how similar a particular image is to each of our ideal digits? Remember to step away from this book and jot down some ideas before you move on! Research shows that recall and understanding improves dramatically when you are engaged with the learning process by solving problems, experimenting, and trying new ideas yourself\n\nHere’s a sample 3:\n\na_3 = stacked_threes[1]\nshow_image(a_3);\n\n\n\n\n\n\n\n\nHow can we determine its distance from our ideal 3? We can’t just add up the differences between the pixels of this image and the ideal digit. Some differences will be positive while others will be negative, and these differences will cancel out, resulting in a situation where an image that is too dark in some places and too light in others might be shown as having zero total differences from the ideal. That would be misleading!\nTo avoid this, there are two main ways data scientists measure distance in this context:\n\nTake the mean of the absolute value of differences (absolute value is the function that replaces negative values with positive values). This is called the mean absolute difference or L1 norm\nTake the mean of the square of differences (which makes everything positive) and then take the square root (which undoes the squaring). This is called the root mean squared error (RMSE) or L2 norm.\n\n\nimportant: It’s Okay to Have Forgotten Your Math: In this book we generally assume that you have completed high school math, and remember at least some of it… But everybody forgets some things! It all depends on what you happen to have had reason to practice in the meantime. Perhaps you have forgotten what a square root is, or exactly how they work. No problem! Any time you come across a maths concept that is not explained fully in this book, don’t just keep moving on; instead, stop and look it up. Make sure you understand the basic idea, how it works, and why we might be using it. One of the best places to refresh your understanding is Khan Academy. For instance, Khan Academy has a great introduction to square roots.\n\nLet’s try both of these now:\n\ndist_3_abs = (a_3 - mean3).abs().mean()\ndist_3_sqr = ((a_3 - mean3)**2).mean().sqrt()\ndist_3_abs,dist_3_sqr\n\n(tensor(0.1114), tensor(0.2021))\n\n\n\ndist_7_abs = (a_3 - mean7).abs().mean()\ndist_7_sqr = ((a_3 - mean7)**2).mean().sqrt()\ndist_7_abs,dist_7_sqr\n\n(tensor(0.1586), tensor(0.3021))\n\n\nIn both cases, the distance between our 3 and the “ideal” 3 is less than the distance to the ideal 7. So our simple model will give the right prediction in this case.\nPyTorch already provides both of these as loss functions. You’ll find these inside torch.nn.functional, which the PyTorch team recommends importing as F (and is available by default under that name in fastai):\n\nF.l1_loss(a_3.float(),mean7), F.mse_loss(a_3,mean7).sqrt()\n\n(tensor(0.1586), tensor(0.3021))\n\n\nHere mse stands for mean squared error, and l1 refers to the standard mathematical jargon for mean absolute value (in math it’s called the L1 norm).\n\nS: Intuitively, the difference between L1 norm and mean squared error (MSE) is that the latter will penalize bigger mistakes more heavily than the former (and be more lenient with small mistakes).\n\n\nJ: When I first came across this “L1” thingie, I looked it up to see what on earth it meant. I found on Google that it is a vector norm using absolute value, so looked up vector norm and started reading: Given a vector space V over a field F of the real or complex numbers, a norm on V is a nonnegative-valued any function p: V → [0,+∞) with the following properties: For all a ∈ F and all u, v ∈ V, p(u + v) ≤ p(u) + p(v)… Then I stopped reading. “Ugh, I’ll never understand math!” I thought, for the thousandth time. Since then I’ve learned that every time these complex mathy bits of jargon come up in practice, it turns out I can replace them with a tiny bit of code! Like, the L1 loss is just equal to (a-b).abs().mean(), where a and b are tensors. I guess mathy folks just think differently than me… I’ll make sure in this book that every time some mathy jargon comes up, I’ll give you the little bit of code it’s equal to as well, and explain in common-sense terms what’s going on.\n\nWe just completed various mathematical operations on PyTorch tensors. If you’ve done some numeric programming in NumPy before, you may recognize these as being similar to NumPy arrays. Let’s have a look at those two very important data structures.\n\nNumPy Arrays and PyTorch Tensors\nNumPy is the most widely used library for scientific and numeric programming in Python. It provides very similar functionality and a very similar API to that provided by PyTorch; however, it does not support using the GPU or calculating gradients, which are both critical for deep learning. Therefore, in this book we will generally use PyTorch tensors instead of NumPy arrays, where possible.\n(Note that fastai adds some features to NumPy and PyTorch to make them a bit more similar to each other. If any code in this book doesn’t work on your computer, it’s possible that you forgot to include a line like this at the start of your notebook: from fastai.vision.all import *.)\nBut what are arrays and tensors, and why should you care?\nPython is slow compared to many languages. Anything fast in Python, NumPy, or PyTorch is likely to be a wrapper for a compiled object written (and optimized) in another language—specifically C. In fact, NumPy arrays and PyTorch tensors can finish computations many thousands of times faster than using pure Python.\nA NumPy array is a multidimensional table of data, with all items of the same type. Since that can be any type at all, they can even be arrays of arrays, with the innermost arrays potentially being different sizes—this is called a “jagged array.” By “multidimensional table” we mean, for instance, a list (dimension of one), a table or matrix (dimension of two), a “table of tables” or “cube” (dimension of three), and so forth. If the items are all of some simple type such as integer or float, then NumPy will store them as a compact C data structure in memory. This is where NumPy shines. NumPy has a wide variety of operators and methods that can run computations on these compact structures at the same speed as optimized C, because they are written in optimized C.\nA PyTorch tensor is nearly the same thing as a NumPy array, but with an additional restriction that unlocks some additional capabilities. It’s the same in that it, too, is a multidimensional table of data, with all items of the same type. However, the restriction is that a tensor cannot use just any old type—it has to use a single basic numeric type for all components. For example, a PyTorch tensor cannot be jagged. It is always a regularly shaped multidimensional rectangular structure.\nThe vast majority of methods and operators supported by NumPy on these structures are also supported by PyTorch, but PyTorch tensors have additional capabilities. One major capability is that these structures can live on the GPU, in which case their computation will be optimized for the GPU and can run much faster (given lots of values to work on). In addition, PyTorch can automatically calculate derivatives of these operations, including combinations of operations. As you’ll see, it would be impossible to do deep learning in practice without this capability.\n\nS: If you don’t know what C is, don’t worry as you won’t need it at all. In a nutshell, it’s a low-level (low-level means more similar to the language that computers use internally) language that is very fast compared to Python. To take advantage of its speed while programming in Python, try to avoid as much as possible writing loops, and replace them by commands that work directly on arrays or tensors.\n\nPerhaps the most important new coding skill for a Python programmer to learn is how to effectively use the array/tensor APIs. We will be showing lots more tricks later in this book, but here’s a summary of the key things you need to know for now.\nTo create an array or tensor, pass a list (or list of lists, or list of lists of lists, etc.) to array() or tensor():\n\ndata = [[1,2,3],[4,5,6]]\narr = array (data)\ntns = tensor(data)\n\n\narr  # numpy\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n\ntns  # pytorch\n\ntensor([[1, 2, 3],\n        [4, 5, 6]])\n\n\nAll the operations that follow are shown on tensors, but the syntax and results for NumPy arrays is identical.\nYou can select a row (note that, like lists in Python, tensors are 0-indexed so 1 refers to the second row/column):\n\ntns[1]\n\ntensor([4, 5, 6])\n\n\nor a column, by using : to indicate all of the first axis (we sometimes refer to the dimensions of tensors/arrays as axes):\n\ntns[:,1]\n\ntensor([2, 5])\n\n\nYou can combine these with Python slice syntax ([start:end] with end being excluded) to select part of a row or column:\n\ntns[1,1:3]\n\ntensor([5, 6])\n\n\nAnd you can use the standard operators such as +, -, *, /:\n\ntns+1\n\ntensor([[2, 3, 4],\n        [5, 6, 7]])\n\n\nTensors have a type:\n\ntns.type()\n\n'torch.LongTensor'\n\n\nAnd will automatically change type as needed, for example from int to float:\n\ntns*1.5\n\ntensor([[1.5000, 3.0000, 4.5000],\n        [6.0000, 7.5000, 9.0000]])\n\n\nSo, is our baseline model any good? To quantify this, we must define a metric.",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#computing-metrics-using-broadcasting",
    "href": "mnist_basics.html#computing-metrics-using-broadcasting",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.5 Computing Metrics Using Broadcasting",
    "text": "4.5 Computing Metrics Using Broadcasting\nRecall that a metric is a number that is calculated based on the predictions of our model, and the correct labels in our dataset, in order to tell us how good our model is. For instance, we could use either of the functions we saw in the previous section, mean squared error, or mean absolute error, and take the average of them over the whole dataset. However, neither of these are numbers that are very understandable to most people; in practice, we normally use accuracy as the metric for classification models.\nAs we’ve discussed, we want to calculate our metric over a validation set. This is so that we don’t inadvertently overfit—that is, train a model to work well only on our training data. This is not really a risk with the pixel similarity model we’re using here as a first try, since it has no trained components, but we’ll use a validation set anyway to follow normal practices and to be ready for our second try later.\nTo get a validation set we need to remove some of the data from training entirely, so it is not seen by the model at all. As it turns out, the creators of the MNIST dataset have already done this for us. Do you remember how there was a whole separate directory called valid? That’s what this directory is for!\nSo to start with, let’s create tensors for our 3s and 7s from that directory. These are the tensors we will use to calculate a metric measuring the quality of our first-try model, which measures distance from an ideal image:\n\nvalid_3_tens = torch.stack([tensor(Image.open(o)) \n                            for o in (path/'valid'/'3').ls()])\nvalid_3_tens = valid_3_tens.float()/255\nvalid_7_tens = torch.stack([tensor(Image.open(o)) \n                            for o in (path/'valid'/'7').ls()])\nvalid_7_tens = valid_7_tens.float()/255\nvalid_3_tens.shape,valid_7_tens.shape\n\n(torch.Size([1010, 28, 28]), torch.Size([1028, 28, 28]))\n\n\nIt’s good to get in the habit of checking shapes as you go. Here we see two tensors, one representing the 3s validation set of 1,010 images of size 28×28, and one representing the 7s validation set of 1,028 images of size 28×28.\nWe ultimately want to write a function, is_3, that will decide if an arbitrary image is a 3 or a 7. It will do this by deciding which of our two “ideal digits” this arbitrary image is closer to. For that we need to define a notion of distance—that is, a function that calculates the distance between two images.\nWe can write a simple function that calculates the mean absolute error using an expression very similar to the one we wrote in the last section:\n\ndef mnist_distance(a,b): return (a-b).abs().mean((-1,-2))\nmnist_distance(a_3, mean3)\n\ntensor(0.1114)\n\n\nThis is the same value we previously calculated for the distance between these two images, the ideal 3 mean3 and the arbitrary sample 3 a_3, which are both single-image tensors with a shape of [28,28].\nBut in order to calculate a metric for overall accuracy, we will need to calculate the distance to the ideal 3 for every image in the validation set. How do we do that calculation? We could write a loop over all of the single-image tensors that are stacked within our validation set tensor, valid_3_tens, which has a shape of [1010,28,28] representing 1,010 images. But there is a better way.\nSomething very interesting happens when we take this exact same distance function, designed for comparing two single images, but pass in as an argument valid_3_tens, the tensor that represents the 3s validation set:\n\nvalid_3_dist = mnist_distance(valid_3_tens, mean3)\nvalid_3_dist, valid_3_dist.shape\n\n(tensor([0.1634, 0.1145, 0.1363,  ..., 0.1105, 0.1111, 0.1640]),\n torch.Size([1010]))\n\n\nInstead of complaining about shapes not matching, it returned the distance for every single image as a vector (i.e., a rank-1 tensor) of length 1,010 (the number of 3s in our validation set). How did that happen?\nTake another look at our function mnist_distance, and you’ll see we have there the subtraction (a-b). The magic trick is that PyTorch, when it tries to perform a simple subtraction operation between two tensors of different ranks, will use broadcasting. That is, it will automatically expand the tensor with the smaller rank to have the same size as the one with the larger rank. Broadcasting is an important capability that makes tensor code much easier to write.\nAfter broadcasting so the two argument tensors have the same rank, PyTorch applies its usual logic for two tensors of the same rank: it performs the operation on each corresponding element of the two tensors, and returns the tensor result. For instance:\n\ntensor([1,2,3]) + tensor(1)\n\ntensor([2, 3, 4])\n\n\nSo in this case, PyTorch treats mean3, a rank-2 tensor representing a single image, as if it were 1,010 copies of the same image, and then subtracts each of those copies from each 3 in our validation set. What shape would you expect this tensor to have? Try to figure it out yourself before you look at the answer below:\n\n(valid_3_tens-mean3).shape\n\ntorch.Size([1010, 28, 28])\n\n\nWe are calculating the difference between our “ideal 3” and each of the 1,010 3s in the validation set, for each of 28×28 images, resulting in the shape [1010,28,28].\nThere are a couple of important points about how broadcasting is implemented, which make it valuable not just for expressivity but also for performance:\n\nPyTorch doesn’t actually copy mean3 1,010 times. It pretends it were a tensor of that shape, but doesn’t actually allocate any additional memory\nIt does the whole calculation in C (or, if you’re using a GPU, in CUDA, the equivalent of C on the GPU), tens of thousands of times faster than pure Python (up to millions of times faster on a GPU!).\n\nThis is true of all broadcasting and elementwise operations and functions done in PyTorch. It’s the most important technique for you to know to create efficient PyTorch code.\nNext in mnist_distance we see abs. You might be able to guess now what this does when applied to a tensor. It applies the method to each individual element in the tensor, and returns a tensor of the results (that is, it applies the method “elementwise”). So in this case, we’ll get back 1,010 matrices of absolute values.\nFinally, our function calls mean((-1,-2)). The tuple (-1,-2) represents a range of axes. In Python, -1 refers to the last element, and -2 refers to the second-to-last. So in this case, this tells PyTorch that we want to take the mean ranging over the values indexed by the last two axes of the tensor. The last two axes are the horizontal and vertical dimensions of an image. After taking the mean over the last two axes, we are left with just the first tensor axis, which indexes over our images, which is why our final size was (1010). In other words, for every image, we averaged the intensity of all the pixels in that image.\nWe’ll be learning lots more about broadcasting throughout this book, especially in Chapter 17, and will be practicing it regularly too.\nWe can use mnist_distance to figure out whether an image is a 3 or not by using the following logic: if the distance between the digit in question and the ideal 3 is less than the distance to the ideal 7, then it’s a 3. This function will automatically do broadcasting and be applied elementwise, just like all PyTorch functions and operators:\n\ndef is_3(x): return mnist_distance(x,mean3) &lt; mnist_distance(x,mean7)\n\nLet’s test it on our example case:\n\nis_3(a_3), is_3(a_3).float()\n\n(tensor(True), tensor(1.))\n\n\nNote that when we convert the Boolean response to a float, we get 1.0 for True and 0.0 for False. Thanks to broadcasting, we can also test it on the full validation set of 3s:\n\nis_3(valid_3_tens)\n\ntensor([True, True, True,  ..., True, True, True])\n\n\nNow we can calculate the accuracy for each of the 3s and 7s by taking the average of that function for all 3s and its inverse for all 7s:\n\naccuracy_3s =      is_3(valid_3_tens).float() .mean()\naccuracy_7s = (1 - is_3(valid_7_tens).float()).mean()\n\naccuracy_3s,accuracy_7s,(accuracy_3s+accuracy_7s)/2\n\n(tensor(0.9168), tensor(0.9854), tensor(0.9511))\n\n\nThis looks like a pretty good start! We’re getting over 90% accuracy on both 3s and 7s, and we’ve seen how to define a metric conveniently using broadcasting.\nBut let’s be honest: 3s and 7s are very different-looking digits. And we’re only classifying 2 out of the 10 possible digits so far. So we’re going to need to do better!\nTo do better, perhaps it is time to try a system that does some real learning—that is, that can automatically modify itself to improve its performance. In other words, it’s time to talk about the training process, and SGD.",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#stochastic-gradient-descent-sgd",
    "href": "mnist_basics.html#stochastic-gradient-descent-sgd",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.6 Stochastic Gradient Descent (SGD)",
    "text": "4.6 Stochastic Gradient Descent (SGD)\nDo you remember the way that Arthur Samuel described machine learning, which we quoted in Chapter 1?\n\nSuppose we arrange for some automatic means of testing the effectiveness of any current weight assignment in terms of actual performance and provide a mechanism for altering the weight assignment so as to maximize the performance. We need not go into the details of such a procedure to see that it could be made entirely automatic and to see that a machine so programmed would “learn” from its experience.\n\nAs we discussed, this is the key to allowing us to have a model that can get better and better—that can learn. But our pixel similarity approach does not really do this. We do not have any kind of weight assignment, or any way of improving based on testing the effectiveness of a weight assignment. In other words, we can’t really improve our pixel similarity approach by modifying a set of parameters. In order to take advantage of the power of deep learning, we will first have to represent our task in the way that Arthur Samuel described it.\nInstead of trying to find the similarity between an image and an “ideal image,” we could instead look at each individual pixel and come up with a set of weights for each one, such that the highest weights are associated with those pixels most likely to be black for a particular category. For instance, pixels toward the bottom right are not very likely to be activated for a 7, so they should have a low weight for a 7, but they are likely to be activated for an 8, so they should have a high weight for an 8. This can be represented as a function and set of weight values for each possible category—for instance the probability of being the number 8:\ndef pr_eight(x,w): return (x*w).sum()\nHere we are assuming that x is the image, represented as a vector—in other words, with all of the rows stacked up end to end into a single long line. And we are assuming that the weights are a vector w. If we have this function, then we just need some way to update the weights to make them a little bit better. With such an approach, we can repeat that step a number of times, making the weights better and better, until they are as good as we can make them.\nWe want to find the specific values for the vector w that causes the result of our function to be high for those images that are actually 8s, and low for those images that are not. Searching for the best vector w is a way to search for the best function for recognising 8s. (Because we are not yet using a deep neural network, we are limited by what our function can actually do—we are going to fix that constraint later in this chapter.)\nTo be more specific, here are the steps that we are going to require, to turn this function into a machine learning classifier:\n\nInitialize the weights.\nFor each image, use these weights to predict whether it appears to be a 3 or a 7.\nBased on these predictions, calculate how good the model is (its loss).\nCalculate the gradient, which measures for each weight, how changing that weight would change the loss\nStep (that is, change) all the weights based on that calculation.\nGo back to the step 2, and repeat the process.\nIterate until you decide to stop the training process (for instance, because the model is good enough or you don’t want to wait any longer).\n\nThese seven steps, illustrated in Figure 4.2, are the key to the training of all deep learning models. That deep learning turns out to rely entirely on these steps is extremely surprising and counterintuitive. It’s amazing that this process can solve such complex problems. But, as you’ll see, it really does!\n\n\n\n\n\n\n\n\nFigure 4.2: The gradient descent process\n\n\n\n\n\nThere are many different ways to do each of these seven steps, and we will be learning about them throughout the rest of this book. These are the details that make a big difference for deep learning practitioners, but it turns out that the general approach to each one generally follows some basic principles. Here are a few guidelines:\n\nInitialize:: We initialize the parameters to random values. This may sound surprising. There are certainly other choices we could make, such as initializing them to the percentage of times that pixel is activated for that category—but since we already know that we have a routine to improve these weights, it turns out that just starting with random weights works perfectly well.\nLoss:: This is what Samuel referred to when he spoke of testing the effectiveness of any current weight assignment in terms of actual performance. We need some function that will return a number that is small if the performance of the model is good (the standard approach is to treat a small loss as good, and a large loss as bad, although this is just a convention).\nStep:: A simple way to figure out whether a weight should be increased a bit, or decreased a bit, would be just to try it: increase the weight by a small amount, and see if the loss goes up or down. Once you find the correct direction, you could then change that amount by a bit more, and a bit less, until you find an amount that works well. However, this is slow! As we will see, the magic of calculus allows us to directly figure out in which direction, and by roughly how much, to change each weight, without having to try all these small changes. The way to do this is by calculating gradients. This is just a performance optimization, we would get exactly the same results by using the slower manual process as well.\nStop:: Once we’ve decided how many epochs to train the model for (a few suggestions for this were given in the earlier list), we apply that decision. This is where that decision is applied. For our digit classifier, we would keep training until the accuracy of the model started getting worse, or we ran out of time.\n\nBefore applying these steps to our image classification problem, let’s illustrate what they look like in a simpler case. First we will define a very simple function, the quadratic—let’s pretend that this is our loss function, and x is a weight parameter of the function:\n\ndef f(x): return x**2\n\nHere is a graph of that function:\n\nplot_function(f, 'x', 'x**2')\n\n\n\n\n\n\n\n\nThe sequence of steps we described earlier starts by picking some random value for a parameter, and calculating the value of the loss:\n\nplot_function(f, 'x', 'x**2')\nplt.scatter(-1.5, f(-1.5), color='red');\n\n\n\n\n\n\n\n\nNow we look to see what would happen if we increased or decreased our parameter by a little bit—the adjustment. This is simply the slope at a particular point:\n\nWe can change our weight by a little in the direction of the slope, calculate our loss and adjustment again, and repeat this a few times. Eventually, we will get to the lowest point on our curve:\n\nThis basic idea goes all the way back to Isaac Newton, who pointed out that we can optimize arbitrary functions in this way. Regardless of how complicated our functions become, this basic approach of gradient descent will not significantly change. The only minor changes we will see later in this book are some handy ways we can make it faster, by finding better steps.\n\nCalculating Gradients\nThe one magic step is the bit where we calculate the gradients. As we mentioned, we use calculus as a performance optimization; it allows us to more quickly calculate whether our loss will go up or down when we adjust our parameters up or down. In other words, the gradients will tell us how much we have to change each weight to make our model better.\nYou may remember from your high school calculus class that the derivative of a function tells you how much a change in its parameters will change its result. If not, don’t worry, lots of us forget calculus once high school is behind us! But you will have to have some intuitive understanding of what a derivative is before you continue, so if this is all very fuzzy in your head, head over to Khan Academy and complete the lessons on basic derivatives. You won’t have to know how to calculate them yourselves, you just have to know what a derivative is.\nThe key point about a derivative is this: for any function, such as the quadratic function we saw in the previous section, we can calculate its derivative. The derivative is another function. It calculates the change, rather than the value. For instance, the derivative of the quadratic function at the value 3 tells us how rapidly the function changes at the value 3. More specifically, you may recall that gradient is defined as rise/run, that is, the change in the value of the function, divided by the change in the value of the parameter. When we know how our function will change, then we know what we need to do to make it smaller. This is the key to machine learning: having a way to change the parameters of a function to make it smaller. Calculus provides us with a computational shortcut, the derivative, which lets us directly calculate the gradients of our functions.\nOne important thing to be aware of is that our function has lots of weights that we need to adjust, so when we calculate the derivative we won’t get back one number, but lots of them—a gradient for every weight. But there is nothing mathematically tricky here; you can calculate the derivative with respect to one weight, and treat all the other ones as constant, then repeat that for each other weight. This is how all of the gradients are calculated, for every weight.\nWe mentioned just now that you won’t have to calculate any gradients yourself. How can that be? Amazingly enough, PyTorch is able to automatically compute the derivative of nearly any function! What’s more, it does it very fast. Most of the time, it will be at least as fast as any derivative function that you can create by hand. Let’s see an example.\nFirst, let’s pick a tensor value which we want gradients at:\n\nxt = tensor(3.).requires_grad_()\n\nNotice the special method requires_grad_? That’s the magical incantation we use to tell PyTorch that we want to calculate gradients with respect to that variable at that value. It is essentially tagging the variable, so PyTorch will remember to keep track of how to compute gradients of the other, direct calculations on it that you will ask for.\n\na: This API might throw you off if you’re coming from math or physics. In those contexts the “gradient” of a function is just another function (i.e., its derivative), so you might expect gradient-related APIs to give you a new function. But in deep learning, “gradients” usually means the value of a function’s derivative at a particular argument value. The PyTorch API also puts the focus on the argument, not the function you’re actually computing the gradients of. It may feel backwards at first, but it’s just a different perspective.\n\nNow we calculate our function with that value. Notice how PyTorch prints not just the value calculated, but also a note that it has a gradient function it’ll be using to calculate our gradients when needed:\n\nyt = f(xt)\nyt\n\ntensor(9., grad_fn=&lt;PowBackward0&gt;)\n\n\nFinally, we tell PyTorch to calculate the gradients for us:\n\nyt.backward()\n\nThe “backward” here refers to backpropagation, which is the name given to the process of calculating the derivative of each layer. We’ll see how this is done exactly in chapter Chapter 17, when we calculate the gradients of a deep neural net from scratch. This is called the “backward pass” of the network, as opposed to the “forward pass,” which is where the activations are calculated. Life would probably be easier if backward was just called calculate_grad, but deep learning folks really do like to add jargon everywhere they can!\nWe can now view the gradients by checking the grad attribute of our tensor:\n\nxt.grad\n\ntensor(6.)\n\n\nIf you remember your high school calculus rules, the derivative of x**2 is 2*x, and we have x=3, so the gradients should be 2*3=6, which is what PyTorch calculated for us!\nNow we’ll repeat the preceding steps, but with a vector argument for our function:\n\nxt = tensor([3.,4.,10.]).requires_grad_()\nxt\n\ntensor([ 3.,  4., 10.], requires_grad=True)\n\n\nAnd we’ll add sum to our function so it can take a vector (i.e., a rank-1 tensor), and return a scalar (i.e., a rank-0 tensor):\n\ndef f(x): return (x**2).sum()\n\nyt = f(xt)\nyt\n\ntensor(125., grad_fn=&lt;SumBackward0&gt;)\n\n\nOur gradients are 2*xt, as we’d expect!\n\nyt.backward()\nxt.grad\n\ntensor([ 6.,  8., 20.])\n\n\nThe gradients only tell us the slope of our function, they don’t actually tell us exactly how far to adjust the parameters. But it gives us some idea of how far; if the slope is very large, then that may suggest that we have more adjustments to do, whereas if the slope is very small, that may suggest that we are close to the optimal value.\n\n\nStepping With a Learning Rate\nDeciding how to change our parameters based on the values of the gradients is an important part of the deep learning process. Nearly all approaches start with the basic idea of multiplying the gradient by some small number, called the learning rate (LR). The learning rate is often a number between 0.001 and 0.1, although it could be anything. Often, people select a learning rate just by trying a few, and finding which results in the best model after training (we’ll show you a better approach later in this book, called the learning rate finder). Once you’ve picked a learning rate, you can adjust your parameters using this simple function:\nw -= gradient(w) * lr\nThis is known as stepping your parameters, using an optimizer step. Notice how we subtract the gradient * lr from the parameter to update it. This allows us to adjust the parameter in the direction of the slope by increasing the parameter when the slope is negative and decreasing the parameter when the slope is positive. We want to adjust our parameters in the direction of the slope because our goal in deep learning is to minimize the loss.\nIf you pick a learning rate that’s too low, it can mean having to do a lot of steps. Figure 4.3 illustrates that.\n\n\n\n\n\n\nFigure 4.3: Gradient descent with low LR\n\n\n\nBut picking a learning rate that’s too high is even worse—it can actually result in the loss getting worse, as we see in Figure 4.4!\n\n\n\n\n\n\nFigure 4.4: Gradient descent with high LR\n\n\n\nIf the learning rate is too high, it may also “bounce” around, rather than actually diverging; Figure 4.5 shows how this has the result of taking many steps to train successfully.\n\n\n\n\n\n\nFigure 4.5: Gradient descent with bouncy LR\n\n\n\nNow let’s apply all of this in an end-to-end example.\n\n\nAn End-to-End SGD Example\nWe’ve seen how to use gradients to find a minimum. Now it’s time to look at an SGD example and see how finding a minimum can be used to train a model to fit data better.\nLet’s start with a simple, synthetic, example model. Imagine you were measuring the speed of a roller coaster as it went over the top of a hump. It would start fast, and then get slower as it went up the hill; it would be slowest at the top, and it would then speed up again as it went downhill. You want to build a model of how the speed changes over time. If you were measuring the speed manually every second for 20 seconds, it might look something like this:\n\ntime = torch.arange(0,20).float(); time\n\ntensor([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15., 16., 17., 18., 19.])\n\n\n\nspeed = torch.randn(20)*3 + 0.75*(time-9.5)**2 + 1\nplt.scatter(time,speed);\n\n\n\n\n\n\n\n\nWe’ve added a bit of random noise, since measuring things manually isn’t precise. This means it’s not that easy to answer the question: what was the roller coaster’s speed? Using SGD we can try to find a function that matches our observations. We can’t consider every possible function, so let’s use a guess that it will be quadratic; i.e., a function of the form a*(time**2)+(b*time)+c.\nWe want to distinguish clearly between the function’s input (the time when we are measuring the coaster’s speed) and its parameters (the values that define which quadratic we’re trying). So, let’s collect the parameters in one argument and thus separate the input, t, and the parameters, params, in the function’s signature:\n\ndef f(t, params):\n    a,b,c = params\n    return a*(t**2) + (b*t) + c\n\nIn other words, we’ve restricted the problem of finding the best imaginable function that fits the data, to finding the best quadratic function. This greatly simplifies the problem, since every quadratic function is fully defined by the three parameters a, b, and c. Thus, to find the best quadratic function, we only need to find the best values for a, b, and c.\nIf we can solve this problem for the three parameters of a quadratic function, we’ll be able to apply the same approach for other, more complex functions with more parameters—such as a neural net. Let’s find the parameters for f first, and then we’ll come back and do the same thing for the MNIST dataset with a neural net.\nWe need to define first what we mean by “best.” We define this precisely by choosing a loss function, which will return a value based on a prediction and a target, where lower values of the function correspond to “better” predictions. It is important for loss functions to return lower values when predictions are more accurate, as the SGD procedure we defined earlier will try to minimize this loss. For continuous data, it’s common to use mean squared error:\n\ndef mse(preds, targets): return ((preds-targets)**2).mean()\n\nNow, let’s work through our 7 step process.\n\nStep 1: Initialize the parameters\nFirst, we initialize the parameters to random values, and tell PyTorch that we want to track their gradients, using requires_grad_:\n\nparams = torch.randn(3).requires_grad_()\n\n\n\nStep 2: Calculate the predictions\nNext, we calculate the predictions:\n\npreds = f(time, params)\n\nLet’s create a little function to see how close our predictions are to our targets, and take a look:\n\ndef show_preds(preds, ax=None):\n    if ax is None: ax=plt.subplots()[1]\n    ax.scatter(time, speed)\n    ax.scatter(time, to_np(preds), color='red')\n    ax.set_ylim(-300,100)\n\n\nshow_preds(preds)\n\n\n\n\n\n\n\n\nThis doesn’t look very close—our random parameters suggest that the roller coaster will end up going backwards, since we have negative speeds!\n\n\nStep 3: Calculate the loss\nWe calculate the loss as follows:\n\nloss = mse(preds, speed)\nloss\n\ntensor(25823.8086, grad_fn=&lt;MeanBackward0&gt;)\n\n\nOur goal is now to improve this. To do that, we’ll need to know the gradients.\n\n\nStep 4: Calculate the gradients\nThe next step is to calculate the gradients. In other words, calculate an approximation of how the parameters need to change:\n\nloss.backward()\nparams.grad\n\ntensor([-53195.8633,  -3419.7148,   -253.8908])\n\n\n\nparams.grad * 1e-5\n\ntensor([-0.5320, -0.0342, -0.0025])\n\n\nWe can use these gradients to improve our parameters. We’ll need to pick a learning rate (we’ll discuss how to do that in practice in the next chapter; for now we’ll just use 1e-5, or 0.00001):\n\nparams\n\ntensor([-0.7658, -0.7506,  1.3525], requires_grad=True)\n\n\n\n\nStep 5: Step the weights.\nNow we need to update the parameters based on the gradients we just calculated:\n\nlr = 1e-5\nparams.data -= lr * params.grad.data\nparams.grad = None\n\n\na: Understanding this bit depends on remembering recent history. To calculate the gradients we call backward on the loss. But this loss was itself calculated by mse, which in turn took preds as an input, which was calculated using f taking as an input params, which was the object on which we originally called requires_grad_—which is the original call that now allows us to call backward on loss. This chain of function calls represents the mathematical composition of functions, which enables PyTorch to use calculus’s chain rule under the hood to calculate these gradients.\n\nLet’s see if the loss has improved:\n\npreds = f(time,params)\nmse(preds, speed)\n\ntensor(5435.5356, grad_fn=&lt;MeanBackward0&gt;)\n\n\nAnd take a look at the plot:\n\nshow_preds(preds)\n\n\n\n\n\n\n\n\nWe need to repeat this a few times, so we’ll create a function to apply one step:\n\ndef apply_step(params, prn=True):\n    preds = f(time, params)\n    loss = mse(preds, speed)\n    loss.backward()\n    params.data -= lr * params.grad.data\n    params.grad = None\n    if prn: print(loss.item())\n    return preds\n\n\n\nStep 6: Repeat the process\nNow we iterate. By looping and performing many improvements, we hope to reach a good result:\n\nfor i in range(10): apply_step(params)\n\n5435.53564453125\n1577.44921875\n847.3778076171875\n709.2225341796875\n683.0758056640625\n678.1243896484375\n677.1838989257812\n677.0023193359375\n676.9645385742188\n676.9537353515625\n\n\nThe loss is going down, just as we hoped! But looking only at these loss numbers disguises the fact that each iteration represents an entirely different quadratic function being tried, on the way to finding the best possible quadratic function. We can see this process visually if, instead of printing out the loss function, we plot the function at every step. Then we can see how the shape is approaching the best possible quadratic function for our data:\n\n_,axs = plt.subplots(1,4,figsize=(12,3))\nfor ax in axs: show_preds(apply_step(params, False), ax)\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\n\nStep 7: stop\nWe just decided to stop after 10 epochs arbitrarily. In practice, we would watch the training and validation losses and our metrics to decide when to stop, as we’ve discussed.\n\n\n\nSummarizing Gradient Descent\n\n\n\n\n\n\n\n\nFigure 4.6: The gradient descent process\n\n\n\n\n\nTo summarize, at the beginning, the weights of our model can be random (training from scratch) or come from a pretrained model (transfer learning). In the first case, the output we will get from our inputs won’t have anything to do with what we want, and even in the second case, it’s very likely the pretrained model won’t be very good at the specific task we are targeting. So the model will need to learn better weights.\nWe begin by comparing the outputs the model gives us with our targets (we have labeled data, so we know what result the model should give) using a loss function, which returns a number that we want to make as low as possible by improving our weights. To do this, we take a few data items (such as images) from the training set and feed them to our model. We compare the corresponding targets using our loss function, and the score we get tells us how wrong our predictions were. We then change the weights a little bit to make it slightly better.\nTo find how to change the weights to make the loss a bit better, we use calculus to calculate the gradients. (Actually, we let PyTorch do it for us!) Let’s consider an analogy. Imagine you are lost in the mountains with your car parked at the lowest point. To find your way back to it, you might wander in a random direction, but that probably wouldn’t help much. Since you know your vehicle is at the lowest point, you would be better off going downhill. By always taking a step in the direction of the steepest downward slope, you should eventually arrive at your destination. We use the magnitude of the gradient (i.e., the steepness of the slope) to tell us how big a step to take; specifically, we multiply the gradient by a number we choose called the learning rate to decide on the step size. We then iterate until we have reached the lowest point, which will be our parking lot, then we can stop.\nAll of that we just saw can be transposed directly to the MNIST dataset, except for the loss function. Let’s now see how we can define a good training objective.",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#the-mnist-loss-function",
    "href": "mnist_basics.html#the-mnist-loss-function",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.7 The MNIST Loss Function",
    "text": "4.7 The MNIST Loss Function\nWe already have our independent variables x—these are the images themselves. We’ll concatenate them all into a single tensor, and also change them from a list of matrices (a rank-3 tensor) to a list of vectors (a rank-2 tensor). We can do this using view, which is a PyTorch method that changes the shape of a tensor without changing its contents. -1 is a special parameter to view that means “make this axis as big as necessary to fit all the data”:\n\ntrain_x = torch.cat([stacked_threes, stacked_sevens]).view(-1, 28*28)\n\nWe need a label for each image. We’ll use 1 for 3s and 0 for 7s:\n\ntrain_y = tensor([1]*len(threes) + [0]*len(sevens)).unsqueeze(1)\ntrain_x.shape,train_y.shape\n\n(torch.Size([12396, 784]), torch.Size([12396, 1]))\n\n\nA Dataset in PyTorch is required to return a tuple of (x,y) when indexed. Python provides a zip function which, when combined with list, provides a simple way to get this functionality:\n\ndset = list(zip(train_x,train_y))\nx,y = dset[0]\nx.shape,y\n\n(torch.Size([784]), tensor([1]))\n\n\n\nvalid_x = torch.cat([valid_3_tens, valid_7_tens]).view(-1, 28*28)\nvalid_y = tensor([1]*len(valid_3_tens) + [0]*len(valid_7_tens)).unsqueeze(1)\nvalid_dset = list(zip(valid_x,valid_y))\n\nNow we need an (initially random) weight for every pixel (this is the initialize step in our seven-step process):\n\ndef init_params(size, std=1.0): return (torch.randn(size)*std).requires_grad_()\n\n\nweights = init_params((28*28,1))\n\nThe function weights*pixels won’t be flexible enough—it is always equal to 0 when the pixels are equal to 0 (i.e., its intercept is 0). You might remember from high school math that the formula for a line is y=w*x+b; we still need the b. We’ll initialize it to a random number too:\n\nbias = init_params(1)\n\nIn neural networks, the w in the equation y=w*x+b is called the weights, and the b is called the bias. Together, the weights and bias make up the parameters.\n\njargon: Parameters: The weights and biases of a model. The weights are the w in the equation w*x+b, and the biases are the b in that equation.\n\nWe can now calculate a prediction for one image:\n\n(train_x[0]*weights.T).sum() + bias\n\ntensor([20.2336], grad_fn=&lt;AddBackward0&gt;)\n\n\nWhile we could use a Python for loop to calculate the prediction for each image, that would be very slow. Because Python loops don’t run on the GPU, and because Python is a slow language for loops in general, we need to represent as much of the computation in a model as possible using higher-level functions.\nIn this case, there’s an extremely convenient mathematical operation that calculates w*x for every row of a matrix—it’s called matrix multiplication. Figure 4.7 shows what matrix multiplication looks like.\n\n\n\n\n\n\nFigure 4.7: Matrix multiplication\n\n\n\nThis image shows two matrices, A and B, being multiplied together. Each item of the result, which we’ll call AB, contains each item of its corresponding row of A multiplied by each item of its corresponding column of B, added together. For instance, row 1, column 2 (the yellow dot with a red border) is calculated as \\(a_{1,1} * b_{1,2} + a_{1,2} * b_{2,2}\\). If you need a refresher on matrix multiplication, we suggest you take a look at the Intro to Matrix Multiplication on Khan Academy, since this is the most important mathematical operation in deep learning.\nIn Python, matrix multiplication is represented with the @ operator. Let’s try it:\n\ndef linear1(xb): return xb@weights + bias\npreds = linear1(train_x)\npreds\n\ntensor([[20.2336],\n        [17.0644],\n        [15.2384],\n        ...,\n        [18.3804],\n        [23.8567],\n        [28.6816]], grad_fn=&lt;AddBackward0&gt;)\n\n\nThe first element is the same as we calculated before, as we’d expect. This equation, batch@weights + bias, is one of the two fundamental equations of any neural network (the other one is the activation function, which we’ll see in a moment).\nLet’s check our accuracy. To decide if an output represents a 3 or a 7, we can just check whether it’s greater than 0.0, so our accuracy for each item can be calculated (using broadcasting, so no loops!) with:\n\ncorrects = (preds&gt;0.0).float() == train_y\ncorrects\n\ntensor([[ True],\n        [ True],\n        [ True],\n        ...,\n        [False],\n        [False],\n        [False]])\n\n\n\ncorrects.float().mean().item()\n\n0.4912068545818329\n\n\nNow let’s see what the change in accuracy is for a small change in one of the weights (note that we have to ask PyTorch not to calculate gradients as we do this, which is what with torch.no_grad() is doing here):\n\nwith torch.no_grad(): weights[0] *= 1.0001\n\n\npreds = linear1(train_x)\n((preds&gt;0.0).float() == train_y).float().mean().item()\n\n0.4912068545818329\n\n\nAs we’ve seen, we need gradients in order to improve our model using SGD, and in order to calculate gradients we need some loss function that represents how good our model is. That is because the gradients are a measure of how that loss function changes with small tweaks to the weights.\nSo, we need to choose a loss function. The obvious approach would be to use accuracy, which is our metric, as our loss function as well. In this case, we would calculate our prediction for each image, collect these values to calculate an overall accuracy, and then calculate the gradients of each weight with respect to that overall accuracy.\nUnfortunately, we have a significant technical problem here. The gradient of a function is its slope, or its steepness, which can be defined as rise over run—that is, how much the value of the function goes up or down, divided by how much we changed the input. We can write this in mathematically as: (y_new - y_old) / (x_new - x_old). This gives us a good approximation of the gradient when x_new is very similar to x_old, meaning that their difference is very small. But accuracy only changes at all when a prediction changes from a 3 to a 7, or vice versa. The problem is that a small change in weights from x_old to x_new isn’t likely to cause any prediction to change, so (y_new - y_old) will almost always be 0. In other words, the gradient is 0 almost everywhere.\nA very small change in the value of a weight will often not actually change the accuracy at all. This means it is not useful to use accuracy as a loss function—if we do, most of the time our gradients will actually be 0, and the model will not be able to learn from that number.\n\nS: In mathematical terms, accuracy is a function that is constant almost everywhere (except at the threshold, 0.5), so its derivative is nil almost everywhere (and infinity at the threshold). This then gives gradients that are 0 or infinite, which are useless for updating the model.\n\nInstead, we need a loss function which, when our weights result in slightly better predictions, gives us a slightly better loss. So what does a “slightly better prediction” look like, exactly? Well, in this case, it means that if the correct answer is a 3 the score is a little higher, or if the correct answer is a 7 the score is a little lower.\nLet’s write such a function now. What form does it take?\nThe loss function receives not the images themselves, but the predictions from the model. Let’s make one argument, prds, of values between 0 and 1, where each value is the prediction that an image is a 3. It is a vector (i.e., a rank-1 tensor), indexed over the images.\nThe purpose of the loss function is to measure the difference between predicted values and the true values — that is, the targets (aka labels). Let’s make another argument, trgts, with values of 0 or 1 which tells whether an image actually is a 3 or not. It is also a vector (i.e., another rank-1 tensor), indexed over the images.\nSo, for instance, suppose we had three images which we knew were a 3, a 7, and a 3. And suppose our model predicted with high confidence (0.9) that the first was a 3, with slight confidence (0.4) that the second was a 7, and with fair confidence (0.2), but incorrectly, that the last was a 7. This would mean our loss function would receive these values as its inputs:\n\ntrgts  = tensor([1,0,1])\nprds   = tensor([0.9, 0.4, 0.2])\n\nHere’s a first try at a loss function that measures the distance between predictions and targets:\n\ndef mnist_loss(predictions, targets):\n    return torch.where(targets==1, 1-predictions, predictions).mean()\n\nWe’re using a new function, torch.where(a,b,c). This is the same as running the list comprehension [b[i] if a[i] else c[i] for i in range(len(a))], except it works on tensors, at C/CUDA speed. In plain English, this function will measure how distant each prediction is from 1 if it should be 1, and how distant it is from 0 if it should be 0, and then it will take the mean of all those distances.\n\nnote: Read the Docs: It’s important to learn about PyTorch functions like this, because looping over tensors in Python performs at Python speed, not C/CUDA speed! Try running help(torch.where) now to read the docs for this function, or, better still, look it up on the PyTorch documentation site.\n\nLet’s try it on our prds and trgts:\n\ntorch.where(trgts==1, 1-prds, prds)\n\ntensor([0.1000, 0.4000, 0.8000])\n\n\nYou can see that this function returns a lower number when predictions are more accurate, when accurate predictions are more confident (higher absolute values), and when inaccurate predictions are less confident. In PyTorch, we always assume that a lower value of a loss function is better. Since we need a scalar for the final loss, mnist_loss takes the mean of the previous tensor:\n\nmnist_loss(prds,trgts)\n\ntensor(0.4333)\n\n\nFor instance, if we change our prediction for the one “false” target from 0.2 to 0.8 the loss will go down, indicating that this is a better prediction:\n\nmnist_loss(tensor([0.9, 0.4, 0.8]),trgts)\n\ntensor(0.2333)\n\n\nOne problem with mnist_loss as currently defined is that it assumes that predictions are always between 0 and 1. We need to ensure, then, that this is actually the case! As it happens, there is a function that does exactly that—let’s take a look.\n\nSigmoid\nThe sigmoid function always outputs a number between 0 and 1. It’s defined as follows:\n\ndef sigmoid(x): return 1/(1+torch.exp(-x))\n\nPytorch defines an accelerated version for us, so we don’t really need our own. This is an important function in deep learning, since we often want to ensure values are between 0 and 1. This is what it looks like:\n\nplot_function(torch.sigmoid, title='Sigmoid', min=-4, max=4)\n\n\n\n\n\n\n\n\nAs you can see, it takes any input value, positive or negative, and smooshes it onto an output value between 0 and 1. It’s also a smooth curve that only goes up, which makes it easier for SGD to find meaningful gradients.\nLet’s update mnist_loss to first apply sigmoid to the inputs:\n\ndef mnist_loss(predictions, targets):\n    predictions = predictions.sigmoid()\n    return torch.where(targets==1, 1-predictions, predictions).mean()\n\nNow we can be confident our loss function will work, even if the predictions are not between 0 and 1. All that is required is that a higher prediction corresponds to higher confidence an image is a 3.\nHaving defined a loss function, now is a good moment to recapitulate why we did this. After all, we already had a metric, which was overall accuracy. So why did we define a loss?\nThe key difference is that the metric is to drive human understanding and the loss is to drive automated learning. To drive automated learning, the loss must be a function that has a meaningful derivative. It can’t have big flat sections and large jumps, but instead must be reasonably smooth. This is why we designed a loss function that would respond to small changes in confidence level. This requirement means that sometimes it does not really reflect exactly what we are trying to achieve, but is rather a compromise between our real goal and a function that can be optimized using its gradient. The loss function is calculated for each item in our dataset, and then at the end of an epoch the loss values are all averaged and the overall mean is reported for the epoch.\nMetrics, on the other hand, are the numbers that we really care about. These are the values that are printed at the end of each epoch that tell us how our model is really doing. It is important that we learn to focus on these metrics, rather than the loss, when judging the performance of a model.\n\n\nSGD and Mini-Batches\nNow that we have a loss function that is suitable for driving SGD, we can consider some of the details involved in the next phase of the learning process, which is to change or update the weights based on the gradients. This is called an optimization step.\nIn order to take an optimization step we need to calculate the loss over one or more data items. How many should we use? We could calculate it for the whole dataset, and take the average, or we could calculate it for a single data item. But neither of these is ideal. Calculating it for the whole dataset would take a very long time. Calculating it for a single item would not use much information, so it would result in a very imprecise and unstable gradient. That is, you’d be going to the trouble of updating the weights, but taking into account only how that would improve the model’s performance on that single item.\nSo instead we take a compromise between the two: we calculate the average loss for a few data items at a time. This is called a mini-batch. The number of data items in the mini-batch is called the batch size. A larger batch size means that you will get a more accurate and stable estimate of your dataset’s gradients from the loss function, but it will take longer, and you will process fewer mini-batches per epoch. Choosing a good batch size is one of the decisions you need to make as a deep learning practitioner to train your model quickly and accurately. We will talk about how to make this choice throughout this book.\nAnother good reason for using mini-batches rather than calculating the gradient on individual data items is that, in practice, we nearly always do our training on an accelerator such as a GPU. These accelerators only perform well if they have lots of work to do at a time, so it’s helpful if we can give them lots of data items to work on. Using mini-batches is one of the best ways to do this. However, if you give them too much data to work on at once, they run out of memory—making GPUs happy is also tricky!\nAs we saw in our discussion of data augmentation in Chapter 2, we get better generalization if we can vary things during training. One simple and effective thing we can vary is what data items we put in each mini-batch. Rather than simply enumerating our dataset in order for every epoch, instead what we normally do is randomly shuffle it on every epoch, before we create mini-batches. PyTorch and fastai provide a class that will do the shuffling and mini-batch collation for you, called DataLoader.\nA DataLoader can take any Python collection and turn it into an iterator over mini-batches, like so:\n\ncoll = range(15)\ndl = DataLoader(coll, batch_size=5, shuffle=True)\nlist(dl)\n\n[tensor([ 3, 12,  8, 10,  2]),\n tensor([ 9,  4,  7, 14,  5]),\n tensor([ 1, 13,  0,  6, 11])]\n\n\nFor training a model, we don’t just want any Python collection, but a collection containing independent and dependent variables (that is, the inputs and targets of the model). A collection that contains tuples of independent and dependent variables is known in PyTorch as a Dataset. Here’s an example of an extremely simple Dataset:\n\nds = L(enumerate(string.ascii_lowercase))\nds\n\n(#26) [(0, 'a'),(1, 'b'),(2, 'c'),(3, 'd'),(4, 'e'),(5, 'f'),(6, 'g'),(7, 'h'),(8, 'i'),(9, 'j')...]\n\n\nWhen we pass a Dataset to a DataLoader we will get back mini-batches which are themselves tuples of tensors representing batches of independent and dependent variables:\n\ndl = DataLoader(ds, batch_size=6, shuffle=True)\nlist(dl)\n\n[(tensor([17, 18, 10, 22,  8, 14]), ('r', 's', 'k', 'w', 'i', 'o')),\n (tensor([20, 15,  9, 13, 21, 12]), ('u', 'p', 'j', 'n', 'v', 'm')),\n (tensor([ 7, 25,  6,  5, 11, 23]), ('h', 'z', 'g', 'f', 'l', 'x')),\n (tensor([ 1,  3,  0, 24, 19, 16]), ('b', 'd', 'a', 'y', 't', 'q')),\n (tensor([2, 4]), ('c', 'e'))]\n\n\nWe are now ready to write our first training loop for a model using SGD!",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#putting-it-all-together",
    "href": "mnist_basics.html#putting-it-all-together",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.8 Putting It All Together",
    "text": "4.8 Putting It All Together\nIt’s time to implement the process we saw in Figure 4.2. In code, our process will be implemented something like this for each epoch:\nfor x,y in dl:\n    pred = model(x)\n    loss = loss_func(pred, y)\n    loss.backward()\n    parameters -= parameters.grad * lr\nFirst, let’s re-initialize our parameters:\n\nweights = init_params((28*28,1))\nbias = init_params(1)\n\nA DataLoader can be created from a Dataset:\n\ndl = DataLoader(dset, batch_size=256)\nxb,yb = first(dl)\nxb.shape,yb.shape\n\n(torch.Size([256, 784]), torch.Size([256, 1]))\n\n\nWe’ll do the same for the validation set:\n\nvalid_dl = DataLoader(valid_dset, batch_size=256)\n\nLet’s create a mini-batch of size 4 for testing:\n\nbatch = train_x[:4]\nbatch.shape\n\ntorch.Size([4, 784])\n\n\n\npreds = linear1(batch)\npreds\n\ntensor([[-11.1002],\n        [  5.9263],\n        [  9.9627],\n        [ -8.1484]], grad_fn=&lt;AddBackward0&gt;)\n\n\n\nloss = mnist_loss(preds, train_y[:4])\nloss\n\ntensor(0.5006, grad_fn=&lt;MeanBackward0&gt;)\n\n\nNow we can calculate the gradients:\n\nloss.backward()\nweights.grad.shape,weights.grad.mean(),bias.grad\n\n(torch.Size([784, 1]), tensor(-0.0001), tensor([-0.0008]))\n\n\nLet’s put that all in a function:\n\ndef calc_grad(xb, yb, model):\n    preds = model(xb)\n    loss = mnist_loss(preds, yb)\n    loss.backward()\n\nand test it:\n\ncalc_grad(batch, train_y[:4], linear1)\nweights.grad.mean(),bias.grad\n\n(tensor(-0.0002), tensor([-0.0015]))\n\n\nBut look what happens if we call it twice:\n\ncalc_grad(batch, train_y[:4], linear1)\nweights.grad.mean(),bias.grad\n\n(tensor(-0.0003), tensor([-0.0023]))\n\n\nThe gradients have changed! The reason for this is that loss.backward actually adds the gradients of loss to any gradients that are currently stored. So, we have to set the current gradients to 0 first:\n\nweights.grad.zero_()\nbias.grad.zero_();\n\n\nnote: Inplace Operations: Methods in PyTorch whose names end in an underscore modify their objects in place. For instance, bias.zero_() sets all elements of the tensor bias to 0.\n\nOur only remaining step is to update the weights and biases based on the gradient and learning rate. When we do so, we have to tell PyTorch not to take the gradient of this step too—otherwise things will get very confusing when we try to compute the derivative at the next batch! If we assign to the data attribute of a tensor then PyTorch will not take the gradient of that step. Here’s our basic training loop for an epoch:\n\ndef train_epoch(model, lr, params):\n    for xb,yb in dl:\n        calc_grad(xb, yb, model)\n        for p in params:\n            p.data -= p.grad*lr\n            p.grad.zero_()\n\nWe also want to check how we’re doing, by looking at the accuracy of the validation set. To decide if an output represents a 3 or a 7, we can just check whether it’s greater than 0. So our accuracy for each item can be calculated (using broadcasting, so no loops!) with:\n\n(preds&gt;0.0).float() == train_y[:4]\n\ntensor([[False],\n        [ True],\n        [ True],\n        [False]])\n\n\nThat gives us this function to calculate our validation accuracy:\n\ndef batch_accuracy(xb, yb):\n    preds = xb.sigmoid()\n    correct = (preds&gt;0.5) == yb\n    return correct.float().mean()\n\nWe can check it works:\n\nbatch_accuracy(linear1(batch), train_y[:4])\n\ntensor(0.5000)\n\n\nand then put the batches together:\n\ndef validate_epoch(model):\n    accs = [batch_accuracy(model(xb), yb) for xb,yb in valid_dl]\n    return round(torch.stack(accs).mean().item(), 4)\n\n\nvalidate_epoch(linear1)\n\n0.5219\n\n\nThat’s our starting point. Let’s train for one epoch, and see if the accuracy improves:\n\nlr = 1.\nparams = weights,bias\ntrain_epoch(linear1, lr, params)\nvalidate_epoch(linear1)\n\n0.6883\n\n\nThen do a few more:\n\nfor i in range(20):\n    train_epoch(linear1, lr, params)\n    print(validate_epoch(linear1), end=' ')\n\n0.8314 0.9017 0.9227 0.9349 0.9438 0.9501 0.9535 0.9564 0.9594 0.9618 0.9613 0.9638 0.9643 0.9652 0.9662 0.9677 0.9687 0.9691 0.9691 0.9696 \n\n\nLooking good! We’re already about at the same accuracy as our “pixel similarity” approach, and we’ve created a general-purpose foundation we can build on. Our next step will be to create an object that will handle the SGD step for us. In PyTorch, it’s called an optimizer.\n\nCreating an Optimizer\nBecause this is such a general foundation, PyTorch provides some useful classes to make it easier to implement. The first thing we can do is replace our linear1 function with PyTorch’s nn.Linear module. A module is an object of a class that inherits from the PyTorch nn.Module class. Objects of this class behave identically to standard Python functions, in that you can call them using parentheses and they will return the activations of a model.\nnn.Linear does the same thing as our init_params and linear together. It contains both the weights and biases in a single class. Here’s how we replicate our model from the previous section:\n\nlinear_model = nn.Linear(28*28,1)\n\nEvery PyTorch module knows what parameters it has that can be trained; they are available through the parameters method:\n\nw,b = linear_model.parameters()\nw.shape,b.shape\n\n(torch.Size([1, 784]), torch.Size([1]))\n\n\nWe can use this information to create an optimizer:\n\nclass BasicOptim:\n    def __init__(self,params,lr): self.params,self.lr = list(params),lr\n\n    def step(self, *args, **kwargs):\n        for p in self.params: p.data -= p.grad.data * self.lr\n\n    def zero_grad(self, *args, **kwargs):\n        for p in self.params: p.grad = None\n\nWe can create our optimizer by passing in the model’s parameters:\n\nopt = BasicOptim(linear_model.parameters(), lr)\n\nOur training loop can now be simplified to:\n\ndef train_epoch(model):\n    for xb,yb in dl:\n        calc_grad(xb, yb, model)\n        opt.step()\n        opt.zero_grad()\n\nOur validation function doesn’t need to change at all:\n\nvalidate_epoch(linear_model)\n\n0.4157\n\n\nLet’s put our little training loop in a function, to make things simpler:\n\ndef train_model(model, epochs):\n    for i in range(epochs):\n        train_epoch(model)\n        print(validate_epoch(model), end=' ')\n\nThe results are the same as in the previous section:\n\ntrain_model(linear_model, 20)\n\n0.4932 0.8618 0.8203 0.9102 0.9331 0.9468 0.9555 0.9629 0.9658 0.9673 0.9687 0.9707 0.9726 0.9751 0.9761 0.9761 0.9775 0.978 0.9785 0.9785 \n\n\nfastai provides the SGD class which, by default, does the same thing as our BasicOptim:\n\nlinear_model = nn.Linear(28*28,1)\nopt = SGD(linear_model.parameters(), lr)\ntrain_model(linear_model, 20)\n\n0.4932 0.852 0.8335 0.9116 0.9326 0.9473 0.9555 0.9624 0.9648 0.9668 0.9692 0.9712 0.9731 0.9746 0.9761 0.9765 0.9775 0.978 0.9785 0.9785 \n\n\nfastai also provides Learner.fit, which we can use instead of train_model. To create a Learner we first need to create a DataLoaders, by passing in our training and validation DataLoaders:\n\ndls = DataLoaders(dl, valid_dl)\n\nTo create a Learner without using an application (such as vision_learner) we need to pass in all the elements that we’ve created in this chapter: the DataLoaders, the model, the optimization function (which will be passed the parameters), the loss function, and optionally any metrics to print:\n\nlearn = Learner(dls, nn.Linear(28*28,1), opt_func=SGD,\n                loss_func=mnist_loss, metrics=batch_accuracy)\n\nNow we can call fit:\n\nlearn.fit(10, lr=lr)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nbatch_accuracy\ntime\n\n\n\n\n0\n0.636857\n0.503549\n0.495584\n00:00\n\n\n1\n0.545725\n0.170281\n0.866045\n00:00\n\n\n2\n0.199223\n0.184893\n0.831207\n00:00\n\n\n3\n0.086580\n0.107836\n0.911187\n00:00\n\n\n4\n0.045185\n0.078481\n0.932777\n00:00\n\n\n5\n0.029108\n0.062792\n0.946516\n00:00\n\n\n6\n0.022560\n0.053017\n0.955348\n00:00\n\n\n7\n0.019687\n0.046500\n0.962218\n00:00\n\n\n8\n0.018252\n0.041929\n0.965162\n00:00\n\n\n9\n0.017402\n0.038573\n0.967615\n00:00\n\n\n\n\n\nAs you can see, there’s nothing magic about the PyTorch and fastai classes. They are just convenient pre-packaged pieces that make your life a bit easier! (They also provide a lot of extra functionality we’ll be using in future chapters.)\nWith these classes, we can now replace our linear model with a neural network.",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#adding-a-nonlinearity",
    "href": "mnist_basics.html#adding-a-nonlinearity",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.9 Adding a Nonlinearity",
    "text": "4.9 Adding a Nonlinearity\nSo far we have a general procedure for optimizing the parameters of a function, and we have tried it out on a very boring function: a simple linear classifier. A linear classifier is very constrained in terms of what it can do. To make it a bit more complex (and able to handle more tasks), we need to add something nonlinear between two linear classifiers—this is what gives us a neural network.\nHere is the entire definition of a basic neural network:\n\ndef simple_net(xb): \n    res = xb@w1 + b1\n    res = res.max(tensor(0.0))\n    res = res@w2 + b2\n    return res\n\nThat’s it! All we have in simple_net is two linear classifiers with a max function between them.\nHere, w1 and w2 are weight tensors, and b1 and b2 are bias tensors; that is, parameters that are initially randomly initialized, just like we did in the previous section:\n\nw1 = init_params((28*28,30))\nb1 = init_params(30)\nw2 = init_params((30,1))\nb2 = init_params(1)\n\nThe key point about this is that w1 has 30 output activations (which means that w2 must have 30 input activations, so they match). That means that the first layer can construct 30 different features, each representing some different mix of pixels. You can change that 30 to anything you like, to make the model more or less complex.\nThat little function res.max(tensor(0.0)) is called a rectified linear unit, also known as ReLU. We think we can all agree that rectified linear unit sounds pretty fancy and complicated… But actually, there’s nothing more to it than res.max(tensor(0.0))—in other words, replace every negative number with a zero. This tiny function is also available in PyTorch as F.relu:\n\nplot_function(F.relu)\n\n\n\n\n\n\n\n\n\nJ: There is an enormous amount of jargon in deep learning, including terms like rectified linear unit. The vast vast majority of this jargon is no more complicated than can be implemented in a short line of code, as we saw in this example. The reality is that for academics to get their papers published they need to make them sound as impressive and sophisticated as possible. One of the ways that they do that is to introduce jargon. Unfortunately, this has the result that the field ends up becoming far more intimidating and difficult to get into than it should be. You do have to learn the jargon, because otherwise papers and tutorials are not going to mean much to you. But that doesn’t mean you have to find the jargon intimidating. Just remember, when you come across a word or phrase that you haven’t seen before, it will almost certainly turn out to be referring to a very simple concept.\n\nThe basic idea is that by using more linear layers, we can have our model do more computation, and therefore model more complex functions. But there’s no point just putting one linear layer directly after another one, because when we multiply things together and then add them up multiple times, that could be replaced by multiplying different things together and adding them up just once! That is to say, a series of any number of linear layers in a row can be replaced with a single linear layer with a different set of parameters.\nBut if we put a nonlinear function between them, such as max, then this is no longer true. Now each linear layer is actually somewhat decoupled from the other ones, and can do its own useful work. The max function is particularly interesting, because it operates as a simple if statement.\n\nS: Mathematically, we say the composition of two linear functions is another linear function. So, we can stack as many linear classifiers as we want on top of each other, and without nonlinear functions between them, it will just be the same as one linear classifier.\n\nAmazingly enough, it can be mathematically proven that this little function can solve any computable problem to an arbitrarily high level of accuracy, if you can find the right parameters for w1 and w2 and if you make these matrices big enough. For any arbitrarily wiggly function, we can approximate it as a bunch of lines joined together; to make it closer to the wiggly function, we just have to use shorter lines. This is known as the universal approximation theorem. The three lines of code that we have here are known as layers. The first and third are known as linear layers, and the second line of code is known variously as a nonlinearity, or activation function.\nJust like in the previous section, we can replace this code with something a bit simpler, by taking advantage of PyTorch:\n\nsimple_net = nn.Sequential(\n    nn.Linear(28*28,30),\n    nn.ReLU(),\n    nn.Linear(30,1)\n)\n\nnn.Sequential creates a module that will call each of the listed layers or functions in turn.\nnn.ReLU is a PyTorch module that does exactly the same thing as the F.relu function. Most functions that can appear in a model also have identical forms that are modules. Generally, it’s just a case of replacing F with nn and changing the capitalization. When using nn.Sequential, PyTorch requires us to use the module version. Since modules are classes, we have to instantiate them, which is why you see nn.ReLU() in this example.\nBecause nn.Sequential is a module, we can get its parameters, which will return a list of all the parameters of all the modules it contains. Let’s try it out! As this is a deeper model, we’ll use a lower learning rate and a few more epochs.\n\nlearn = Learner(dls, simple_net, opt_func=SGD,\n                loss_func=mnist_loss, metrics=batch_accuracy)\n\n\nlearn.fit(40, 0.1)\n\nWe’re not showing the 40 lines of output here to save room; the training process is recorded in learn.recorder, with the table of output stored in the values attribute, so we can plot the accuracy over training as:\n\nplt.plot(L(learn.recorder.values).itemgot(2));\n\n\n\n\n\n\n\n\nAnd we can view the final accuracy:\n\nlearn.recorder.values[-1][2]\n\n0.982826292514801\n\n\nAt this point we have something that is rather magical:\n\nA function that can solve any problem to any level of accuracy (the neural network) given the correct set of parameters\nA way to find the best set of parameters for any function (stochastic gradient descent)\n\nThis is why deep learning can do things which seem rather magical, such fantastic things. Believing that this combination of simple techniques can really solve any problem is one of the biggest steps that we find many students have to take. It seems too good to be true—surely things should be more difficult and complicated than this? Our recommendation: try it out! We just tried it on the MNIST dataset and you have seen the results. And since we are doing everything from scratch ourselves (except for calculating the gradients) you know that there is no special magic hiding behind the scenes.\n\nGoing Deeper\nThere is no need to stop at just two linear layers. We can add as many as we want, as long as we add a nonlinearity between each pair of linear layers. As you will learn, however, the deeper the model gets, the harder it is to optimize the parameters in practice. Later in this book you will learn about some simple but brilliantly effective techniques for training deeper models.\nWe already know that a single nonlinearity with two linear layers is enough to approximate any function. So why would we use deeper models? The reason is performance. With a deeper model (that is, one with more layers) we do not need to use as many parameters; it turns out that we can use smaller matrices with more layers, and get better results than we would get with larger matrices, and few layers.\nThat means that we can train the model more quickly, and it will take up less memory. In the 1990s researchers were so focused on the universal approximation theorem that very few were experimenting with more than one nonlinearity. This theoretical but not practical foundation held back the field for years. Some researchers, however, did experiment with deep models, and eventually were able to show that these models could perform much better in practice. Eventually, theoretical results were developed which showed why this happens. Today, it is extremely unusual to find anybody using a neural network with just one nonlinearity.\nHere is what happens when we train an 18-layer model using the same approach we saw in Chapter 1:\n\ndls = ImageDataLoaders.from_folder(path)\nlearn = vision_learner(dls, resnet18, pretrained=False,\n                    loss_func=F.cross_entropy, metrics=accuracy)\nlearn.fit_one_cycle(1, 0.1)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.082089\n0.009578\n0.997056\n00:11\n\n\n\n\n\nNearly 100% accuracy! That’s a big difference compared to our simple neural net. But as you’ll learn in the remainder of this book, there are just a few little tricks you need to use to get such great results from scratch yourself. You already know the key foundational pieces. (Of course, even once you know all the tricks, you’ll nearly always want to work with the pre-built classes provided by PyTorch and fastai, because they save you having to think about all the little details yourself.)",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#jargon-recap",
    "href": "mnist_basics.html#jargon-recap",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.10 Jargon Recap",
    "text": "4.10 Jargon Recap\nCongratulations: you now know how to create and train a deep neural network from scratch! We’ve gone through quite a few steps to get to this point, but you might be surprised at how simple it really is.\nNow that we are at this point, it is a good opportunity to define, and review, some jargon and key concepts.\nA neural network contains a lot of numbers, but they are only of two types: numbers that are calculated, and the parameters that these numbers are calculated from. This gives us the two most important pieces of jargon to learn:\n\nActivations:: Numbers that are calculated (both by linear and nonlinear layers)\nParameters:: Numbers that are randomly initialized, and optimized (that is, the numbers that define the model)\n\nWe will often talk in this book about activations and parameters. Remember that they have very specific meanings. They are numbers. They are not abstract concepts, but they are actual specific numbers that are in your model. Part of becoming a good deep learning practitioner is getting used to the idea of actually looking at your activations and parameters, and plotting them and testing whether they are behaving correctly.\nOur activations and parameters are all contained in tensors. These are simply regularly shaped arrays—for example, a matrix. Matrices have rows and columns; we call these the axes or dimensions. The number of dimensions of a tensor is its rank. There are some special tensors:\n\nRank zero: scalar\nRank one: vector\nRank two: matrix\n\nA neural network contains a number of layers. Each layer is either linear or nonlinear. We generally alternate between these two kinds of layers in a neural network. Sometimes people refer to both a linear layer and its subsequent nonlinearity together as a single layer. Yes, this is confusing. Sometimes a nonlinearity is referred to as an activation function.\nTable 4.1 summarizes the key concepts related to SGD.\n\n\n\nTable 4.1: Deep learning vocabulary\n\n\n\n\n\n\n\n\n\nTerm\nMeaning\n\n\n\n\nReLU\nFunction that returns 0 for negative numbers and doesn’t change positive numbers.\n\n\nMini-batch\nA small group of inputs and labels gathered together in two arrays. A gradient descent step is updated on this batch (rather than a whole epoch).\n\n\nForward pass\nApplying the model to some input and computing the predictions.\n\n\nLoss\nA value that represents how well (or badly) our model is doing.\n\n\nGradient\nThe derivative of the loss with respect to some parameter of the model.\n\n\nBackward pass\nComputing the gradients of the loss with respect to all model parameters.\n\n\nGradient descent\nTaking a step in the directions opposite to the gradients to make the model parameters a little bit better.\n\n\nLearning rate\nThe size of the step we take when applying SGD to update the parameters of the model.\n\n\n\n\n\n\n\nnote: Choose Your Own Adventure Reminder: Did you choose to skip over chapters 2 & 3, in your excitement to peek under the hood? Well, here’s your reminder to head back to chapter 2 now, because you’ll be needing to know that stuff very soon!",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "mnist_basics.html#questionnaire",
    "href": "mnist_basics.html#questionnaire",
    "title": "4  Under the Hood: Training a Digit Classifier",
    "section": "4.11 Questionnaire",
    "text": "4.11 Questionnaire\n\nHow is a grayscale image represented on a computer? How about a color image?\nHow are the files and folders in the MNIST_SAMPLE dataset structured? Why?\nExplain how the “pixel similarity” approach to classifying digits works.\nWhat is a list comprehension? Create one now that selects odd numbers from a list and doubles them.\nWhat is a “rank-3 tensor”?\nWhat is the difference between tensor rank and shape? How do you get the rank from the shape?\nWhat are RMSE and L1 norm?\nHow can you apply a calculation on thousands of numbers at once, many thousands of times faster than a Python loop?\nCreate a 3×3 tensor or array containing the numbers from 1 to 9. Double it. Select the bottom-right four numbers.\nWhat is broadcasting?\nAre metrics generally calculated using the training set, or the validation set? Why?\nWhat is SGD?\nWhy does SGD use mini-batches?\nWhat are the seven steps in SGD for machine learning?\nHow do we initialize the weights in a model?\nWhat is “loss”?\nWhy can’t we always use a high learning rate?\nWhat is a “gradient”?\nDo you need to know how to calculate gradients yourself?\nWhy can’t we use accuracy as a loss function?\nDraw the sigmoid function. What is special about its shape?\nWhat is the difference between a loss function and a metric?\nWhat is the function to calculate new weights using a learning rate?\nWhat does the DataLoader class do?\nWrite pseudocode showing the basic steps taken in each epoch for SGD.\nCreate a function that, if passed two arguments [1,2,3,4] and 'abcd', returns [(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd')]. What is special about that output data structure?\nWhat does view do in PyTorch?\nWhat are the “bias” parameters in a neural network? Why do we need them?\nWhat does the @ operator do in Python?\nWhat does the backward method do?\nWhy do we have to zero the gradients?\nWhat information do we have to pass to Learner?\nShow Python or pseudocode for the basic steps of a training loop.\nWhat is “ReLU”? Draw a plot of it for values from -2 to +2.\nWhat is an “activation function”?\nWhat’s the difference between F.relu and nn.ReLU?\nThe universal approximation theorem shows that any function can be approximated as closely as needed using just one nonlinearity. So why do we normally use more?\n\n\nFurther Research\n\nCreate your own implementation of Learner from scratch, based on the training loop shown in this chapter.\nComplete all the steps in this chapter using the full MNIST datasets (that is, for all digits, not just 3s and 7s). This is a significant project and will take you quite a bit of time to complete! You’ll need to do some of your own research to figure out how to overcome some obstacles you’ll meet on the way.",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Under the Hood: Training a Digit Classifier</span>"
    ]
  },
  {
    "objectID": "convolutions.html",
    "href": "convolutions.html",
    "title": "13  Convolutional Neural Networks",
    "section": "",
    "text": "13.1 The Magic of Convolutions\nOne of the most powerful tools that machine learning practitioners have at their disposal is feature engineering. A feature is a transformation of the data which is designed to make it easier to model. For instance, the add_datepart function that we used for our tabular dataset preprocessing in Chapter 9 added date features to the Bulldozers dataset. What kinds of features might we be able to create from images?\nIn the context of an image, a feature is a visually distinctive attribute. For example, the number 7 is characterized by a horizontal edge near the top of the digit, and a top-right to bottom-left diagonal edge underneath that. On the other hand, the number 3 is characterized by a diagonal edge in one direction at the top left and bottom right of the digit, the opposite diagonal at the bottom left and top right, horizontal edges at the middle, top, and bottom, and so forth. So what if we could extract information about where the edges occur in each image, and then use that information as our features, instead of raw pixels?\nIt turns out that finding the edges in an image is a very common task in computer vision, and is surprisingly straightforward. To do it, we use something called a convolution. A convolution requires nothing more than multiplication, and addition—two operations that are responsible for the vast majority of work that we will see in every single deep learning model in this book!\nA convolution applies a kernel across an image. A kernel is a little matrix, such as the 3×3 matrix in the top right of Figure 13.1.\nThe 7×7 grid to the left is the image we’re going to apply the kernel to. The convolution operation multiplies each element of the kernel by each element of a 3×3 block of the image. The results of these multiplications are then added together. The diagram in Figure 13.1 shows an example of applying a kernel to a single location in the image, the 3×3 block around cell 18.\nLet’s do this with code. First, we create a little 3×3 matrix like so:\ntop_edge = tensor([[-1,-1,-1],\n                   [ 0, 0, 0],\n                   [ 1, 1, 1]]).float()\nWe’re going to call this our kernel (because that’s what fancy computer vision researchers call these). And we’ll need an image, of course:\npath = untar_data(URLs.MNIST_SAMPLE)\nim3 = Image.open(path/'train'/'3'/'12.png')\nshow_image(im3);\nNow we’re going to take the top 3×3-pixel square of our image, and multiply each of those values by each item in our kernel. Then we’ll add them up, like so:\nim3_t = tensor(im3)\nim3_t[0:3,0:3] * top_edge\n\ntensor([[-0., -0., -0.],\n        [0., 0., 0.],\n        [0., 0., 0.]])\n(im3_t[0:3,0:3] * top_edge).sum()\n\ntensor(0.)\nNot very interesting so far—all the pixels in the top-left corner are white. But let’s pick a couple of more interesting spots:\ndf = pd.DataFrame(im3_t[:10,:20])\ndf.style.set_properties(**{'font-size':'6pt'}).background_gradient('Greys')\nThere’s a top edge at cell 5,8. Let’s repeat our calculation there:\n(im3_t[4:7,6:9] * top_edge).sum()\n\ntensor(762.)\nThere’s a right edge at cell 8,18. What does that give us?:\n(im3_t[7:10,17:20] * top_edge).sum()\n\ntensor(-29.)\nAs you can see, this little calculation is returning a high number where the 3×3-pixel square represents a top edge (i.e., where there are low values at the top of the square, and high values immediately underneath). That’s because the -1 values in our kernel have little impact in that case, but the 1 values have a lot.\nLet’s look a tiny bit at the math. The filter will take any window of size 3×3 in our images, and if we name the pixel values like this:\n\\[\\begin{matrix} a1 & a2 & a3 \\\\ a4 & a5 & a6 \\\\ a7 & a8 & a9 \\end{matrix}\\]\nit will return \\(-a1-a2-a3+a7+a8+a9\\). If we are in a part of the image where \\(a1\\), \\(a2\\), and \\(a3\\) add up to the same as \\(a7\\), \\(a8\\), and \\(a9\\), then the terms will cancel each other out and we will get 0. However, if \\(a7\\) is greater than \\(a1\\), \\(a8\\) is greater than \\(a2\\), and \\(a9\\) is greater than \\(a3\\), we will get a bigger number as a result. So this filter detects horizontal edges—more precisely, edges where we go from bright parts of the image at the top to darker parts at the bottom.\nChanging our filter to have the row of 1s at the top and the -1s at the bottom would detect horizontal edges that go from dark to light. Putting the 1s and -1s in columns versus rows would give us filters that detect vertical edges. Each set of weights will produce a different kind of outcome.\nLet’s create a function to do this for one location, and check it matches our result from before:\ndef apply_kernel(row, col, kernel):\n    return (im3_t[row-1:row+2,col-1:col+2] * kernel).sum()\napply_kernel(5,7,top_edge)\n\ntensor(762.)\nBut note that we can’t apply it to the corner (e.g., location 0,0), since there isn’t a complete 3×3 square there.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Convolutional Neural Networks</span>"
    ]
  },
  {
    "objectID": "convolutions.html#the-magic-of-convolutions",
    "href": "convolutions.html#the-magic-of-convolutions",
    "title": "13  Convolutional Neural Networks",
    "section": "",
    "text": "jargon: Feature engineering: Creating new transformations of the input data in order to make it easier to model.\n\n\n\n\n\n\n\n\n\n\nFigure 13.1: Applying a kernel to one location\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMapping a Convolution Kernel\nWe can map apply_kernel() across the coordinate grid. That is, we’ll be taking our 3×3 kernel, and applying it to each 3×3 section of our image. For instance, Figure 13.2 shows the positions a 3×3 kernel can be applied to in the first row of a 5×5 image.\n\n\n\n\n\n\nFigure 13.2: Applying a kernel across a grid\n\n\n\nTo get a grid of coordinates we can use a nested list comprehension, like so:\n\n[[(i,j) for j in range(1,5)] for i in range(1,5)]\n\n[[(1, 1), (1, 2), (1, 3), (1, 4)],\n [(2, 1), (2, 2), (2, 3), (2, 4)],\n [(3, 1), (3, 2), (3, 3), (3, 4)],\n [(4, 1), (4, 2), (4, 3), (4, 4)]]\n\n\n\nnote: Nested List Comprehensions: Nested list comprehensions are used a lot in Python, so if you haven’t seen them before, take a few minutes to make sure you understand what’s happening here, and experiment with writing your own nested list comprehensions.\n\nHere’s the result of applying our kernel over a coordinate grid:\n\nrng = range(1,27)\ntop_edge3 = tensor([[apply_kernel(i,j,top_edge) for j in rng] for i in rng])\n\nshow_image(top_edge3);\n\n\n\n\n\n\n\n\nLooking good! Our top edges are black, and bottom edges are white (since they are the opposite of top edges). Now that our image contains negative numbers too, matplotlib has automatically changed our colors so that white is the smallest number in the image, black the highest, and zeros appear as gray.\nWe can try the same thing for left edges:\n\nleft_edge = tensor([[-1,1,0],\n                    [-1,1,0],\n                    [-1,1,0]]).float()\n\nleft_edge3 = tensor([[apply_kernel(i,j,left_edge) for j in rng] for i in rng])\n\nshow_image(left_edge3);\n\n\n\n\n\n\n\n\nAs we mentioned before, a convolution is the operation of applying such a kernel over a grid in this way. In the paper “A Guide to Convolution Arithmetic for Deep Learning” there are many great diagrams showing how image kernels can be applied. Here’s an example from the paper showing (at the bottom) a light blue 4×4 image, with a dark blue 3×3 kernel being applied, creating a 2×2 green output activation map at the top.\n\n\n\n\n\n\nFigure 13.3: Result of applying a 3×3 kernel to a 4×4 image (courtesy of Vincent Dumoulin and Francesco Visin)\n\n\n\nLook at the shape of the result. If the original image has a height of h and a width of w, how many 3×3 windows can we find? As you can see from the example, there are h-2 by w-2 windows, so the image we get has a result as a height of h-2 and a width of w-2.\nWe won’t implement this convolution function from scratch, but use PyTorch’s implementation instead (it is way faster than anything we could do in Python).\n\n\nConvolutions in PyTorch\nConvolution is such an important and widely used operation that PyTorch has it built in. It’s called F.conv2d (recall that F is a fastai import from torch.nn.functional, as recommended by PyTorch). The PyTorch docs tell us that it includes these parameters:\n\ninput:: input tensor of shape (minibatch, in_channels, iH, iW)\nweight:: filters of shape (out_channels, in_channels, kH, kW)\n\nHere iH,iW is the height and width of the image (i.e., 28,28), and kH,kW is the height and width of our kernel (3,3). But apparently PyTorch is expecting rank-4 tensors for both these arguments, whereas currently we only have rank-2 tensors (i.e., matrices, or arrays with two axes).\nThe reason for these extra axes is that PyTorch has a few tricks up its sleeve. The first trick is that PyTorch can apply a convolution to multiple images at the same time. That means we can call it on every item in a batch at once!\nThe second trick is that PyTorch can apply multiple kernels at the same time. So let’s create the diagonal-edge kernels too, and then stack all four of our edge kernels into a single tensor:\n\ndiag1_edge = tensor([[ 0,-1, 1],\n                     [-1, 1, 0],\n                     [ 1, 0, 0]]).float()\ndiag2_edge = tensor([[ 1,-1, 0],\n                     [ 0, 1,-1],\n                     [ 0, 0, 1]]).float()\n\nedge_kernels = torch.stack([left_edge, top_edge, diag1_edge, diag2_edge])\nedge_kernels.shape\n\ntorch.Size([4, 3, 3])\n\n\nTo test this, we’ll need a DataLoader and a sample mini-batch. Let’s use the data block API:\n\nmnist = DataBlock((ImageBlock(cls=PILImageBW), CategoryBlock), \n                  get_items=get_image_files, \n                  splitter=GrandparentSplitter(),\n                  get_y=parent_label)\n\ndls = mnist.dataloaders(path)\nxb,yb = first(dls.valid)\nxb.shape\n\ntorch.Size([64, 1, 28, 28])\n\n\nBy default, fastai puts data on the GPU when using data blocks. Let’s move it to the CPU for our examples:\n\nxb,yb = to_cpu(xb),to_cpu(yb)\n\nOne batch contains 64 images, each of 1 channel, with 28×28 pixels. F.conv2d can handle multichannel (i.e., color) images too. A channel is a single basic color in an image—for regular full-color images there are three channels, red, green, and blue. PyTorch represents an image as a rank-3 tensor, with dimensions [channels, rows, columns].\nWe’ll see how to handle more than one channel later in this chapter. Kernels passed to F.conv2d need to be rank-4 tensors: [channels_in, features_out, rows, columns]. edge_kernels is currently missing one of these. We need to tell PyTorch that the number of input channels in the kernel is one, which we can do by inserting an axis of size one (this is known as a unit axis) in the first location, where the PyTorch docs show in_channels is expected. To insert a unit axis into a tensor, we use the unsqueeze method:\n\nedge_kernels.shape,edge_kernels.unsqueeze(1).shape\n\n(torch.Size([4, 3, 3]), torch.Size([4, 1, 3, 3]))\n\n\nThis is now the correct shape for edge_kernels. Let’s pass this all to conv2d:\n\nedge_kernels = edge_kernels.unsqueeze(1)\n\n\nbatch_features = F.conv2d(xb, edge_kernels)\nbatch_features.shape\n\ntorch.Size([64, 4, 26, 26])\n\n\nThe output shape shows we gave 64 images in the mini-batch, 4 kernels, and 26×26 edge maps (we started with 28×28 images, but lost one pixel from each side as discussed earlier). We can see we get the same results as when we did this manually:\n\nshow_image(batch_features[0,0]);\n\n\n\n\n\n\n\n\nThe most important trick that PyTorch has up its sleeve is that it can use the GPU to do all this work in parallel—that is, applying multiple kernels, to multiple images, across multiple channels. Doing lots of work in parallel is critical to getting GPUs to work efficiently; if we did each of these operations one at a time, we’d often run hundreds of times slower (and if we used our manual convolution loop from the previous section, we’d be millions of times slower!). Therefore, to become a strong deep learning practitioner, one skill to practice is giving your GPU plenty of work to do at a time.\nIt would be nice to not lose those two pixels on each axis. The way we do that is to add padding, which is simply additional pixels added around the outside of our image. Most commonly, pixels of zeros are added.\n\n\nStrides and Padding\nWith appropriate padding, we can ensure that the output activation map is the same size as the original image, which can make things a lot simpler when we construct our architectures. Figure 13.4 shows how adding padding allows us to apply the kernels in the image corners.\n\n\n\n\n\n\nFigure 13.4: A convolution with padding\n\n\n\nWith a 5×5 input, 4×4 kernel, and 2 pixels of padding, we end up with a 6×6 activation map, as we can see in Figure 13.5.\n\n\n\n\n\n\nFigure 13.5: A 4×4 kernel with 5×5 input and 2 pixels of padding (courtesy of Vincent Dumoulin and Francesco Visin)\n\n\n\nIf we add a kernel of size ks by ks (with ks an odd number), the necessary padding on each side to keep the same shape is ks//2. An even number for ks would require a different amount of padding on the top/bottom and left/right, but in practice we almost never use an even filter size.\nSo far, when we have applied the kernel to the grid, we have moved it one pixel over at a time. But we can jump further; for instance, we could move over two pixels after each kernel application, as in Figure 13.6. This is known as a stride-2 convolution. The most common kernel size in practice is 3×3, and the most common padding is 1. As you’ll see, stride-2 convolutions are useful for decreasing the size of our outputs, and stride-1 convolutions are useful for adding layers without changing the output size.\n\n\n\n\n\n\nFigure 13.6: A 3×3 kernel with 5×5 input, stride-2 convolution, and 1 pixel of padding (courtesy of Vincent Dumoulin and Francesco Visin)\n\n\n\nIn an image of size h by w, using a padding of 1 and a stride of 2 will give us a result of size (h+1)//2 by (w+1)//2. The general formula for each dimension is (n + 2*pad - ks)//stride + 1, where pad is the padding, ks, the size of our kernel, and stride is the stride.\nLet’s now take a look at how the pixel values of the result of our convolutions are computed.\n\n\nUnderstanding the Convolution Equations\nTo explain the math behind convolutions, fast.ai student Matt Kleinsmith came up with the very clever idea of showing CNNs from different viewpoints. In fact, it’s so clever, and so helpful, we’re going to show it here too!\nHere’s our 3×3 pixel image, with each pixel labeled with a letter:\n\nAnd here’s our kernel, with each weight labeled with a Greek letter:\n\nSince the filter fits in the image four times, we have four results:\n\nFigure 13.7 shows how we applied the kernel to each section of the image to yield each result.\n\n\n\n\n\n\nFigure 13.7: Applying the kernel\n\n\n\nThe equation view is in Figure 13.8.\n\n\n\n\n\n\nFigure 13.8: The equation\n\n\n\nNotice that the bias term, b, is the same for each section of the image. You can consider the bias as part of the filter, just like the weights (α, β, γ, δ) are part of the filter.\nHere’s an interesting insight—a convolution can be represented as a special kind of matrix multiplication, as illustrated in Figure 13.9. The weight matrix is just like the ones from traditional neural networks. However, this weight matrix has two special properties:\n\nThe zeros shown in gray are untrainable. This means that they’ll stay zero throughout the optimization process.\nSome of the weights are equal, and while they are trainable (i.e., changeable), they must remain equal. These are called shared weights.\n\nThe zeros correspond to the pixels that the filter can’t touch. Each row of the weight matrix corresponds to one application of the filter.\n\n\n\n\n\n\nFigure 13.9: Convolution as matrix multiplication\n\n\n\nNow that we understand what a convolution is, let’s use them to build a neural net.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Convolutional Neural Networks</span>"
    ]
  },
  {
    "objectID": "convolutions.html#our-first-convolutional-neural-network",
    "href": "convolutions.html#our-first-convolutional-neural-network",
    "title": "13  Convolutional Neural Networks",
    "section": "13.2 Our First Convolutional Neural Network",
    "text": "13.2 Our First Convolutional Neural Network\nThere is no reason to believe that some particular edge filters are the most useful kernels for image recognition. Furthermore, we’ve seen that in later layers convolutional kernels become complex transformations of features from lower levels, but we don’t have a good idea of how to manually construct these.\nInstead, it would be best to learn the values of the kernels. We already know how to do this—SGD! In effect, the model will learn the features that are useful for classification.\nWhen we use convolutions instead of (or in addition to) regular linear layers we create a convolutional neural network (CNN).\n\nCreating the CNN\nLet’s go back to the basic neural network we had in Chapter 4. It was defined like this:\n\nsimple_net = nn.Sequential(\n    nn.Linear(28*28,30),\n    nn.ReLU(),\n    nn.Linear(30,1)\n)\n\nWe can view a model’s definition:\n\nsimple_net\n\nSequential(\n  (0): Linear(in_features=784, out_features=30, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=30, out_features=1, bias=True)\n)\n\n\nWe now want to create a similar architecture to this linear model, but using convolutional layers instead of linear. nn.Conv2d is the module equivalent of F.conv2d. It’s more convenient than F.conv2d when creating an architecture, because it creates the weight matrix for us automatically when we instantiate it.\nHere’s a possible architecture:\n\nbroken_cnn = sequential(\n    nn.Conv2d(1,30, kernel_size=3, padding=1),\n    nn.ReLU(),\n    nn.Conv2d(30,1, kernel_size=3, padding=1)\n)\n\nOne thing to note here is that we didn’t need to specify 28×28 as the input size. That’s because a linear layer needs a weight in the weight matrix for every pixel, so it needs to know how many pixels there are, but a convolution is applied over each pixel automatically. The weights only depend on the number of input and output channels and the kernel size, as we saw in the previous section.\nThink about what the output shape is going to be, then let’s try it and see:\n\nbroken_cnn(xb).shape\n\ntorch.Size([64, 1, 28, 28])\n\n\nThis is not something we can use to do classification, since we need a single output activation per image, not a 28×28 map of activations. One way to deal with this is to use enough stride-2 convolutions such that the final layer is size 1. That is, after one stride-2 convolution the size will be 14×14, after two it will be 7×7, then 4×4, 2×2, and finally size 1.\nLet’s try that now. First, we’ll define a function with the basic parameters we’ll use in each convolution:\n\ndef conv(ni, nf, ks=3, act=True):\n    res = nn.Conv2d(ni, nf, stride=2, kernel_size=ks, padding=ks//2)\n    if act: res = nn.Sequential(res, nn.ReLU())\n    return res\n\n\nimportant: Refactoring: Refactoring parts of your neural networks like this makes it much less likely you’ll get errors due to inconsistencies in your architectures, and makes it more obvious to the reader which parts of your layers are actually changing.\n\nWhen we use a stride-2 convolution, we often increase the number of features at the same time. This is because we’re decreasing the number of activations in the activation map by a factor of 4; we don’t want to decrease the capacity of a layer by too much at a time.\n\njargon: channels and features: These two terms are largely used interchangeably, and refer to the size of the second axis of a weight matrix, which is, the number of activations per grid cell after a convolution. Features is never used to refer to the input data, but channels can refer to either the input data (generally channels are colors) or activations inside the network.\n\nHere is how we can build a simple CNN:\n\nsimple_cnn = sequential(\n    conv(1 ,4),            #14x14\n    conv(4 ,8),            #7x7\n    conv(8 ,16),           #4x4\n    conv(16,32),           #2x2\n    conv(32,2, act=False), #1x1\n    Flatten(),\n)\n\n\nj: I like to add comments like the ones here after each convolution to show how large the activation map will be after each layer. These comments assume that the input size is 28*28\n\nNow the network outputs two activations, which map to the two possible levels in our labels:\n\nsimple_cnn(xb).shape\n\ntorch.Size([64, 2])\n\n\nWe can now create our Learner:\n\nlearn = Learner(dls, simple_cnn, loss_func=F.cross_entropy, metrics=accuracy)\n\nTo see exactly what’s going on in the model, we can use summary:\n\nlearn.summary()\n\nSequential (Input shape: ['64 x 1 x 28 x 28'])\n================================================================\nLayer (type)         Output Shape         Param #    Trainable \n================================================================\nConv2d               64 x 4 x 14 x 14     40         True      \n________________________________________________________________\nReLU                 64 x 4 x 14 x 14     0          False     \n________________________________________________________________\nConv2d               64 x 8 x 7 x 7       296        True      \n________________________________________________________________\nReLU                 64 x 8 x 7 x 7       0          False     \n________________________________________________________________\nConv2d               64 x 16 x 4 x 4      1,168      True      \n________________________________________________________________\nReLU                 64 x 16 x 4 x 4      0          False     \n________________________________________________________________\nConv2d               64 x 32 x 2 x 2      4,640      True      \n________________________________________________________________\nReLU                 64 x 32 x 2 x 2      0          False     \n________________________________________________________________\nConv2d               64 x 2 x 1 x 1       578        True      \n________________________________________________________________\nFlatten              64 x 2               0          False     \n________________________________________________________________\n\nTotal params: 6,722\nTotal trainable params: 6,722\nTotal non-trainable params: 0\n\nOptimizer used: &lt;function Adam&gt;\nLoss function: &lt;function cross_entropy&gt;\n\nCallbacks:\n  - TrainEvalCallback\n  - Recorder\n  - ProgressCallback\n\n\nNote that the output of the final Conv2d layer is 64x2x1x1. We need to remove those extra 1x1 axes; that’s what Flatten does. It’s basically the same as PyTorch’s squeeze method, but as a module.\nLet’s see if this trains! Since this is a deeper network than we’ve built from scratch before, we’ll use a lower learning rate and more epochs:\n\nlearn.fit_one_cycle(2, 0.01)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.072684\n0.045110\n0.990186\n00:05\n\n\n1\n0.022580\n0.030775\n0.990186\n00:05\n\n\n\n\n\nSuccess! It’s getting closer to the resnet18 result we had, although it’s not quite there yet, and it’s taking more epochs, and we’re needing to use a lower learning rate. We still have a few more tricks to learn, but we’re getting closer and closer to being able to create a modern CNN from scratch.\n\n\nUnderstanding Convolution Arithmetic\nWe can see from the summary that we have an input of size 64x1x28x28. The axes are batch,channel,height,width. This is often represented as NCHW (where N refers to batch size). Tensorflow, on the other hand, uses NHWC axis order. The first layer is:\n\nm = learn.model[0]\nm\n\nSequential(\n  (0): Conv2d(1, 4, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n  (1): ReLU()\n)\n\n\nSo we have 1 input channel, 4 output channels, and a 3×3 kernel. Let’s check the weights of the first convolution:\n\nm[0].weight.shape\n\ntorch.Size([4, 1, 3, 3])\n\n\nThe summary shows we have 40 parameters, and 4*1*3*3 is 36. What are the other four parameters? Let’s see what the bias contains:\n\nm[0].bias.shape\n\ntorch.Size([4])\n\n\nWe can now use this information to clarify our statement in the previous section: “When we use a stride-2 convolution, we often increase the number of features because we’re decreasing the number of activations in the activation map by a factor of 4; we don’t want to decrease the capacity of a layer by too much at a time.”\nThere is one bias for each channel. (Sometimes channels are called features or filters when they are not input channels.) The output shape is 64x4x14x14, and this will therefore become the input shape to the next layer. The next layer, according to summary, has 296 parameters. Let’s ignore the batch axis to keep things simple. So for each of 14*14=196 locations we are multiplying 296-8=288 weights (ignoring the bias for simplicity), so that’s 196*288=56_448 multiplications at this layer. The next layer will have 7*7*(1168-16)=56_448 multiplications.\nWhat happened here is that our stride-2 convolution halved the grid size from 14x14 to 7x7, and we doubled the number of filters from 8 to 16, resulting in no overall change in the amount of computation. If we left the number of channels the same in each stride-2 layer, the amount of computation being done in the net would get less and less as it gets deeper. But we know that the deeper layers have to compute semantically rich features (such as eyes or fur), so we wouldn’t expect that doing less computation would make sense.\nAnother way to think of this is based on receptive fields.\n\n\nReceptive Fields\nThe receptive field is the area of an image that is involved in the calculation of a layer. On the book’s website, you’ll find an Excel spreadsheet called conv-example.xlsx that shows the calculation of two stride-2 convolutional layers using an MNIST digit. Each layer has a single kernel. Figure 13.10 shows what we see if we click on one of the cells in the conv2 section, which shows the output of the second convolutional layer, and click trace precedents.\n\n\n\n\n\n\nFigure 13.10: Immediate precedents of Conv2 layer\n\n\n\nHere, the cell with the green border is the cell we clicked on, and the blue highlighted cells are its precedents—that is, the cells used to calculate its value. These cells are the corresponding 3×3 area of cells from the input layer (on the left), and the cells from the filter (on the right). Let’s now click trace precedents again, to see what cells are used to calculate these inputs. Figure 13.11 shows what happens.\n\n\n\n\n\n\nFigure 13.11: Secondary precedents of Conv2 layer\n\n\n\nIn this example, we have just two convolutional layers, each of stride 2, so this is now tracing right back to the input image. We can see that a 7×7 area of cells in the input layer is used to calculate the single green cell in the Conv2 layer. This 7×7 area is the receptive field in the input of the green activation in Conv2. We can also see that a second filter kernel is needed now, since we have two layers.\nAs you see from this example, the deeper we are in the network (specifically, the more stride-2 convs we have before a layer), the larger the receptive field for an activation in that layer. A large receptive field means that a large amount of the input image is used to calculate each activation in that layer is. We now know that in the deeper layers of the network we have semantically rich features, corresponding to larger receptive fields. Therefore, we’d expect that we’d need more weights for each of our features to handle this increasing complexity. This is another way of saying the same thing we mentioned in the previous section: when we introduce a stride-2 conv in our network, we should also increase the number of channels.\nWhen writing this particular chapter, we had a lot of questions we needed answers for, to be able to explain CNNs to you as best we could. Believe it or not, we found most of the answers on Twitter. We’re going to take a quick break to talk to you about that now, before we move on to color images.\n\n\nA Note About Twitter\nWe are not, to say the least, big users of social networks in general. But our goal in writing this book is to help you become the best deep learning practitioner you can, and we would be remiss not to mention how important Twitter has been in our own deep learning journeys.\nYou see, there’s another part of Twitter, far away from Donald Trump and the Kardashians, which is the part of Twitter where deep learning researchers and practitioners talk shop every day. As we were writing this section, Jeremy wanted to double-check that what we were saying about stride-2 convolutions was accurate, so he asked on Twitter:\n\nA few minutes later, this answer popped up:\n\nChristian Szegedy is the first author of Inception, the 2014 ImageNet winner and source of many key insights used in modern neural networks. Two hours later, this appeared:\n\nDo you recognize that name? You saw it in Chapter 2, when we were talking about the Turing Award winners who established the foundations of deep learning today!\nJeremy also asked on Twitter for help checking our description of label smoothing in Chapter 7 was accurate, and got a response again from directly from Christian Szegedy (label smoothing was originally introduced in the Inception paper):\n\nMany of the top people in deep learning today are Twitter regulars, and are very open about interacting with the wider community. One good way to get started is to look at a list of Jeremy’s recent Twitter likes, or Sylvain’s. That way, you can see a list of Twitter users that we think have interesting and useful things to say.\nTwitter is the main way we both stay up to date with interesting papers, software releases, and other deep learning news. For making connections with the deep learning community, we recommend getting involved both in the fast.ai forums and on Twitter.\nThat said, let’s get back to the meat of this chapter. Up until now, we have only shown you examples of pictures in black and white, with one value per pixel. In practice, most colored images have three values per pixel to define their color. We’ll look at working with color images next.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Convolutional Neural Networks</span>"
    ]
  },
  {
    "objectID": "convolutions.html#color-images",
    "href": "convolutions.html#color-images",
    "title": "13  Convolutional Neural Networks",
    "section": "13.3 Color Images",
    "text": "13.3 Color Images\nA colour picture is a rank-3 tensor:\n\nim = image2tensor(Image.open(image_bear()))\nim.shape\n\ntorch.Size([3, 1000, 846])\n\n\n\nshow_image(im);\n\n\n\n\n\n\n\n\nThe first axis contains the channels, red, green, and blue:\n\n_,axs = subplots(1,3)\nfor bear,ax,color in zip(im,axs,('Reds','Greens','Blues')):\n    show_image(255-bear, ax=ax, cmap=color)\n\n\n\n\n\n\n\n\nWe saw what the convolution operation was for one filter on one channel of the image (our examples were done on a square). A convolutional layer will take an image with a certain number of channels (three for the first layer for regular RGB color images) and output an image with a different number of channels. Like our hidden size that represented the numbers of neurons in a linear layer, we can decide to have as many filters as we want, and each of them will be able to specialize, some to detect horizontal edges, others to detect vertical edges and so forth, to give something like we studied in Chapter 2.\nIn one sliding window, we have a certain number of channels and we need as many filters (we don’t use the same kernel for all the channels). So our kernel doesn’t have a size of 3 by 3, but ch_in (for channels in) is 3 by 3. On each channel, we multiply the elements of our window by the elements of the coresponding filter, then sum the results (as we saw before) and sum over all the filters. In the example given in Figure 13.12, the result of our conv layer on that window is red + green + blue.\n\n\n\n\n\n\nFigure 13.12: Convolution over an RGB image\n\n\n\nSo, in order to apply a convolution to a color picture we require a kernel tensor with a size that matches the first axis. At each location, the corresponding parts of the kernel and the image patch are multiplied together.\nThese are then all added together, to produce a single number, for each grid location, for each output feature, as shown in Figure 13.13.\n\n\n\n\n\n\nFigure 13.13: Adding the RGB filters\n\n\n\nThen we have ch_out filters like this, so in the end, the result of our convolutional layer will be a batch of images with ch_out channels and a height and width given by the formula outlined earlier. This give us ch_out tensors of size ch_in x ks x ks that we represent in one big tensor of four dimensions. In PyTorch, the order of the dimensions for those weights is ch_out x ch_in x ks x ks.\nAdditionally, we may want to have a bias for each filter. In the preceding example, the final result for our convolutional layer would be \\(y_{R} + y_{G} + y_{B} + b\\) in that case. Like in a linear layer, there are as many bias as we have kernels, so the biases is a vector of size ch_out.\nThere are no special mechanisms required when setting up a CNN for training with color images. Just make sure your first layer has three inputs.\nThere are lots of ways of processing color images. For instance, you can change them to black and white, change from RGB to HSV (hue, saturation, and value) color space, and so forth. In general, it turns out experimentally that changing the encoding of colors won’t make any difference to your model results, as long as you don’t lose information in the transformation. So, transforming to black and white is a bad idea, since it removes the color information entirely (and this can be critical; for instance, a pet breed may have a distinctive color); but converting to HSV generally won’t make any difference.\nNow you know what those pictures in Chapter 1 of “what a neural net learns” from the Zeiler and Fergus paper mean! This is their picture of some of the layer 1 weights which we showed:\n\nThis is taking the three slices of the convolutional kernel, for each output feature, and displaying them as images. We can see that even though the creators of the neural net never explicitly created kernels to find edges, for instance, the neural net automatically discovered these features using SGD.\nNow let’s see how we can train these CNNs, and show you all the techniques fastai uses under the hood for efficient training.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Convolutional Neural Networks</span>"
    ]
  },
  {
    "objectID": "convolutions.html#improving-training-stability",
    "href": "convolutions.html#improving-training-stability",
    "title": "13  Convolutional Neural Networks",
    "section": "13.4 Improving Training Stability",
    "text": "13.4 Improving Training Stability\nSince we are so good at recognizing 3s from 7s, let’s move on to something harder—recognizing all 10 digits. That means we’ll need to use MNIST instead of MNIST_SAMPLE:\n\npath = untar_data(URLs.MNIST)\n\n\npath.ls()\n\n(#2) [Path('testing'),Path('training')]\n\n\nThe data is in two folders named training and testing, so we have to tell GrandparentSplitter about that (it defaults to train and valid). We did do that in the get_dls function, which we create to make it easy to change our batch size later:\n\ndef get_dls(bs=64):\n    return DataBlock(\n        blocks=(ImageBlock(cls=PILImageBW), CategoryBlock), \n        get_items=get_image_files, \n        splitter=GrandparentSplitter('training','testing'),\n        get_y=parent_label,\n        batch_tfms=Normalize()\n    ).dataloaders(path, bs=bs)\n\ndls = get_dls()\n\nRemember, it’s always a good idea to look at your data before you use it:\n\ndls.show_batch(max_n=9, figsize=(4,4))\n\n\n\n\n\n\n\n\nNow that we have our data ready, we can train a simple model on it.\n\nA Simple Baseline\nEarlier in this chapter, we built a model based on a conv function like this:\n\ndef conv(ni, nf, ks=3, act=True):\n    res = nn.Conv2d(ni, nf, stride=2, kernel_size=ks, padding=ks//2)\n    if act: res = nn.Sequential(res, nn.ReLU())\n    return res\n\nLet’s start with a basic CNN as a baseline. We’ll use the same one as earlier, but with one tweak: we’ll use more activations. Since we have more numbers to differentiate, it’s likely we will need to learn more filters.\nAs we discussed, we generally want to double the number of filters each time we have a stride-2 layer. One way to increase the number of filters throughout our network is to double the number of activations in the first layer–then every layer after that will end up twice as big as in the previous version as well.\nBut there is a subtle problem with this. Consider the kernel that is being applied to each pixel. By default, we use a 3×3-pixel kernel. That means that there are a total of 3×3 = 9 pixels that the kernel is being applied to at each location. Previously, our first layer had four output filters. That meant that there were four values being computed from nine pixels at each location. Think about what happens if we double this output to eight filters. Then when we apply our kernel we will be using nine pixels to calculate eight numbers. That means it isn’t really learning much at all: the output size is almost the same as the input size. Neural networks will only create useful features if they’re forced to do so—that is, if the number of outputs from an operation is significantly smaller than the number of inputs.\nTo fix this, we can use a larger kernel in the first layer. If we use a kernel of 5×5 pixels then there are 25 pixels being used at each kernel application. Creating eight filters from this will mean the neural net will have to find some useful features:\n\ndef simple_cnn():\n    return sequential(\n        conv(1 ,8, ks=5),        #14x14\n        conv(8 ,16),             #7x7\n        conv(16,32),             #4x4\n        conv(32,64),             #2x2\n        conv(64,10, act=False),  #1x1\n        Flatten(),\n    )\n\nAs you’ll see in a moment, we can look inside our models while they’re training in order to try to find ways to make them train better. To do this we use the ActivationStats callback, which records the mean, standard deviation, and histogram of activations of every trainable layer (as we’ve seen, callbacks are used to add behavior to the training loop; we’ll explore how they work in Chapter 16):\n\nfrom fastai.callback.hook import *\n\nWe want to train quickly, so that means training at a high learning rate. Let’s see how we go at 0.06:\n\ndef fit(epochs=1):\n    learn = Learner(dls, simple_cnn(), loss_func=F.cross_entropy,\n                    metrics=accuracy, cbs=ActivationStats(with_hist=True))\n    learn.fit(epochs, 0.06)\n    return learn\n\n\nlearn = fit()\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n2.307071\n2.305865\n0.113500\n00:16\n\n\n\n\n\nThis didn’t train at all well! Let’s find out why.\nOne handy feature of the callbacks passed to Learner is that they are made available automatically, with the same name as the callback class, except in snake_case. So, our ActivationStats callback can be accessed through activation_stats. I’m sure you remember learn.recorder… can you guess how that is implemented? That’s right, it’s a callback called Recorder!\nActivationStats includes some handy utilities for plotting the activations during training. plot_layer_stats(idx) plots the mean and standard deviation of the activations of layer number idx, along with the percentage of activations near zero. Here’s the first layer’s plot:\n\nlearn.activation_stats.plot_layer_stats(0)\n\n\n\n\n\n\n\n\nGenerally our model should have a consistent, or at least smooth, mean and standard deviation of layer activations during training. Activations near zero are particularly problematic, because it means we have computation in the model that’s doing nothing at all (since multiplying by zero gives zero). When you have some zeros in one layer, they will therefore generally carry over to the next layer… which will then create more zeros. Here’s the penultimate layer of our network:\n\nlearn.activation_stats.plot_layer_stats(-2)\n\n\n\n\n\n\n\n\nAs expected, the problems get worse towards the end of the network, as the instability and zero activations compound over layers. Let’s look at what we can do to make training more stable.\n\n\nIncrease Batch Size\nOne way to make training more stable is to increase the batch size. Larger batches have gradients that are more accurate, since they’re calculated from more data. On the downside, though, a larger batch size means fewer batches per epoch, which means less opportunities for your model to update weights. Let’s see if a batch size of 512 helps:\n\ndls = get_dls(512)\n\n\nlearn = fit()\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n2.309385\n2.302744\n0.113500\n00:08\n\n\n\n\n\nLet’s see what the penultimate layer looks like:\n\nlearn.activation_stats.plot_layer_stats(-2)\n\n\n\n\n\n\n\n\nAgain, we’ve got most of our activations near zero. Let’s see what else we can do to improve training stability.\n\n\n1cycle Training\nOur initial weights are not well suited to the task we’re trying to solve. Therefore, it is dangerous to begin training with a high learning rate: we may very well make the training diverge instantly, as we’ve seen. We probably don’t want to end training with a high learning rate either, so that we don’t skip over a minimum. But we want to train at a high learning rate for the rest of the training period, because we’ll be able to train more quickly that way. Therefore, we should change the learning rate during training, from low, to high, and then back to low again.\nLeslie Smith (yes, the same guy that invented the learning rate finder!) developed this idea in his article “Super-Convergence: Very Fast Training of Neural Networks Using Large Learning Rates”. He designed a schedule for learning rate separated into two phases: one where the learning rate grows from the minimum value to the maximum value (warmup), and one where it decreases back to the minimum value (annealing). Smith called this combination of approaches 1cycle training.\n1cycle training allows us to use a much higher maximum learning rate than other types of training, which gives two benefits:\n\nBy training with higher learning rates, we train faster—a phenomenon Smith named super-convergence.\nBy training with higher learning rates, we overfit less because we skip over the sharp local minima to end up in a smoother (and therefore more generalizable) part of the loss.\n\nThe second point is an interesting and subtle one; it is based on the observation that a model that generalizes well is one whose loss would not change very much if you changed the input by a small amount. If a model trains at a large learning rate for quite a while, and can find a good loss when doing so, it must have found an area that also generalizes well, because it is jumping around a lot from batch to batch (that is basically the definition of a high learning rate). The problem is that, as we have discussed, just jumping to a high learning rate is more likely to result in diverging losses, rather than seeing your losses improve. So we don’t jump straight to a high learning rate. Instead, we start at a low learning rate, where our losses do not diverge, and we allow the optimizer to gradually find smoother and smoother areas of our parameters by gradually going to higher and higher learning rates.\nThen, once we have found a nice smooth area for our parameters, we want to find the very best part of that area, which means we have to bring our learning rates down again. This is why 1cycle training has a gradual learning rate warmup, and a gradual learning rate cooldown. Many researchers have found that in practice this approach leads to more accurate models and trains more quickly. That is why it is the approach that is used by default for fine_tune in fastai.\nIn Chapter 16 we’ll learn all about momentum in SGD. Briefly, momentum is a technique where the optimizer takes a step not only in the direction of the gradients, but also that continues in the direction of previous steps. Leslie Smith introduced the idea of cyclical momentums in “A Disciplined Approach to Neural Network Hyper-Parameters: Part 1”. It suggests that the momentum varies in the opposite direction of the learning rate: when we are at high learning rates, we use less momentum, and we use more again in the annealing phase.\nWe can use 1cycle training in fastai by calling fit_one_cycle:\n\ndef fit(epochs=1, lr=0.06):\n    learn = Learner(dls, simple_cnn(), loss_func=F.cross_entropy,\n                    metrics=accuracy, cbs=ActivationStats(with_hist=True))\n    learn.fit_one_cycle(epochs, lr)\n    return learn\n\n\nlearn = fit()\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.210838\n0.084827\n0.974300\n00:08\n\n\n\n\n\nWe’re finally making some progress! It’s giving us a reasonable accuracy now.\nWe can view the learning rate and momentum throughout training by calling plot_sched on learn.recorder. learn.recorder (as the name suggests) records everything that happens during training, including losses, metrics, and hyperparameters such as learning rate and momentum:\n\nlearn.recorder.plot_sched()\n\n\n\n\n\n\n\n\nSmith’s original 1cycle paper used a linear warmup and linear annealing. As you can see, we adapted the approach in fastai by combining it with another popular approach: cosine annealing. fit_one_cycle provides the following parameters you can adjust:\n\nlr_max:: The highest learning rate that will be used (this can also be a list of learning rates for each layer group, or a Python slice object containing the first and last layer group learning rates)\ndiv:: How much to divide lr_max by to get the starting learning rate\ndiv_final:: How much to divide lr_max by to get the ending learning rate\npct_start:: What percentage of the batches to use for the warmup\nmoms:: A tuple (mom1,mom2,mom3) where mom1 is the initial momentum, mom2 is the minimum momentum, and mom3 is the final momentum\n\nLet’s take a look at our layer stats again:\n\nlearn.activation_stats.plot_layer_stats(-2)\n\n\n\n\n\n\n\n\nThe percentage of near-zero weights is getting much better, although it’s still quite high.\nWe can see even more about what’s going on in our training using color_dim, passing it a layer index:\n\nlearn.activation_stats.color_dim(-2)\n\n\n\n\n\n\n\n\ncolor_dim was developed by fast.ai in conjunction with a student, Stefano Giomo. Stefano, who refers to the idea as the colorful dimension, provides an in-depth explanation of the history and details behind the method. The basic idea is to create a histogram of the activations of a layer, which we would hope would follow a smooth pattern such as the normal distribution (colorful_dist).\n\n\n\n\n\n\nFigure 13.14: Histogram in ‘colorful dimension’\n\n\n\nTo create color_dim, we take the histogram shown on the left here, and convert it into just the colored representation shown at the bottom. Then we flip it on its side, as shown on the right. We found that the distribution is clearer if we take the log of the histogram values. Then, Stefano describes:\n\nThe final plot for each layer is made by stacking the histogram of the activations from each batch along the horizontal axis. So each vertical slice in the visualisation represents the histogram of activations for a single batch. The color intensity corresponds to the height of the histogram, in other words the number of activations in each histogram bin.\n\nFigure 13.15 shows how this all fits together.\n\n\n\n\n\n\nFigure 13.15: Summary of the colorful dimension (courtesy of Stefano Giomo)\n\n\n\nThis illustrates why log(f) is more colorful than f when f follows a normal distribution because taking a log changes the Gaussian in a quadratic, which isn’t as narrow.\nSo with that in mind, let’s take another look at the result for the penultimate layer:\n\nlearn.activation_stats.color_dim(-2)\n\n\n\n\n\n\n\n\nThis shows a classic picture of “bad training.” We start with nearly all activations at zero—that’s what we see at the far left, with all the dark blue. The bright yellow at the bottom represents the near-zero activations. Then, over the first few batches we see the number of nonzero activations exponentially increasing. But it goes too far, and collapses! We see the dark blue return, and the bottom becomes bright yellow again. It almost looks like training restarts from scratch. Then we see the activations increase again, and collapse again. After repeating this a few times, eventually we see a spread of activations throughout the range.\nIt’s much better if training can be smooth from the start. The cycles of exponential increase and then collapse tend to result in a lot of near-zero activations, resulting in slow training and poor final results. One way to solve this problem is to use batch normalization.\n\n\nBatch Normalization\nTo fix the slow training and poor final results we ended up with in the previous section, we need to fix the initial large percentage of near-zero activations, and then try to maintain a good distribution of activations throughout training.\nSergey Ioffe and Christian Szegedy presented a solution to this problem in the 2015 paper “Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift”. In the abstract, they describe just the problem that we’ve seen:\n\nTraining Deep Neural Networks is complicated by the fact that the distribution of each layer’s inputs changes during training, as the parameters of the previous layers change. This slows down the training by requiring lower learning rates and careful parameter initialization… We refer to this phenomenon as internal covariate shift, and address the problem by normalizing layer inputs.\n\nTheir solution, they say is:\n\nMaking normalization a part of the model architecture and performing the normalization for each training mini-batch. Batch Normalization allows us to use much higher learning rates and be less careful about initialization.\n\nThe paper caused great excitement as soon as it was released, because it included the chart in Figure 13.16, which clearly demonstrated that batch normalization could train a model that was even more accurate than the current state of the art (the Inception architecture) and around 5x faster.\n\n\n\n\n\n\nFigure 13.16: Impact of batch normalization (courtesy of Sergey Ioffe and Christian Szegedy)\n\n\n\nBatch normalization (often just called batchnorm) works by taking an average of the mean and standard deviations of the activations of a layer and using those to normalize the activations. However, this can cause problems because the network might want some activations to be really high in order to make accurate predictions. So they also added two learnable parameters (meaning they will be updated in the SGD step), usually called gamma and beta. After normalizing the activations to get some new activation vector y, a batchnorm layer returns gamma*y + beta.\nThat’s why our activations can have any mean or variance, independent from the mean and standard deviation of the results of the previous layer. Those statistics are learned separately, making training easier on our model. The behavior is different during training and validation: during training, we use the mean and standard deviation of the batch to normalize the data, while during validation we instead use a running mean of the statistics calculated during training.\nLet’s add a batchnorm layer to conv:\n\ndef conv(ni, nf, ks=3, act=True):\n    layers = [nn.Conv2d(ni, nf, stride=2, kernel_size=ks, padding=ks//2)]\n    if act: layers.append(nn.ReLU())\n    layers.append(nn.BatchNorm2d(nf))\n    return nn.Sequential(*layers)\n\nand fit our model:\n\nlearn = fit()\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.130036\n0.055021\n0.986400\n00:10\n\n\n\n\n\nThat’s a great result! Let’s take a look at color_dim:\n\nlearn.activation_stats.color_dim(-4)\n\n\n\n\n\n\n\n\nThis is just what we hope to see: a smooth development of activations, with no “crashes.” Batchnorm has really delivered on its promise here! In fact, batchnorm has been so successful that we see it (or something very similar) in nearly all modern neural networks.\nAn interesting observation about models containing batch normalization layers is that they tend to generalize better than models that don’t contain them. Although we haven’t as yet seen a rigorous analysis of what’s going on here, most researchers believe that the reason for this is that batch normalization adds some extra randomness to the training process. Each mini-batch will have a somewhat different mean and standard deviation than other mini-batches. Therefore, the activations will be normalized by different values each time. In order for the model to make accurate predictions, it will have to learn to become robust to these variations. In general, adding additional randomization to the training process often helps.\nSince things are going so well, let’s train for a few more epochs and see how it goes. In fact, let’s increase the learning rate, since the abstract of the batchnorm paper claimed we should be able to “train at much higher learning rates”:\n\nlearn = fit(5, lr=0.1)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n0.191731\n0.121738\n0.960900\n00:11\n\n\n1\n0.083739\n0.055808\n0.981800\n00:10\n\n\n2\n0.053161\n0.044485\n0.987100\n00:10\n\n\n3\n0.034433\n0.030233\n0.990200\n00:10\n\n\n4\n0.017646\n0.025407\n0.991200\n00:10\n\n\n\n\n\nAt this point, I think it’s fair to say we know how to recognize digits! It’s time to move on to something harder…",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Convolutional Neural Networks</span>"
    ]
  },
  {
    "objectID": "convolutions.html#conclusions",
    "href": "convolutions.html#conclusions",
    "title": "13  Convolutional Neural Networks",
    "section": "13.5 Conclusions",
    "text": "13.5 Conclusions\nWe’ve seen that convolutions are just a type of matrix multiplication, with two constraints on the weight matrix: some elements are always zero, and some elements are tied (forced to always have the same value). In Chapter 1 we saw the eight requirements from the 1986 book Parallel Distributed Processing; one of them was “A pattern of connectivity among units.” That’s exactly what these constraints do: they enforce a certain pattern of connectivity.\nThese constraints allow us to use far fewer parameters in our model, without sacrificing the ability to represent complex visual features. That means we can train deeper models faster, with less overfitting. Although the universal approximation theorem shows that it should be possible to represent anything in a fully connected network in one hidden layer, we’ve seen now that in practice we can train much better models by being thoughtful about network architecture.\nConvolutions are by far the most common pattern of connectivity we see in neural nets (along with regular linear layers, which we refer to as fully connected), but it’s likely that many more will be discovered.\nWe’ve also seen how to interpret the activations of layers in the network to see whether training is going well or not, and how batchnorm helps regularize the training and makes it smoother. In the next chapter, we will use both of those layers to build the most popular architecture in computer vision: a residual network.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Convolutional Neural Networks</span>"
    ]
  },
  {
    "objectID": "convolutions.html#questionnaire",
    "href": "convolutions.html#questionnaire",
    "title": "13  Convolutional Neural Networks",
    "section": "13.6 Questionnaire",
    "text": "13.6 Questionnaire\n\nWhat is a “feature”?\nWrite out the convolutional kernel matrix for a top edge detector.\nWrite out the mathematical operation applied by a 3×3 kernel to a single pixel in an image.\nWhat is the value of a convolutional kernel apply to a 3×3 matrix of zeros?\nWhat is “padding”?\nWhat is “stride”?\nCreate a nested list comprehension to complete any task that you choose.\nWhat are the shapes of the input and weight parameters to PyTorch’s 2D convolution?\nWhat is a “channel”?\nWhat is the relationship between a convolution and a matrix multiplication?\nWhat is a “convolutional neural network”?\nWhat is the benefit of refactoring parts of your neural network definition?\nWhat is Flatten? Where does it need to be included in the MNIST CNN? Why?\nWhat does “NCHW” mean?\nWhy does the third layer of the MNIST CNN have 7*7*(1168-16) multiplications?\nWhat is a “receptive field”?\nWhat is the size of the receptive field of an activation after two stride 2 convolutions? Why?\nRun conv-example.xlsx yourself and experiment with trace precedents.\nHave a look at Jeremy or Sylvain’s list of recent Twitter “like”s, and see if you find any interesting resources or ideas there.\nHow is a color image represented as a tensor?\nHow does a convolution work with a color input?\nWhat method can we use to see that data in DataLoaders?\nWhy do we double the number of filters after each stride-2 conv?\nWhy do we use a larger kernel in the first conv with MNIST (with simple_cnn)?\nWhat information does ActivationStats save for each layer?\nHow can we access a learner’s callback after training?\nWhat are the three statistics plotted by plot_layer_stats? What does the x-axis represent?\nWhy are activations near zero problematic?\nWhat are the upsides and downsides of training with a larger batch size?\nWhy should we avoid using a high learning rate at the start of training?\nWhat is 1cycle training?\nWhat are the benefits of training with a high learning rate?\nWhy do we want to use a low learning rate at the end of training?\nWhat is “cyclical momentum”?\nWhat callback tracks hyperparameter values during training (along with other information)?\nWhat does one column of pixels in the color_dim plot represent?\nWhat does “bad training” look like in color_dim? Why?\nWhat trainable parameters does a batch normalization layer contain?\nWhat statistics are used to normalize in batch normalization during training? How about during validation?\nWhy do models with batch normalization layers generalize better?\n\n\nFurther Research\n\nWhat features other than edge detectors have been used in computer vision (especially before deep learning became popular)?\nThere are other normalization layers available in PyTorch. Try them out and see what works best. Learn about why other normalization layers have been developed, and how they differ from batch normalization.\nTry moving the activation function after the batch normalization layer in conv. Does it make a difference? See what you can find out about what order is recommended, and why.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Convolutional Neural Networks</span>"
    ]
  },
  {
    "objectID": "resnet.html",
    "href": "resnet.html",
    "title": "14  ResNets",
    "section": "",
    "text": "14.1 Going Back to Imagenette\nIt’s going to be tough to judge any improvements we make to our models when we are already at an accuracy that is as high as we saw on MNIST in the previous chapter, so we will tackle a tougher image classification problem by going back to Imagenette. We’ll stick with small images to keep things reasonably fast.\nLet’s grab the data—we’ll use the already-resized 160 px version to make things faster still, and will random crop to 128 px:\ndef get_data(url, presize, resize):\n    path = untar_data(url)\n    return DataBlock(\n        blocks=(ImageBlock, CategoryBlock), get_items=get_image_files, \n        splitter=GrandparentSplitter(valid_name='val'),\n        get_y=parent_label, item_tfms=Resize(presize),\n        batch_tfms=[*aug_transforms(min_scale=0.5, size=resize),\n                    Normalize.from_stats(*imagenet_stats)],\n    ).dataloaders(path, bs=128)\ndls = get_data(URLs.IMAGENETTE_160, 160, 128)\ndls.show_batch(max_n=4)\nWhen we looked at MNIST we were dealing with 28×28-pixel images. For Imagenette we are going to be training with 128×128-pixel images. Later, we would like to be able to use larger images as well—at least as big as 224×224 pixels, the ImageNet standard. Do you recall how we managed to get a single vector of activations for each image out of the MNIST convolutional neural network?\nThe approach we used was to ensure that there were enough stride-2 convolutions such that the final layer would have a grid size of 1. Then we just flattened out the unit axes that we ended up with, to get a vector for each image (so, a matrix of activations for a mini-batch). We could do the same thing for Imagenette, but that would cause two problems:\nOne approach to dealing with the first of these issues would be to flatten the final convolutional layer in a way that handles a grid size other than 1×1. That is, we could simply flatten a matrix into a vector as we have done before, by laying out each row after the previous row. In fact, this is the approach that convolutional neural networks up until 2013 nearly always took. The most famous example is the 2013 ImageNet winner VGG, still sometimes used today. But there was another problem with this architecture: not only did it not work with images other than those of the same size used in the training set, but it required a lot of memory, because flattening out the convolutional layer resulted in many activations being fed into the final layers. Therefore, the weight matrices of the final layers were enormous.\nThis problem was solved through the creation of fully convolutional networks. The trick in fully convolutional networks is to take the average of activations across a convolutional grid. In other words, we can simply use this function:\ndef avg_pool(x): return x.mean((2,3))\nAs you see, it is taking the mean over the x- and y-axes. This function will always convert a grid of activations into a single activation per image. PyTorch provides a slightly more versatile module called nn.AdaptiveAvgPool2d, which averages a grid of activations into whatever sized destination you require (although we nearly always use a size of 1).\nA fully convolutional network, therefore, has a number of convolutional layers, some of which will be stride 2, at the end of which is an adaptive average pooling layer, a flatten layer to remove the unit axes, and finally a linear layer. Here is our first fully convolutional network:\ndef block(ni, nf): return ConvLayer(ni, nf, stride=2)\ndef get_model():\n    return nn.Sequential(\n        block(3, 16),\n        block(16, 32),\n        block(32, 64),\n        block(64, 128),\n        block(128, 256),\n        nn.AdaptiveAvgPool2d(1),\n        Flatten(),\n        nn.Linear(256, dls.c))\nWe’re going to be replacing the implementation of block in the network with other variants in a moment, which is why we’re not calling it conv any more. We’re also saving some time by taking advantage of fastai’s ConvLayer, which that already provides the functionality of conv from the last chapter (plus a lot more!).\nOnce we are done with our convolutional layers, we will get activations of size bs x ch x h x w (batch size, a certain number of channels, height, and width). We want to convert this to a tensor of size bs x ch, so we take the average over the last two dimensions and flatten the trailing 1×1 dimension like we did in our previous model.\nThis is different from regular pooling in the sense that those layers will generally take the average (for average pooling) or the maximum (for max pooling) of a window of a given size. For instance, max pooling layers of size 2, which were very popular in older CNNs, reduce the size of our image by half on each dimension by taking the maximum of each 2×2 window (with a stride of 2).\nAs before, we can define a Learner with our custom model and then train it on the data we grabbed earlier:\ndef get_learner(m):\n    return Learner(dls, m, loss_func=nn.CrossEntropyLoss(), metrics=accuracy\n                  ).to_fp16()\n\nlearn = get_learner(get_model())\nlearn.lr_find()\n3e-3 is often a good learning rate for CNNs, and that appears to be the case here too, so let’s try that:\nlearn.fit_one_cycle(5, 3e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.901582\n2.155090\n0.325350\n00:07\n\n\n1\n1.559855\n1.586795\n0.507771\n00:07\n\n\n2\n1.296350\n1.295499\n0.571720\n00:07\n\n\n3\n1.144139\n1.139257\n0.639236\n00:07\n\n\n4\n1.049770\n1.092619\n0.659108\n00:07\nThat’s a pretty good start, considering we have to pick the correct one of 10 categories, and we’re training from scratch for just 5 epochs! We can do way better than this using a deeper mode, but just stacking new layers won’t really improve our results (you can try and see for yourself!). To work around this problem, ResNets introduce the idea of skip connections. We’ll explore those and other aspects of ResNets in the next section.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ResNets</span>"
    ]
  },
  {
    "objectID": "resnet.html#going-back-to-imagenette",
    "href": "resnet.html#going-back-to-imagenette",
    "title": "14  ResNets",
    "section": "",
    "text": "We’d need lots of stride-2 layers to make our grid 1×1 at the end—perhaps more than we would otherwise choose.\nThe model would not work on images of any size other than the size we originally trained on.\n\n\n\n\n\n\n\n\n\nstop: Consider this question: would this approach makes sense for an optical character recognition (OCR) problem such as MNIST? The vast majority of practitioners tackling OCR and similar problems tend to use fully convolutional networks, because that’s what nearly everybody learns nowadays. But it really doesn’t make any sense! You can’t decide, for instance, whether a number is a 3 or an 8 by slicing it into small pieces, jumbling them up, and deciding whether on average each piece looks like a 3 or an 8. But that’s what adaptive average pooling effectively does! Fully convolutional networks are only really a good choice for objects that don’t have a single correct orientation or size (e.g., like most natural photos).",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ResNets</span>"
    ]
  },
  {
    "objectID": "resnet.html#building-a-modern-cnn-resnet",
    "href": "resnet.html#building-a-modern-cnn-resnet",
    "title": "14  ResNets",
    "section": "14.2 Building a Modern CNN: ResNet",
    "text": "14.2 Building a Modern CNN: ResNet\nWe now have all the pieces we need to build the models we have been using in our computer vision tasks since the beginning of this book: ResNets. We’ll introduce the main idea behind them and show how it improves accuracy on Imagenette compared to our previous model, before building a version with all the recent tweaks.\n\nSkip Connections\nIn 2015, the authors of the ResNet paper noticed something that they found curious. Even after using batchnorm, they saw that a network using more layers was doing less well than a network using fewer layers—and there were no other differences between the models. Most interestingly, the difference was observed not only in the validation set, but also in the training set; so, it wasn’t just a generalization issue, but a training issue. As the paper explains:\n\nUnexpectedly, such degradation is not caused by overfitting, and adding more layers to a suitably deep model leads to higher training error, as [previously reported] and thoroughly verified by our experiments.\n\nThis phenomenon was illustrated by the graph in Figure 14.1, with training error on the left and test error on the right.\n\n\n\n\n\n\nFigure 14.1: Training of networks of different depth (courtesy of Kaiming He et al.)\n\n\n\nAs the authors mention here, they are not the first people to have noticed this curious fact. But they were the first to make a very important leap:\n\nLet us consider a shallower architecture and its deeper counterpart that adds more layers onto it. There exists a solution by construction to the deeper model: the added layers are identity mapping, and the other layers are copied from the learned shallower model.\n\nAs this is an academic paper this process is described in a rather inaccessible way, but the concept is actually very simple: start with a 20-layer neural network that is trained well, and add another 36 layers that do nothing at all (for instance, they could be linear layers with a single weight equal to 1, and bias equal to 0). The result will be a 56-layer network that does exactly the same thing as the 20-layer network, proving that there are always deep networks that should be at least as good as any shallow network. But for some reason, SGD does not seem able to find them.\n\njargon: Identity mapping: Returning the input without changing it at all. This process is performed by an identity function.\n\nActually, there is another way to create those extra 36 layers, which is much more interesting. What if we replaced every occurrence of conv(x) with x + conv(x), where conv is the function from the previous chapter that adds a second convolution, then a batchnorm layer, then a ReLU. Furthermore, recall that batchnorm does gamma*y + beta. What if we initialized gamma to zero for every one of those final batchnorm layers? Then our conv(x) for those extra 36 layers will always be equal to zero, which means x+conv(x) will always be equal to x.\nWhat has that gained us? The key thing is that those 36 extra layers, as they stand, are an identity mapping, but they have parameters, which means they are trainable. So, we can start with our best 20-layer model, add these 36 extra layers which initially do nothing at all, and then fine-tune the whole 56-layer model. Those extra 36 layers can then learn the parameters that make them most useful.\nThe ResNet paper actually proposed a variant of this, which is to instead “skip over” every second convolution, so effectively we get x+conv2(conv1(x)). This is shown by the diagram in Figure 14.2 (from the paper).\n\n\n\n\n\n\nFigure 14.2: A simple ResNet block (courtesy of Kaiming He et al.)\n\n\n\nThat arrow on the right is just the x part of x+conv2(conv1(x)), and is known as the identity branch or skip connection. The path on the left is the conv2(conv1(x)) part. You can think of the identity path as providing a direct route from the input to the output.\nIn a ResNet, we don’t actually proceed by first training a smaller number of layers, and then adding new layers on the end and fine-tuning. Instead, we use ResNet blocks like the one in Figure 14.2 throughout the CNN, initialized from scratch in the usual way, and trained with SGD in the usual way. We rely on the skip connections to make the network easier to train with SGD.\nThere’s another (largely equivalent) way to think of these ResNet blocks. This is how the paper describes it:\n\nInstead of hoping each few stacked layers directly fit a desired underlying mapping, we explicitly let these layers fit a residual mapping. Formally, denoting the desired underlying mapping as H(x), we let the stacked nonlinear layers fit another mapping of F(x) := H(x)−x. The original mapping is recast into F(x)+x. We hypothesize that it is easier to optimize the residual mapping than to optimize the original, unreferenced mapping. To the extreme, if an identity mapping were optimal, it would be easier to push the residual to zero than to fit an identity mapping by a stack of nonlinear layers.\n\nAgain, this is rather inaccessible prose—so let’s try to restate it in plain English! If the outcome of a given layer is x, when using a ResNet block that returns y = x+block(x) we’re not asking the block to predict y, we are asking it to predict the difference between y and x. So the job of those blocks isn’t to predict certain features, but to minimize the error between x and the desired y. A ResNet is, therefore, good at learning about slight differences between doing nothing and passing though a block of two convolutional layers (with trainable weights). This is how these models got their name: they’re predicting residuals (reminder: “residual” is prediction minus target).\nOne key concept that both of these two ways of thinking about ResNets share is the idea of ease of learning. This is an important theme. Recall the universal approximation theorem, which states that a sufficiently large network can learn anything. This is still true, but there turns out to be a very important difference between what a network can learn in principle, and what it is easy for it to learn with realistic data and training regimes. Many of the advances in neural networks over the last decade have been like the ResNet block: the result of realizing how to make something that was always possible actually feasible.\n\nnote: True Identity Path: The original paper didn’t actually do the trick of using zero for the initial value of gamma in the last batchnorm layer of each block; that came a couple of years later. So, the original version of ResNet didn’t quite begin training with a truly identity path through the ResNet blocks, but nonetheless having the ability to “navigate through” the skip connections did indeed make it train better. Adding the batchnorm gamma init trick made the models train at even higher learning rates.\n\nHere’s the definition of a simple ResNet block (where norm_type=NormType.BatchZero causes fastai to init the gamma weights of the last batchnorm layer to zero):\n\nclass ResBlock(Module):\n    def __init__(self, ni, nf):\n        self.convs = nn.Sequential(\n            ConvLayer(ni,nf),\n            ConvLayer(nf,nf, norm_type=NormType.BatchZero))\n        \n    def forward(self, x): return x + self.convs(x)\n\nThere are two problems with this, however: it can’t handle a stride other than 1, and it requires that ni==nf. Stop for a moment to think carefully about why this is.\nThe issue is that with a stride of, say, 2 on one of the convolutions, the grid size of the output activations will be half the size on each axis of the input. So then we can’t add that back to x in forward because x and the output activations have different dimensions. The same basic issue occurs if ni!=nf: the shapes of the input and output connections won’t allow us to add them together.\nTo fix this, we need a way to change the shape of x to match the result of self.convs. Halving the grid size can be done using an average pooling layer with a stride of 2: that is, a layer that takes 2×2 patches from the input and replaces them with their average.\nChanging the number of channels can be done by using a convolution. We want this skip connection to be as close to an identity map as possible, however, which means making this convolution as simple as possible. The simplest possible convolution is one where the kernel size is 1. That means that the kernel is size ni*nf*1*1, so it’s only doing a dot product over the channels of each input pixel—it’s not combining across pixels at all. This kind of 1x1 convolution is very widely used in modern CNNs, so take a moment to think about how it works.\n\njargon: 1x1 convolution: A convolution with a kernel size of 1.\n\nHere’s a ResBlock using these tricks to handle changing shape in the skip connection:\n\ndef _conv_block(ni,nf,stride):\n    return nn.Sequential(\n        ConvLayer(ni, nf, stride=stride),\n        ConvLayer(nf, nf, act_cls=None, norm_type=NormType.BatchZero))\n\n\nclass ResBlock(Module):\n    def __init__(self, ni, nf, stride=1):\n        self.convs = _conv_block(ni,nf,stride)\n        self.idconv = noop if ni==nf else ConvLayer(ni, nf, 1, act_cls=None)\n        self.pool = noop if stride==1 else nn.AvgPool2d(2, ceil_mode=True)\n\n    def forward(self, x):\n        return F.relu(self.convs(x) + self.idconv(self.pool(x)))\n\nNote that we’re using the noop function here, which simply returns its input unchanged (noop is a computer science term that stands for “no operation”). In this case, idconv does nothing at all if ni==nf, and pool does nothing if stride==1, which is what we wanted in our skip connection.\nAlso, you’ll see that we’ve removed the ReLU (act_cls=None) from the final convolution in convs and from idconv, and moved it to after we add the skip connection. The thinking behind this is that the whole ResNet block is like a layer, and you want your activation to be after your layer.\nLet’s replace our block with ResBlock, and try it out:\n\ndef block(ni,nf): return ResBlock(ni, nf, stride=2)\nlearn = get_learner(get_model())\n\n\nlearn.fit_one_cycle(5, 3e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.973174\n1.845491\n0.373248\n00:08\n\n\n1\n1.678627\n1.778713\n0.439236\n00:08\n\n\n2\n1.386163\n1.596503\n0.507261\n00:08\n\n\n3\n1.177839\n1.102993\n0.644841\n00:09\n\n\n4\n1.052435\n1.038013\n0.667771\n00:09\n\n\n\n\n\nIt’s not much better. But the whole point of this was to allow us to train deeper models, and we’re not really taking advantage of that yet. To create a model that’s, say, twice as deep, all we need to do is replace our block with two ResBlocks in a row:\n\ndef block(ni, nf):\n    return nn.Sequential(ResBlock(ni, nf, stride=2), ResBlock(nf, nf))\n\n\nlearn = get_learner(get_model())\nlearn.fit_one_cycle(5, 3e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.964076\n1.864578\n0.355159\n00:12\n\n\n1\n1.636880\n1.596789\n0.502675\n00:12\n\n\n2\n1.335378\n1.304472\n0.588535\n00:12\n\n\n3\n1.089160\n1.065063\n0.663185\n00:12\n\n\n4\n0.942904\n0.963589\n0.692739\n00:12\n\n\n\n\n\nNow we’re making good progress!\nThe authors of the ResNet paper went on to win the 2015 ImageNet challenge. At the time, this was by far the most important annual event in computer vision. We have already seen another ImageNet winner: the 2013 winners, Zeiler and Fergus. It is interesting to note that in both cases the starting points for the breakthroughs were experimental observations: observations about what layers actually learn, in the case of Zeiler and Fergus, and observations about which kinds of networks can be trained, in the case of the ResNet authors. This ability to design and analyze thoughtful experiments, or even just to see an unexpected result, say “Hmmm, that’s interesting,” and then, most importantly, set about figuring out what on earth is going on, with great tenacity, is at the heart of many scientific discoveries. Deep learning is not like pure mathematics. It is a heavily experimental field, so it’s important to be a strong practitioner, not just a theoretician.\nSince the ResNet was introduced, it’s been widely studied and applied to many domains. One of the most interesting papers, published in 2018, is Hao Li et al.’s “Visualizing the Loss Landscape of Neural Nets”. It shows that using skip connections helps smooth the loss function, which makes training easier as it avoids falling into a very sharp area. Figure 14.3 shows a stunning picture from the paper, illustrating the difference between the bumpy terrain that SGD has to navigate to optimize a regular CNN (left) versus the smooth surface of a ResNet (right).\n\n\n\n\n\n\nFigure 14.3: Impact of ResNet on loss landscape (courtesy of Hao Li et al.)\n\n\n\nOur first model is already good, but further research has discovered more tricks we can apply to make it better. We’ll look at those next.\n\n\nA State-of-the-Art ResNet\nIn “Bag of Tricks for Image Classification with Convolutional Neural Networks”, Tong He et al. study different variations of the ResNet architecture that come at almost no additional cost in terms of number of parameters or computation. By using a tweaked ResNet-50 architecture and Mixup they achieved 94.6% top-5 accuracy on ImageNet, in comparison to 92.2% with a regular ResNet-50 without Mixup. This result is better than that achieved by regular ResNet models that are twice as deep (and twice as slow, and much more likely to overfit).\n\njargon: top-5 accuracy: A metric testing how often the label we want is in the top 5 predictions of our model. It was used in the ImageNet competition because many of the images contained multiple objects, or contained objects that could be easily confused or may even have been mislabeled with a similar label. In these situations, looking at top-1 accuracy may be inappropriate. However, recently CNNs have been getting so good that top-5 accuracy is nearly 100%, so some researchers are using top-1 accuracy for ImageNet too now.\n\nWe’ll use this tweaked version as we scale up to the full ResNet, because it’s substantially better. It differs a little bit from our previous implementation, in that instead of just starting with ResNet blocks, it begins with a few convolutional layers followed by a max pooling layer. This is what the first layers, called the stem of the network, look like:\n\ndef _resnet_stem(*sizes):\n    return [\n        ConvLayer(sizes[i], sizes[i+1], 3, stride = 2 if i==0 else 1)\n            for i in range(len(sizes)-1)\n    ] + [nn.MaxPool2d(kernel_size=3, stride=2, padding=1)]\n\n\n_resnet_stem(3,32,32,64)\n\n[ConvLayer(\n   (0): Conv2d(3, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n   (1): BatchNorm2d(32, eps=1e-05, momentum=0.1)\n   (2): ReLU()\n ), ConvLayer(\n   (0): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n   (1): BatchNorm2d(32, eps=1e-05, momentum=0.1)\n   (2): ReLU()\n ), ConvLayer(\n   (0): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n   (1): BatchNorm2d(64, eps=1e-05, momentum=0.1)\n   (2): ReLU()\n ), MaxPool2d(kernel_size=3, stride=2, padding=1, ceil_mode=False)]\n\njargon: Stem: The first few layers of a CNN. Generally, the stem has a different structure than the main body of the CNN.\n\nThe reason that we have a stem of plain convolutional layers, instead of ResNet blocks, is based on a very important insight about all deep convolutional neural networks: the vast majority of the computation occurs in the early layers. Therefore, we should keep the early layers as fast and simple as possible.\nTo see why so much computation occurs in the early layers, consider the very first convolution on a 128-pixel input image. If it is a stride-1 convolution, then it will apply the kernel to every one of the 128×128 pixels. That’s a lot of work! In the later layers, however, the grid size could be as small as 4×4 or even 2×2, so there are far fewer kernel applications to do.\nOn the other hand, the first-layer convolution only has 3 input features and 32 output features. Since it is a 3×3 kernel, this is 3×32×3×3 = 864 parameters in the weights. But the last convolution will have 256 input features and 512 output features, resulting in 1,179,648 weights! So the first layers contain the vast majority of the computation, but the last layers contain the vast majority of the parameters.\nA ResNet block takes more computation than a plain convolutional block, since (in the stride-2 case) a ResNet block has three convolutions and a pooling layer. That’s why we want to have plain convolutions to start off our ResNet.\nWe’re now ready to show the implementation of a modern ResNet, with the “bag of tricks.” It uses four groups of ResNet blocks, with 64, 128, 256, then 512 filters. Each group starts with a stride-2 block, except for the first one, since it’s just after a MaxPooling layer:\n\nclass ResNet(nn.Sequential):\n    def __init__(self, n_out, layers, expansion=1):\n        stem = _resnet_stem(3,32,32,64)\n        self.block_szs = [64, 64, 128, 256, 512]\n        for i in range(1,5): self.block_szs[i] *= expansion\n        blocks = [self._make_layer(*o) for o in enumerate(layers)]\n        super().__init__(*stem, *blocks,\n                         nn.AdaptiveAvgPool2d(1), Flatten(),\n                         nn.Linear(self.block_szs[-1], n_out))\n    \n    def _make_layer(self, idx, n_layers):\n        stride = 1 if idx==0 else 2\n        ch_in,ch_out = self.block_szs[idx:idx+2]\n        return nn.Sequential(*[\n            ResBlock(ch_in if i==0 else ch_out, ch_out, stride if i==0 else 1)\n            for i in range(n_layers)\n        ])\n\nThe _make_layer function is just there to create a series of n_layers blocks. The first one is going from ch_in to ch_out with the indicated stride and all the others are blocks of stride 1 with ch_out to ch_out tensors. Once the blocks are defined, our model is purely sequential, which is why we define it as a subclass of nn.Sequential. (Ignore the expansion parameter for now; we’ll discuss it in the next section. For now, it’ll be 1, so it doesn’t do anything.)\nThe various versions of the models (ResNet-18, -34, -50, etc.) just change the number of blocks in each of those groups. This is the definition of a ResNet-18:\n\nrn = ResNet(dls.c, [2,2,2,2])\n\nLet’s train it for a little bit and see how it fares compared to the previous model:\n\nlearn = get_learner(rn)\nlearn.fit_one_cycle(5, 3e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.673882\n1.828394\n0.413758\n00:13\n\n\n1\n1.331675\n1.572685\n0.518217\n00:13\n\n\n2\n1.087224\n1.086102\n0.650701\n00:13\n\n\n3\n0.900428\n0.968219\n0.684331\n00:12\n\n\n4\n0.760280\n0.782558\n0.757197\n00:12\n\n\n\n\n\nEven though we have more channels (and our model is therefore even more accurate), our training is just as fast as before, thanks to our optimized stem.\nTo make our model deeper without taking too much compute or memory, we can use another kind of layer introduced by the ResNet paper for ResNets with a depth of 50 or more: the bottleneck layer.\n\n\nBottleneck Layers\nInstead of stacking two convolutions with a kernel size of 3, bottleneck layers use three different convolutions: two 1×1 (at the beginning and the end) and one 3×3, as shown on the right in Figure 14.4.\n\n\n\n\n\n\nFigure 14.4: Comparison of regular and bottleneck ResNet blocks (courtesy of Kaiming He et al.)\n\n\n\nWhy is that useful? 1×1 convolutions are much faster, so even if this seems to be a more complex design, this block executes faster than the first ResNet block we saw. This then lets us use more filters: as we see in the illustration, the number of filters in and out is 4 times higher (256 instead of 64) diminish then restore the number of channels (hence the name bottleneck). The overall impact is that we can use more filters in the same amount of time.\nLet’s try replacing our ResBlock with this bottleneck design:\n\ndef _conv_block(ni,nf,stride):\n    return nn.Sequential(\n        ConvLayer(ni, nf//4, 1),\n        ConvLayer(nf//4, nf//4, stride=stride), \n        ConvLayer(nf//4, nf, 1, act_cls=None, norm_type=NormType.BatchZero))\n\nWe’ll use this to create a ResNet-50 with group sizes of (3,4,6,3). We now need to pass 4 in to the expansion parameter of ResNet, since we need to start with four times less channels and we’ll end with four times more channels.\nDeeper networks like this don’t generally show improvements when training for only 5 epochs, so we’ll bump it up to 20 epochs this time to make the most of our bigger model. And to really get great results, let’s use bigger images too:\n\ndls = get_data(URLs.IMAGENETTE_320, presize=320, resize=224)\n\nWe don’t have to do anything to account for the larger 224-pixel images; thanks to our fully convolutional network, it just works. This is also why we were able to do progressive resizing earlier in the book—the models we used were fully convolutional, so we were even able to fine-tune models trained with different sizes. We can now train our model and see the effects:\n\nrn = ResNet(dls.c, [3,4,6,3], 4)\n\n\nlearn = get_learner(rn)\nlearn.fit_one_cycle(20, 3e-3)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n1.613448\n1.473355\n0.514140\n00:31\n\n\n1\n1.359604\n2.050794\n0.397452\n00:31\n\n\n2\n1.253112\n4.511735\n0.387006\n00:31\n\n\n3\n1.133450\n2.575221\n0.396178\n00:31\n\n\n4\n1.054752\n1.264525\n0.613758\n00:32\n\n\n5\n0.927930\n2.670484\n0.422675\n00:32\n\n\n6\n0.838268\n1.724588\n0.528662\n00:32\n\n\n7\n0.748289\n1.180668\n0.666497\n00:31\n\n\n8\n0.688637\n1.245039\n0.650446\n00:32\n\n\n9\n0.645530\n1.053691\n0.674904\n00:31\n\n\n10\n0.593401\n1.180786\n0.676433\n00:32\n\n\n11\n0.536634\n0.879937\n0.713885\n00:32\n\n\n12\n0.479208\n0.798356\n0.741656\n00:32\n\n\n13\n0.440071\n0.600644\n0.806879\n00:32\n\n\n14\n0.402952\n0.450296\n0.858599\n00:32\n\n\n15\n0.359117\n0.486126\n0.846369\n00:32\n\n\n16\n0.313642\n0.442215\n0.861911\n00:32\n\n\n17\n0.294050\n0.485967\n0.853503\n00:32\n\n\n18\n0.270583\n0.408566\n0.875924\n00:32\n\n\n19\n0.266003\n0.411752\n0.872611\n00:33\n\n\n\n\n\nWe’re getting a great result now! Try adding Mixup, and then training this for a hundred epochs while you go get lunch. You’ll have yourself a very accurate image classifier, trained from scratch.\nThe bottleneck design we’ve shown here is typically only used in ResNet-50, -101, and -152 models. ResNet-18 and -34 models usually use the non-bottleneck design seen in the previous section. However, we’ve noticed that the bottleneck layer generally works better even for the shallower networks. This just goes to show that the little details in papers tend to stick around for years, even if they’re actually not quite the best design! Questioning assumptions and “stuff everyone knows” is always a good idea, because this is still a new field, and there are lots of details that aren’t always done well.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ResNets</span>"
    ]
  },
  {
    "objectID": "resnet.html#conclusion",
    "href": "resnet.html#conclusion",
    "title": "14  ResNets",
    "section": "14.3 Conclusion",
    "text": "14.3 Conclusion\nYou have now seen how the models we have been using for computer vision since the first chapter are built, using skip connections to allow deeper models to be trained. Even if there has been a lot of research into better architectures, they all use one version or another of this trick, to make a direct path from the input to the end of the network. When using transfer learning, the ResNet is the pretrained model. In the next chapter, we will look at the final details of how the models we actually used were built from it.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ResNets</span>"
    ]
  },
  {
    "objectID": "resnet.html#questionnaire",
    "href": "resnet.html#questionnaire",
    "title": "14  ResNets",
    "section": "14.4 Questionnaire",
    "text": "14.4 Questionnaire\n\nHow did we get to a single vector of activations in the CNNs used for MNIST in previous chapters? Why isn’t that suitable for Imagenette?\nWhat do we do for Imagenette instead?\nWhat is “adaptive pooling”?\nWhat is “average pooling”?\nWhy do we need Flatten after an adaptive average pooling layer?\nWhat is a “skip connection”?\nWhy do skip connections allow us to train deeper models?\nWhat does Figure 14.1 show? How did that lead to the idea of skip connections?\nWhat is “identity mapping”?\nWhat is the basic equation for a ResNet block (ignoring batchnorm and ReLU layers)?\nWhat do ResNets have to do with residuals?\nHow do we deal with the skip connection when there is a stride-2 convolution? How about when the number of filters changes?\nHow can we express a 1×1 convolution in terms of a vector dot product?\nCreate a 1x1 convolution with F.conv2d or nn.Conv2d and apply it to an image. What happens to the shape of the image?\nWhat does the noop function return?\nExplain what is shown in Figure 14.3.\nWhen is top-5 accuracy a better metric than top-1 accuracy?\nWhat is the “stem” of a CNN?\nWhy do we use plain convolutions in the CNN stem, instead of ResNet blocks?\nHow does a bottleneck block differ from a plain ResNet block?\nWhy is a bottleneck block faster?\nHow do fully convolutional nets (and nets with adaptive pooling in general) allow for progressive resizing?\n\n\nFurther Research\n\nTry creating a fully convolutional net with adaptive average pooling for MNIST (note that you’ll need fewer stride-2 layers). How does it compare to a network without such a pooling layer?\nIn Chapter 17 we introduce Einstein summation notation. Skip ahead to see how this works, and then write an implementation of the 1×1 convolution operation using torch.einsum. Compare it to the same operation using torch.conv2d.\nWrite a “top-5 accuracy” function using plain PyTorch or plain Python.\nTrain a model on Imagenette for more epochs, with and without label smoothing. Take a look at the Imagenette leaderboards and see how close you can get to the best results shown. Read the linked pages describing the leading approaches.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>ResNets</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html",
    "href": "accel_sgd.html",
    "title": "16  The Training Process",
    "section": "",
    "text": "16.1 Establishing a Baseline\nFirst, we’ll create a baseline, using plain SGD, and compare it to fastai’s default optimizer. We’ll start by grabbing Imagenette with the same get_data we used in Chapter 14:\ndls = get_data(URLs.IMAGENETTE_160, 160, 128)\nWe’ll create a ResNet-34 without pretraining, and pass along any arguments received:\ndef get_learner(**kwargs):\n    return vision_learner(dls, resnet34, pretrained=False,\n                    metrics=accuracy, **kwargs).to_fp16()\nHere’s the default fastai optimizer, with the usual 3e-3 learning rate:\nlearn = get_learner()\nlearn.fit_one_cycle(3, 0.003)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n2.571932\n2.685040\n0.322548\n00:11\n\n\n1\n1.904674\n1.852589\n0.437452\n00:11\n\n\n2\n1.586909\n1.374908\n0.594904\n00:11\nNow let’s try plain SGD. We can pass opt_func (optimization function) to vision_learner to get fastai to use any optimizer:\nlearn = get_learner(opt_func=SGD)\nThe first thing to look at is lr_find:\nlearn.lr_find()\nIt looks like we’ll need to use a higher learning rate than we normally use:\nlearn.fit_one_cycle(3, 0.03, moms=(0,0,0))\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n2.969412\n2.214596\n0.242038\n00:09\n\n\n1\n2.442730\n1.845950\n0.362548\n00:09\n\n\n2\n2.157159\n1.741143\n0.408917\n00:09\nBecause accelerating SGD with momentum is such a good idea, fastai does this by default in fit_one_cycle, so we turn it off with moms=(0,0,0). We’ll be discussing momentum shortly.)\nClearly, plain SGD isn’t training as fast as we’d like. So let’s learn some tricks to get accelerated training!",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#a-generic-optimizer",
    "href": "accel_sgd.html#a-generic-optimizer",
    "title": "16  The Training Process",
    "section": "16.2 A Generic Optimizer",
    "text": "16.2 A Generic Optimizer\nTo build up our accelerated SGD tricks, we’ll need to start with a nice flexible optimizer foundation. No library prior to fastai provided such a foundation, but during fastai’s development we realized that all the optimizer improvements we’d seen in the academic literature could be handled using optimizer callbacks. These are small pieces of code that we can compose, mix and match in an optimizer to build the optimizer step. They are called by fastai’s lightweight Optimizer class. These are the definitions in Optimizer of the two key methods that we’ve been using in this book:\ndef zero_grad(self):\n    for p,*_ in self.all_params():\n        p.grad.detach_()\n        p.grad.zero_()\n\ndef step(self):\n    for p,pg,state,hyper in self.all_params():\n        for cb in self.cbs:\n            state = _update(state, cb(p, **{**state, **hyper}))\n        self.state[p] = state\nAs we saw when training an MNIST model from scratch, zero_grad just loops through the parameters of the model and sets the gradients to zero. It also calls detach_, which removes any history of gradient computation, since it won’t be needed after zero_grad.\nThe more interesting method is step, which loops through the callbacks (cbs) and calls them to update the parameters (the _update function just calls state.update if there’s anything returned by cb). As you can see, Optimizer doesn’t actually do any SGD steps itself. Let’s see how we can add SGD to Optimizer.\nHere’s an optimizer callback that does a single SGD step, by multiplying -lr by the gradients and adding that to the parameter (when Tensor.add_ in PyTorch is passed two parameters, they are multiplied together before the addition):\n\ndef sgd_cb(p, lr, **kwargs): p.data.add_(-lr, p.grad.data)\n\nWe can pass this to Optimizer using the cbs parameter; we’ll need to use partial since Learner will call this function to create our optimizer later:\n\nopt_func = partial(Optimizer, cbs=[sgd_cb])\n\nLet’s see if this trains:\n\nlearn = get_learner(opt_func=opt_func)\nlearn.fit(3, 0.03)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n2.730918\n2.009971\n0.332739\n00:09\n\n\n1\n2.204893\n1.747202\n0.441529\n00:09\n\n\n2\n1.875621\n1.684515\n0.445350\n00:09\n\n\n\n\n\nIt’s working! So that’s how we create SGD from scratch in fastai. Now let’s see what “momentum” is.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#momentum",
    "href": "accel_sgd.html#momentum",
    "title": "16  The Training Process",
    "section": "16.3 Momentum",
    "text": "16.3 Momentum\nAs described in Chapter 4, SGD can be thought of as standing at the top of a mountain and working your way down by taking a step in the direction of the steepest slope at each point in time. But what if we have a ball rolling down the mountain? It won’t, at each given point, exactly follow the direction of the gradient, as it will have momentum. A ball with more momentum (for instance, a heavier ball) will skip over little bumps and holes, and be more likely to get to the bottom of a bumpy mountain. A ping pong ball, on the other hand, will get stuck in every little crevice.\nSo how can we bring this idea over to SGD? We can use a moving average, instead of only the current gradient, to make our step:\nweight.avg = beta * weight.avg + (1-beta) * weight.grad\nnew_weight = weight - lr * weight.avg\nHere beta is some number we choose which defines how much momentum to use. If beta is 0, then the first equation becomes weight.avg = weight.grad, so we end up with plain SGD. But if it’s a number close to 1, then the main direction chosen is an average of the previous steps. (If you have done a bit of statistics, you may recognize in the first equation an exponentially weighted moving average, which is very often used to denoise data and get the underlying tendency.)\nNote that we are writing weight.avg to highlight the fact that we need to store the moving averages for each parameter of the model (they all have their own independent moving averages).\nFigure 16.1 shows an example of noisy data for a single parameter, with the momentum curve plotted in red, and the gradients of the parameter plotted in blue. The gradients increase, then decrease, and the momentum does a good job of following the general trend without getting too influenced by noise.\n\n\n\n\n\n\n\n\nFigure 16.1: An example of momentum\n\n\n\n\n\nIt works particularly well if the loss function has narrow canyons we need to navigate: vanilla SGD would send us bouncing from one side to the other, while SGD with momentum will average those to roll smoothly down the side. The parameter beta determines the strength of the momentum we are using: with a small beta we stay closer to the actual gradient values, whereas with a high beta we will mostly go in the direction of the average of the gradients and it will take a while before any change in the gradients makes that trend move.\nWith a large beta, we might miss that the gradients have changed directions and roll over a small local minima. This is a desired side effect: intuitively, when we show a new input to our model, it will look like something in the training set but won’t be exactly like it. That means it will correspond to a point in the loss function that is close to the minimum we ended up with at the end of training, but not exactly at that minimum. So, we would rather end up training in a wide minimum, where nearby points have approximately the same loss (or if you prefer, a point where the loss is as flat as possible). Figure 16.2 shows how the chart in Figure 16.1 varies as we change beta.\n\n\n\n\n\n\n\n\nFigure 16.2: Momentum with different beta values\n\n\n\n\n\nWe can see in these examples that a beta that’s too high results in the overall changes in gradient getting ignored. In SGD with momentum, a value of beta that is often used is 0.9.\nfit_one_cycle by default starts with a beta of 0.95, gradually adjusts it to 0.85, and then gradually moves it back to 0.95 at the end of training. Let’s see how our training goes with momentum added to plain SGD.\nIn order to add momentum to our optimizer, we’ll first need to keep track of the moving average gradient, which we can do with another callback. When an optimizer callback returns a dict, it is used to update the state of the optimizer and is passed back to the optimizer on the next step. So this callback will keep track of the gradient averages in a parameter called grad_avg:\n\ndef average_grad(p, mom, grad_avg=None, **kwargs):\n    if grad_avg is None: grad_avg = torch.zeros_like(p.grad.data)\n    return {'grad_avg': grad_avg*mom + p.grad.data}\n\nTo use it, we just have to replace p.grad.data with grad_avg in our step function:\n\ndef momentum_step(p, lr, grad_avg, **kwargs): p.data.add_(-lr, grad_avg)\n\n\nopt_func = partial(Optimizer, cbs=[average_grad,momentum_step], mom=0.9)\n\nLearner will automatically schedule mom and lr, so fit_one_cycle will even work with our custom Optimizer:\n\nlearn = get_learner(opt_func=opt_func)\nlearn.fit_one_cycle(3, 0.03)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n2.856000\n2.493429\n0.246115\n00:10\n\n\n1\n2.504205\n2.463813\n0.348280\n00:10\n\n\n2\n2.187387\n1.755670\n0.418853\n00:10\n\n\n\n\n\n\nlearn.recorder.plot_sched()\n\n\n\n\n\n\n\n\nWe’re still not getting great results, so let’s see what else we can do.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#rmsprop",
    "href": "accel_sgd.html#rmsprop",
    "title": "16  The Training Process",
    "section": "16.4 RMSProp",
    "text": "16.4 RMSProp\nRMSProp is another variant of SGD introduced by Geoffrey Hinton in Lecture 6e of his Coursera class “Neural Networks for Machine Learning”. The main difference from SGD is that it uses an adaptive learning rate: instead of using the same learning rate for every parameter, each parameter gets its own specific learning rate controlled by a global learning rate. That way we can speed up training by giving a higher learning rate to the weights that need to change a lot while the ones that are good enough get a lower learning rate.\nHow do we decide which parameters should have a high learning rate and which should not? We can look at the gradients to get an idea. If a parameter’s gradients have been close to zero for a while, that parameter will need a higher learning rate because the loss is flat. On the other hand, if the gradients are all over the place, we should probably be careful and pick a low learning rate to avoid divergence. We can’t just average the gradients to see if they’re changing a lot, because the average of a large positive and a large negative number is close to zero. Instead, we can use the usual trick of either taking the absolute value or the squared values (and then taking the square root after the mean).\nOnce again, to determine the general tendency behind the noise, we will use a moving average—specifically the moving average of the gradients squared. Then we will update the corresponding weight by using the current gradient (for the direction) divided by the square root of this moving average (that way if it’s low, the effective learning rate will be higher, and if it’s high, the effective learning rate will be lower):\nw.square_avg = alpha * w.square_avg + (1-alpha) * (w.grad ** 2)\nnew_w = w - lr * w.grad / math.sqrt(w.square_avg + eps)\nThe eps (epsilon) is added for numerical stability (usually set at 1e-8), and the default value for alpha is usually 0.99.\nWe can add this to Optimizer by doing much the same thing we did for avg_grad, but with an extra **2:\n\ndef average_sqr_grad(p, sqr_mom, sqr_avg=None, **kwargs):\n    if sqr_avg is None: sqr_avg = torch.zeros_like(p.grad.data)\n    return {'sqr_avg': sqr_mom*sqr_avg + (1-sqr_mom)*p.grad.data**2}\n\nAnd we can define our step function and optimizer as before:\n\ndef rms_prop_step(p, lr, sqr_avg, eps, grad_avg=None, **kwargs):\n    denom = sqr_avg.sqrt().add_(eps)\n    p.data.addcdiv_(-lr, p.grad, denom)\n\nopt_func = partial(Optimizer, cbs=[average_sqr_grad,rms_prop_step],\n                   sqr_mom=0.99, eps=1e-7)\n\nLet’s try it out:\n\nlearn = get_learner(opt_func=opt_func)\nlearn.fit_one_cycle(3, 0.003)\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\naccuracy\ntime\n\n\n\n\n0\n2.766912\n1.845900\n0.402548\n00:11\n\n\n1\n2.194586\n1.510269\n0.504459\n00:11\n\n\n2\n1.869099\n1.447939\n0.544968\n00:11\n\n\n\n\n\nMuch better! Now we just have to bring these ideas together, and we have Adam, fastai’s default optimizer.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#adam",
    "href": "accel_sgd.html#adam",
    "title": "16  The Training Process",
    "section": "16.5 Adam",
    "text": "16.5 Adam\nAdam mixes the ideas of SGD with momentum and RMSProp together: it uses the moving average of the gradients as a direction and divides by the square root of the moving average of the gradients squared to give an adaptive learning rate to each parameter.\nThere is one other difference in how Adam calculates moving averages. It takes the unbiased moving average, which is:\nw.avg = beta * w.avg + (1-beta) * w.grad\nunbias_avg = w.avg / (1 - (beta**(i+1)))\nif we are the i-th iteration (starting at 0 like Python does). This divisor of 1 - (beta**(i+1)) makes sure the unbiased average looks more like the gradients at the beginning (since beta &lt; 1, the denominator is very quickly close to 1).\nPutting everything together, our update step looks like:\nw.avg = beta1 * w.avg + (1-beta1) * w.grad\nunbias_avg = w.avg / (1 - (beta1**(i+1)))\nw.sqr_avg = beta2 * w.sqr_avg + (1-beta2) * (w.grad ** 2)\nnew_w = w - lr * unbias_avg / sqrt(w.sqr_avg + eps)\nLike for RMSProp, eps is usually set to 1e-8, and the default for (beta1,beta2) suggested by the literature is (0.9,0.999).\nIn fastai, Adam is the default optimizer we use since it allows faster training, but we’ve found that beta2=0.99 is better suited to the type of schedule we are using. beta1 is the momentum parameter, which we specify with the argument moms in our call to fit_one_cycle. As for eps, fastai uses a default of 1e-5. eps is not just useful for numerical stability. A higher eps limits the maximum value of the adjusted learning rate. To take an extreme example, if eps is 1, then the adjusted learning will never be higher than the base learning rate.\nRather than show all the code for this in the book, we’ll let you look at the optimizer notebook in fastai’s GitHub repository (browse the nbs folder and search for the notebook called optimizer). You’ll see all the code we’ve shown so far, along with Adam and other optimizers, and lots of examples and tests.\nOne thing that changes when we go from SGD to Adam is the way we apply weight decay, and it can have important consequences.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#decoupled-weight-decay",
    "href": "accel_sgd.html#decoupled-weight-decay",
    "title": "16  The Training Process",
    "section": "16.6 Decoupled Weight Decay",
    "text": "16.6 Decoupled Weight Decay\nWeight decay, which we discussed in Chapter 8, is equivalent to (in the case of vanilla SGD) updating the parameters with:\nnew_weight = weight - lr*weight.grad - lr*wd*weight\nThe last part of this formula explains the name of this technique: each weight is decayed by a factor lr * wd.\nThe other name of weight decay is L2 regularization, which consists in adding the sum of all squared weights to the loss (multiplied by the weight decay). As we have seen in Chapter 8, this can be directly expressed on the gradients with:\nweight.grad += wd*weight\nFor SGD, those two formulas are equivalent. However, this equivalence only holds for standard SGD, because we have seen that with momentum, RMSProp or in Adam, the update has some additional formulas around the gradient.\nMost libraries use the second formulation, but it was pointed out in “Decoupled Weight Decay Regularization” by Ilya Loshchilov and Frank Hutter, that the first one is the only correct approach with the Adam optimizer or momentum, which is why fastai makes it its default.\nNow you know everything that is hidden behind the line learn.fit_one_cycle!\nOptimizers are only one part of the training process, however when you need to change the training loop with fastai, you can’t directly change the code inside the library. Instead, we have designed a system of callbacks to let you write any tweaks you like in independent blocks that you can then mix and match.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#callbacks",
    "href": "accel_sgd.html#callbacks",
    "title": "16  The Training Process",
    "section": "16.7 Callbacks",
    "text": "16.7 Callbacks\nSometimes you need to change how things work a little bit. In fact, we have already seen examples of this: Mixup, fp16 training, resetting the model after each epoch for training RNNs, and so forth. How do we go about making these kinds of tweaks to the training process?\nWe’ve seen the basic training loop, which, with the help of the Optimizer class, looks like this for a single epoch:\nfor xb,yb in dl:\n    loss = loss_func(model(xb), yb)\n    loss.backward()\n    opt.step()\n    opt.zero_grad()\nFigure 16.3 shows how to picture that.\n\n\n\n\n\n\nFigure 16.3: Basic training loop\n\n\n\nThe usual way for deep learning practitioners to customize the training loop is to make a copy of an existing training loop, and then insert the code necessary for their particular changes into it. This is how nearly all code that you find online will look. But it has some very serious problems.\nIt’s not very likely that some particular tweaked training loop is going to meet your particular needs. There are hundreds of changes that can be made to a training loop, which means there are billions and billions of possible permutations. You can’t just copy one tweak from a training loop here, another from a training loop there, and expect them all to work together. Each will be based on different assumptions about the environment that it’s working in, use different naming conventions, and expect the data to be in different formats.\nWe need a way to allow users to insert their own code at any part of the training loop, but in a consistent and well-defined way. Computer scientists have already come up with an elegant solution: the callback. A callback is a piece of code that you write, and inject into another piece of code at some predefined point. In fact, callbacks have been used with deep learning training loops for years. The problem is that in previous libraries it was only possible to inject code in a small subset of places where this may have been required, and, more importantly, callbacks were not able to do all the things they needed to do.\nIn order to be just as flexible as manually copying and pasting a training loop and directly inserting code into it, a callback must be able to read every possible piece of information available in the training loop, modify all of it as needed, and fully control when a batch, epoch, or even the whole training loop should be terminated. fastai is the first library to provide all of this functionality. It modifies the training loop so it looks like Figure 16.4.\n\n\n\n\n\n\nFigure 16.4: Training loop with callbacks\n\n\n\nThe real effectiveness of this approach has been borne out over the last couple of years—it has turned out that, by using the fastai callback system, we were able to implement every single new paper we tried and fulfilled every user request for modifying the training loop. The training loop itself has not required modifications. Figure 16.5 shows just a few of the callbacks that have been added.\n\n\n\n\n\n\nFigure 16.5: Some fastai callbacks\n\n\n\nThe reason that this is important is because it means that whatever idea we have in our head, we can implement it. We need never dig into the source code of PyTorch or fastai and hack together some one-off system to try out our ideas. And when we do implement our own callbacks to develop our own ideas, we know that they will work together with all of the other functionality provided by fastai–so we will get progress bars, mixed-precision training, hyperparameter annealing, and so forth.\nAnother advantage is that it makes it easy to gradually remove or add functionality and perform ablation studies. You just need to adjust the list of callbacks you pass along to your fit function.\nAs an example, here is the fastai source code that is run for each batch of the training loop:\ntry:\n    self._split(b);                                  self('before_batch')\n    self.pred = self.model(*self.xb);                self('after_pred')\n    self.loss = self.loss_func(self.pred, *self.yb); self('after_loss')\n    if not self.training: return\n    self.loss.backward();                            self('after_backward')\n    self.opt.step();                                 self('after_step')\n    self.opt.zero_grad()\nexcept CancelBatchException:                         self('after_cancel_batch')\nfinally:                                             self('after_batch')\nThe calls of the form self('...') are where the callbacks are called. As you see, this happens after every step. The callback will receive the entire state of training, and can also modify it. For instance, the input data and target labels are in self.xb and self.yb, respectively; a callback can modify these to alter the data the training loop sees. It can also modify self.loss, or even the gradients.\nLet’s see how this works in practice by writing a callback.\n\nCreating a Callback\nWhen you want to write your own callback, the full list of available events is:\n\nbefore_fit:: called before doing anything; ideal for initial setup.\nbefore_epoch:: called at the beginning of each epoch; useful for any behavior you need to reset at each epoch.\nbefore_train:: called at the beginning of the training part of an epoch.\nbefore_batch:: called at the beginning of each batch, just after drawing said batch. It can be used to do any setup necessary for the batch (like hyperparameter scheduling) or to change the input/target before it goes into the model (for instance, apply Mixup).\nafter_pred:: called after computing the output of the model on the batch. It can be used to change that output before it’s fed to the loss function.\nafter_loss:: called after the loss has been computed, but before the backward pass. It can be used to add penalty to the loss (AR or TAR in RNN training, for instance).\nafter_backward:: called after the backward pass, but before the update of the parameters. It can be used to make changes to the gradients before said update (via gradient clipping, for instance).\nafter_step:: called after the step and before the gradients are zeroed.\nafter_batch:: called at the end of a batch, to perform any required cleanup before the next one.\nafter_train:: called at the end of the training phase of an epoch.\nbefore_validate:: called at the beginning of the validation phase of an epoch; useful for any setup needed specifically for validation.\nafter_validate:: called at the end of the validation part of an epoch.\nafter_epoch:: called at the end of an epoch, for any cleanup before the next one.\nafter_fit:: called at the end of training, for final cleanup.\n\nThe elements of this list are available as attributes of the special variable event, so you can just type event. and hit Tab in your notebook to see a list of all the options.\nLet’s take a look at an example. Do you recall how in Chapter 12 we needed to ensure that our special reset method was called at the start of training and validation for each epoch? We used the ModelResetter callback provided by fastai to do this for us. But how does it work? Here’s the full source code for that class:\n\nclass ModelResetter(Callback):\n    def before_train(self):    self.model.reset()\n    def before_validate(self): self.model.reset()\n\nYes, that’s actually it! It just does what we said in the preceding paragraph: after completing training or validation for an epoch, call a method named reset.\nCallbacks are often “short and sweet” like this one. In fact, let’s look at one more. Here’s the fastai source for the callback that adds RNN regularization (AR and TAR):\n\nclass RNNRegularizer(Callback):\n    def __init__(self, alpha=0., beta=0.): self.alpha,self.beta = alpha,beta\n\n    def after_pred(self):\n        self.raw_out,self.out = self.pred[1],self.pred[2]\n        self.learn.pred = self.pred[0]\n\n    def after_loss(self):\n        if not self.training: return\n        if self.alpha != 0.:\n            self.learn.loss += self.alpha * self.out[-1].float().pow(2).mean()\n        if self.beta != 0.:\n            h = self.raw_out[-1]\n            if len(h)&gt;1:\n                self.learn.loss += self.beta * (h[:,1:] - h[:,:-1]\n                                               ).float().pow(2).mean()\n\n\nnote: Code It Yourself: Go back and reread “Activation Regularization and Temporal Activation Regularization” in Chapter 12 then take another look at the code here. Make sure you understand what it’s doing, and why.\n\nIn both of these examples, notice how we can access attributes of the training loop by directly checking self.model or self.pred. That’s because a Callback will always try to get an attribute it doesn’t have inside the Learner associated with it. These are shortcuts for self.learn.model or self.learn.pred. Note that they work for reading attributes, but not for writing them, which is why when RNNRegularizer changes the loss or the predictions you see self.learn.loss = or self.learn.pred =.\nWhen writing a callback, the following attributes of Learner are available:\n\nmodel:: The model used for training/validation.\ndata:: The underlying DataLoaders.\nloss_func:: The loss function used.\nopt:: The optimizer used to update the model parameters.\nopt_func:: The function used to create the optimizer.\ncbs:: The list containing all the Callbacks.\ndl:: The current DataLoader used for iteration.\nx/xb:: The last input drawn from self.dl (potentially modified by callbacks). xb is always a tuple (potentially with one element) and x is detuplified. You can only assign to xb.\ny/yb:: The last target drawn from self.dl (potentially modified by callbacks). yb is always a tuple (potentially with one element) and y is detuplified. You can only assign to yb.\npred:: The last predictions from self.model (potentially modified by callbacks).\nloss:: The last computed loss (potentially modified by callbacks).\nn_epoch:: The number of epochs in this training.\nn_iter:: The number of iterations in the current self.dl.\nepoch:: The current epoch index (from 0 to n_epoch-1).\niter:: The current iteration index in self.dl (from 0 to n_iter-1).\n\nThe following attributes are added by TrainEvalCallback and should be available unless you went out of your way to remove that callback:\n\ntrain_iter:: The number of training iterations done since the beginning of this training\npct_train:: The percentage of training iterations completed (from 0. to 1.)\ntraining:: A flag to indicate whether or not we’re in training mode\n\nThe following attribute is added by Recorder and should be available unless you went out of your way to remove that callback:\n\nsmooth_loss:: An exponentially averaged version of the training loss\n\nCallbacks can also interrupt any part of the training loop by using a system of exceptions.\n\n\nCallback Ordering and Exceptions\nSometimes, callbacks need to be able to tell fastai to skip over a batch, or an epoch, or stop training altogether. For instance, consider TerminateOnNaNCallback. This handy callback will automatically stop training any time the loss becomes infinite or NaN (not a number). Here’s the fastai source for this callback:\n\nclass TerminateOnNaNCallback(Callback):\n    run_before=Recorder\n    def after_batch(self):\n        if torch.isinf(self.loss) or torch.isnan(self.loss):\n            raise CancelFitException\n\nThe line raise CancelFitException tells the training loop to interrupt training at this point. The training loop catches this exception and does not run any further training or validation. The callback control flow exceptions available are:\n\nCancelBatchException:: Skip the rest of this batch and go to after_batch.\nCancelTrainException:: Skip the rest of the training part of the epoch and go to after_train.\nCancelValidException:: Skip the rest of the validation part of the epoch and go to after_validate.\nCancelEpochException:: Skip the rest of this epoch and go to after_epoch.\nCancelFitException:: Interrupt training and go to after_fit.\n\nYou can detect if one of those exceptions has occurred and add code that executes right after with the following events:\n\nafter_cancel_batch:: Reached immediately after a CancelBatchException before proceeding to after_batch\nafter_cancel_train:: Reached immediately after a CancelTrainException before proceeding to after_train\nafter_cancel_valid:: Reached immediately after a CancelValidException before proceeding to after_valid\nafter_cancel_epoch:: Reached immediately after a CancelEpochException before proceeding to after_epoch\nafter_cancel_fit:: Reached immediately after a CancelFitException before proceeding to after_fit\n\nSometimes, callbacks need to be called in a particular order. For example, in the case of TerminateOnNaNCallback, it’s important that Recorder runs its after_batch after this callback, to avoid registering an NaN loss. You can specify run_before (this callback must run before …) or run_after (this callback must run after …) in your callback to ensure the ordering that you need.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#conclusion",
    "href": "accel_sgd.html#conclusion",
    "title": "16  The Training Process",
    "section": "16.8 Conclusion",
    "text": "16.8 Conclusion\nIn this chapter we took a close look at the training loop, exploring different variants of SGD and why they can be more powerful. At the time of writing, developing new optimizers is a very active area of research, so by the time you read this chapter there may be an addendum on the book’s website that presents new variants. Be sure to check out how our general optimizer framework can help you implement new optimizers very quickly.\nWe also examined the powerful callback system that allows you to customize every bit of the training loop by enabling you to inspect and modify any parameter you like between each step.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#questionnaire",
    "href": "accel_sgd.html#questionnaire",
    "title": "16  The Training Process",
    "section": "16.9 Questionnaire",
    "text": "16.9 Questionnaire\n\nWhat is the equation for a step of SGD, in math or code (as you prefer)?\nWhat do we pass to vision_learner to use a non-default optimizer?\nWhat are optimizer callbacks?\nWhat does zero_grad do in an optimizer?\nWhat does step do in an optimizer? How is it implemented in the general optimizer?\nRewrite sgd_cb to use the += operator, instead of add_.\nWhat is “momentum”? Write out the equation.\nWhat’s a physical analogy for momentum? How does it apply in our model training settings?\nWhat does a bigger value for momentum do to the gradients?\nWhat are the default values of momentum for 1cycle training?\nWhat is RMSProp? Write out the equation.\nWhat do the squared values of the gradients indicate?\nHow does Adam differ from momentum and RMSProp?\nWrite out the equation for Adam.\nCalculate the values of unbias_avg and w.avg for a few batches of dummy values.\nWhat’s the impact of having a high eps in Adam?\nRead through the optimizer notebook in fastai’s repo, and execute it.\nIn what situations do dynamic learning rate methods like Adam change the behavior of weight decay?\nWhat are the four steps of a training loop?\nWhy is using callbacks better than writing a new training loop for each tweak you want to add?\nWhat aspects of the design of fastai’s callback system make it as flexible as copying and pasting bits of code?\nHow can you get the list of events available to you when writing a callback?\nWrite the ModelResetter callback (without peeking).\nHow can you access the necessary attributes of the training loop inside a callback? When can you use or not use the shortcuts that go with them?\nHow can a callback influence the control flow of the training loop?\nWrite the TerminateOnNaN callback (without peeking, if possible).\nHow do you make sure your callback runs after or before another callback?\n\n\nFurther Research\n\nLook up the “Rectified Adam” paper, implement it using the general optimizer framework, and try it out. Search for other recent optimizers that work well in practice, and pick one to implement.\nLook at the mixed-precision callback with the documentation. Try to understand what each event and line of code does.\nImplement your own version of the learning rate finder from scratch. Compare it with fastai’s version.\nLook at the source code of the callbacks that ship with fastai. See if you can find one that’s similar to what you’re looking to do, to get some inspiration.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "accel_sgd.html#foundations-of-deep-learning-wrap-up",
    "href": "accel_sgd.html#foundations-of-deep-learning-wrap-up",
    "title": "16  The Training Process",
    "section": "16.10 Foundations of Deep Learning: Wrap up",
    "text": "16.10 Foundations of Deep Learning: Wrap up\nCongratulations, you have made it to the end of the “foundations of deep learning” section of the book! You now understand how all of fastai’s applications and most important architectures are built, and the recommended ways to train them—and you have all the information you need to build these from scratch. While you probably won’t need to create your own training loop, or batchnorm layer, for instance, knowing what is going on behind the scenes is very helpful for debugging, profiling, and deploying your solutions.\nSince you understand the foundations of fastai’s applications now, be sure to spend some time digging through the source notebooks and running and experimenting with parts of them. This will give you a better idea of how everything in fastai is developed.\nIn the next section, we will be looking even further under the covers: we’ll explore how the actual forward and backward passes of a neural network are done, and we will see what tools are at our disposal to get better performance. We will then continue with a project that brings together all the material in the book, which we will use to build a tool for interpreting convolutional neural networks. Last but not least, we’ll finish by building fastai’s Learner class from scratch.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>The Training Process</span>"
    ]
  },
  {
    "objectID": "foundations.html",
    "href": "foundations.html",
    "title": "17  A Neural Net from the Foundations",
    "section": "",
    "text": "17.1 Building a Neural Net Layer from Scratch\nLet’s start by refreshing our understanding of how matrix multiplication is used in a basic neural network. Since we’re building everything up from scratch, we’ll use nothing but plain Python initially (except for indexing into PyTorch tensors), and then replace the plain Python with PyTorch functionality once we’ve seen how to create it.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Neural Net from the Foundations</span>"
    ]
  },
  {
    "objectID": "foundations.html#building-a-neural-net-layer-from-scratch",
    "href": "foundations.html#building-a-neural-net-layer-from-scratch",
    "title": "17  A Neural Net from the Foundations",
    "section": "",
    "text": "Modeling a Neuron\nA neuron receives a given number of inputs and has an internal weight for each of them. It sums those weighted inputs to produce an output and adds an inner bias. In math, this can be written as:\n\\[ out = \\sum_{i=1}^{n} x_{i} w_{i} + b\\]\nif we name our inputs \\((x_{1},\\dots,x_{n})\\), our weights \\((w_{1},\\dots,w_{n})\\), and our bias \\(b\\). In code this translates into:\noutput = sum([x*w for x,w in zip(inputs,weights)]) + bias\nThis output is then fed into a nonlinear function called an activation function before being sent to another neuron. In deep learning the most common of these is the rectified Linear unit, or ReLU, which, as we’ve seen, is a fancy way of saying:\ndef relu(x): return x if x &gt;= 0 else 0\nA deep learning model is then built by stacking a lot of those neurons in successive layers. We create a first layer with a certain number of neurons (known as hidden size) and link all the inputs to each of those neurons. Such a layer is often called a fully connected layer or a dense layer (for densely connected), or a linear layer.\nIt requires to compute, for each input in our batch and each neuron with a give weight, the dot product:\nsum([x*w for x,w in zip(input,weight)])\nIf you have done a little bit of linear algebra, you may remember that having a lot of those dot products happens when you do a matrix multiplication. More precisely, if our inputs are in a matrix x with a size of batch_size by n_inputs, and if we have grouped the weights of our neurons in a matrix w of size n_neurons by n_inputs (each neuron must have the same number of weights as it has inputs) and all the biases in a vector b of size n_neurons, then the output of this fully connected layer is:\ny = x @ w.t() + b\nwhere @ represents the matrix product and w.t() is the transpose matrix of w. The output y is then of size batch_size by n_neurons, and in position (i,j) we have (for the mathy folks out there):\n\\[y_{i,j} = \\sum_{k=1}^{n} x_{i,k} w_{k,j} + b_{j}\\]\nOr in code:\ny[i,j] = sum([a * b for a,b in zip(x[i,:],w[j,:])]) + b[j]\nThe transpose is necessary because in the mathematical definition of the matrix product m @ n, the coefficient (i,j) is:\nsum([a * b for a,b in zip(m[i,:],n[:,j])])\nSo the very basic operation we need is a matrix multiplication, as it’s what is hidden in the core of a neural net.\n\n\nMatrix Multiplication from Scratch\nLet’s write a function that computes the matrix product of two tensors, before we allow ourselves to use the PyTorch version of it. We will only use the indexing in PyTorch tensors:\n\nimport torch\nfrom torch import tensor\n\nWe’ll need three nested for loops: one for the row indices, one for the column indices, and one for the inner sum. ac and ar stand for number of columns of a and number of rows of a, respectively (the same convention is followed for b), and we make sure calculating the matrix product is possible by checking that a has as many columns as b has rows:\n\ndef matmul(a,b):\n    ar,ac = a.shape # n_rows * n_cols\n    br,bc = b.shape\n    assert ac==br\n    c = torch.zeros(ar, bc)\n    for i in range(ar):\n        for j in range(bc):\n            for k in range(ac): c[i,j] += a[i,k] * b[k,j]\n    return c\n\nTo test this out, we’ll pretend (using random matrices) that we’re working with a small batch of 5 MNIST images, flattened into 28×28 vectors, with linear model to turn them into 10 activations:\n\nm1 = torch.randn(5,28*28)\nm2 = torch.randn(784,10)\n\nLet’s time our function, using the Jupyter “magic” command %time:\n\n%time t1=matmul(m1, m2)\n\nCPU times: user 211 ms, sys: 504 µs, total: 212 ms\nWall time: 211 ms\n\n\nAnd see how that compares to PyTorch’s built-in @:\n\n%timeit -n 20 t2=m1@m2\n\nThe slowest run took 9.18 times longer than the fastest. This could mean that an intermediate result is being cached.\n8.15 µs ± 9.07 µs per loop (mean ± std. dev. of 7 runs, 20 loops each)\n\n\nAs we can see, in Python three nested loops is a very bad idea! Python is a slow language, and this isn’t going to be very efficient. We see here that PyTorch is around 100,000 times faster than Python—and that’s before we even start using the GPU!\nWhere does this difference come from? PyTorch didn’t write its matrix multiplication in Python, but rather in C++ to make it fast. In general, whenever we do computations on tensors we will need to vectorize them so that we can take advantage of the speed of PyTorch, usually by using two techniques: elementwise arithmetic and broadcasting.\n\n\nElementwise Arithmetic\nAll the basic operators (+, -, *, /, &gt;, &lt;, ==) can be applied elementwise. That means if we write a+b for two tensors a and b that have the same shape, we will get a tensor composed of the sums the elements of a and b:\n\na = tensor([10., 6, -4])\nb = tensor([2., 8, 7])\na + b\n\ntensor([12., 14.,  3.])\n\n\nThe Booleans operators will return an array of Booleans:\n\na &lt; b\n\ntensor([False,  True,  True])\n\n\nIf we want to know if every element of a is less than the corresponding element in b, or if two tensors are equal, we need to combine those elementwise operations with torch.all:\n\n(a &lt; b).all(), (a==b).all()\n\n(tensor(False), tensor(False))\n\n\nReduction operations like all(), sum() and mean() return tensors with only one element, called rank-0 tensors. If you want to convert this to a plain Python Boolean or number, you need to call .item():\n\n(a + b).mean().item()\n\n9.666666984558105\n\n\nThe elementwise operations work on tensors of any rank, as long as they have the same shape:\n\nm = tensor([[1., 2, 3], [4,5,6], [7,8,9]])\nm*m\n\ntensor([[ 1.,  4.,  9.],\n        [16., 25., 36.],\n        [49., 64., 81.]])\n\n\nHowever you can’t perform elementwise operations on tensors that don’t have the same shape (unless they are broadcastable, as discussed in the next section):\nm*tensor([[1., 2, 3], [4,5,6]])\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\nCell In [14], line 1\n----&gt; 1 m*n\n\nRuntimeError: The size of tensor a (3) must match the size of tensor b (2) at non-singleton dimension 0\nWith elementwise arithmetic, we can remove one of our three nested loops: we can multiply the tensors that correspond to the i-th row of a and the j-th column of b before summing all the elements, which will speed things up because the inner loop will now be executed by PyTorch at C speed.\nTo access one column or row, we can simply write a[i,:] or b[:,j]. The : means take everything in that dimension. We could restrict this and take only a slice of that particular dimension by passing a range, like 1:5, instead of just :. In that case, we would take the elements in columns or rows 1 to 4 (the second number is noninclusive).\nOne simplification is that we can always omit a trailing colon, so a[i,:] can be abbreviated to a[i]. With all of that in mind, we can write a new version of our matrix multiplication:\n\ndef matmul(a,b):\n    ar,ac = a.shape\n    br,bc = b.shape\n    assert ac==br\n    c = torch.zeros(ar, bc)\n    for i in range(ar):\n        for j in range(bc): c[i,j] = (a[i] * b[:,j]).sum()\n    return c\n\n\n%timeit -n 20 t3 = matmul(m1,m2)\n\n257 µs ± 25.4 µs per loop (mean ± std. dev. of 7 runs, 20 loops each)\n\n\nWe’re already ~700 times faster, just by removing that inner for loop! And that’s just the beginning—with broadcasting we can remove another loop and get an even more important speed up.\n\n\nBroadcasting\nAs we discussed in Chapter 4, broadcasting is a term introduced by the NumPy library that describes how tensors of different ranks are treated during arithmetic operations. For instance, it’s obvious there is no way to add a 3×3 matrix with a 4×5 matrix, but what if we want to add one scalar (which can be represented as a 1×1 tensor) with a matrix? Or a vector of size 3 with a 3×4 matrix? In both cases, we can find a way to make sense of this operation.\nBroadcasting gives specific rules to codify when shapes are compatible when trying to do an elementwise operation, and how the tensor of the smaller shape is expanded to match the tensor of the bigger shape. It’s essential to master those rules if you want to be able to write code that executes quickly. In this section, we’ll expand our previous treatment of broadcasting to understand these rules.\n\nBroadcasting with a scalar\nBroadcasting with a scalar is the easiest type of broadcasting. When we have a tensor a and a scalar, we just imagine a tensor of the same shape as a filled with that scalar and perform the operation:\n\na = tensor([10., 6, -4])\na &gt; 0\n\ntensor([ True,  True, False])\n\n\nHow are we able to do this comparison? 0 is being broadcast to have the same dimensions as a. Note that this is done without creating a tensor full of zeros in memory (that would be very inefficient).\nThis is very useful if you want to normalize your dataset by subtracting the mean (a scalar) from the entire data set (a matrix) and dividing by the standard deviation (another scalar):\n\nm = tensor([[1., 2, 3], [4,5,6], [7,8,9]])\n(m - 5) / 2.73\n\ntensor([[-1.4652, -1.0989, -0.7326],\n        [-0.3663,  0.0000,  0.3663],\n        [ 0.7326,  1.0989,  1.4652]])\n\n\nWhat if have different means for each row of the matrix? in that case you will need to broadcast a vector to a matrix.\n\n\nBroadcasting a vector to a matrix\nWe can broadcast a vector to a matrix as follows:\n\nc = tensor([10.,20,30])\nm = tensor([[1., 2, 3], [4,5,6], [7,8,9]])\nm.shape,c.shape\n\n(torch.Size([3, 3]), torch.Size([3]))\n\n\n\nm + c\n\ntensor([[11., 22., 33.],\n        [14., 25., 36.],\n        [17., 28., 39.]])\n\n\nHere the elements of c are expanded to make three rows that match, making the operation possible. Again, PyTorch doesn’t actually create three copies of c in memory. This is done by the expand_as method behind the scenes:\n\nc.expand_as(m)\n\ntensor([[10., 20., 30.],\n        [10., 20., 30.],\n        [10., 20., 30.]])\n\n\nIf we look at the corresponding tensor, we can ask for its storage property (which shows the actual contents of the memory used for the tensor) to check there is no useless data stored:\n\nt = c.expand_as(m)\nt.storage()\n\n 10.0\n 20.0\n 30.0\n[torch.storage._TypedStorage(dtype=torch.float32, device=cpu) of size 3]\n\n\nEven though the tensor officially has nine elements, only three scalars are stored in memory. This is possible thanks to the clever trick of giving that dimension a stride of 0 (which means that when PyTorch looks for the next row by adding the stride, it doesn’t move):\n\nt.stride(), t.shape\n\n((0, 1), torch.Size([3, 3]))\n\n\nSince m is of size 3×3, there are two ways to do broadcasting. The fact it was done on the last dimension is a convention that comes from the rules of broadcasting and has nothing to do with the way we ordered our tensors. If instead we do this, we get the same result:\n\nc + m\n\ntensor([[11., 22., 33.],\n        [14., 25., 36.],\n        [17., 28., 39.]])\n\n\nIn fact, it’s only possible to broadcast a vector of size n with a matrix of size m by n:\n\nc = tensor([10.,20,30])\nm = tensor([[1., 2, 3], [4,5,6]])\nc+m\n\ntensor([[11., 22., 33.],\n        [14., 25., 36.]])\n\n\nThis won’t work:\nc = tensor([10.,20])\nc+tensor([[1., 2, 3], [4,5,6]])\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\nCell In [26], line 3\n      1 c = tensor([10.,20])\n      2 m = tensor([[1., 2, 3], [4,5,6]])\n----&gt; 3 c+m\n\nRuntimeError: The size of tensor a (2) must match the size of tensor b (3) at non-singleton dimension 1\nIf we want to broadcast in the other dimension, we have to change the shape of our vector to make it a 3×1 matrix. This is done with the unsqueeze method in PyTorch:\n\nc = tensor([10.,20,30])\nm = tensor([[1., 2, 3], [4,5,6], [7,8,9]])\nc = c.unsqueeze(1)\nm.shape,c.shape\n\n(torch.Size([3, 3]), torch.Size([3, 1]))\n\n\nThis time, c is expanded on the column side:\n\nc+m\n\ntensor([[11., 12., 13.],\n        [24., 25., 26.],\n        [37., 38., 39.]])\n\n\nLike before, only three scalars are stored in memory:\n\nt = c.expand_as(m)\nt.storage()\n\n 10.0\n 20.0\n 30.0\n[torch.storage._TypedStorage(dtype=torch.float32, device=cpu) of size 3]\n\n\nAnd the expanded tensor has the right shape because the column dimension has a stride of 0:\n\nt.stride(), t.shape\n\n((1, 0), torch.Size([3, 3]))\n\n\nWith broadcasting, by default if we need to add dimensions, they are added at the beginning. When we were broadcasting before, Pytorch was doing c.unsqueeze(0) behind the scenes:\n\nc = tensor([10.,20,30])\nc.shape, c.unsqueeze(0).shape,c.unsqueeze(1).shape\n\n(torch.Size([3]), torch.Size([1, 3]), torch.Size([3, 1]))\n\n\nThe unsqueeze command can be replaced by None indexing:\n\nc.shape, c[None,:].shape,c[:,None].shape\n\n(torch.Size([3]), torch.Size([1, 3]), torch.Size([3, 1]))\n\n\nYou can always omit trailing colons, and ... means all preceding dimensions:\n\nc[None].shape,c[...,None].shape\n\n(torch.Size([1, 3]), torch.Size([3, 1]))\n\n\nWith this, we can remove another for loop in our matrix multiplication function. Now, instead of multiplying a[i] with b[:,j], we can multiply a[i] with the whole matrix b using broadcasting, then sum the results:\n\ndef matmul(a,b):\n    ar,ac = a.shape\n    br,bc = b.shape\n    assert ac==br\n    c = torch.zeros(ar, bc)\n    for i in range(ar):\n#       c[i,j] = (a[i,:]          * b[:,j]).sum() # previous\n        c[i]   = (a[i  ].unsqueeze(-1) * b).sum(dim=0)\n    return c\n\n\n%timeit -n 20 t4 = matmul(m1,m2)\n\n43.9 µs ± 8.28 µs per loop (mean ± std. dev. of 7 runs, 20 loops each)\n\n\nWe’re now 3,700 times faster than our first implementation! Before we move on, let’s discuss the rules of broadcasting in a little more detail.\n\n\nBroadcasting rules\nWhen operating on two tensors, PyTorch compares their shapes elementwise. It starts with the trailing dimensions and works its way backward, adding 1 when it meets empty dimensions. Two dimensions are compatible when one of the following is true:\n\nThey are equal.\nOne of them is 1, in which case that dimension is broadcast to make it the same as the other.\n\nArrays do not need to have the same number of dimensions. For example, if you have a 256×256×3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with three values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rules, shows that they are compatible:\nImage  (3d tensor): 256 x 256 x 3\nScale  (1d tensor):  (1)   (1)  3\nResult (3d tensor): 256 x 256 x 3\nHowever, a 2D tensor of size 256×256 isn’t compatible with our image:\nImage  (3d tensor): 256 x 256 x   3\nScale  (2d tensor):  (1)  256 x 256\nError\nIn our earlier examples we had with a 3×3 matrix and a vector of size 3, broadcasting was done on the rows:\nMatrix (2d tensor):   3 x 3\nVector (1d tensor): (1)   3\nResult (2d tensor):   3 x 3\nAs an exercise, try to determine what dimensions to add (and where) when you need to normalize a batch of images of size 64 x 3 x 256 x 256 with vectors of three elements (one for the mean and one for the standard deviation).\nAnother useful way of simplifying tensor manipulations is the use of Einstein summations convention.\n\n\n\nEinstein Summation\nBefore using the PyTorch operation @ or torch.matmul, there is one last way we can implement matrix multiplication: Einstein summation (einsum). This is a compact representation for combining products and sums in a general way. We write an equation like this:\nik,kj -&gt; ij\nThe lefthand side represents the operands dimensions, separated by commas. Here we have two tensors that each have two dimensions (i,k and k,j). The righthand side represents the result dimensions, so here we have a tensor with two dimensions i,j.\nThe rules of Einstein summation notation are as follows:\n\nRepeated indices on the left side are implicitly summed over if they are not on the right side.\nEach index can appear at most twice on the left side.\nThe unrepeated indices on the left side must appear on the right side.\n\nSo in our example, since k is repeated, we sum over that index. In the end the formula represents the matrix obtained when we put in (i,j) the sum of all the coefficients (i,k) in the first tensor multiplied by the coefficients (k,j) in the second tensor… which is the matrix product! Here is how we can code this in PyTorch:\n\ndef matmul(a,b): return torch.einsum('ik,kj-&gt;ij', a, b)\n\nEinstein summation is a very practical way of expressing operations involving indexing and sum of products. Note that you can have just one member on the lefthand side. For instance, this:\ntorch.einsum('ij-&gt;ji', a)\nreturns the transpose of the matrix a. You can also have three or more members. This:\ntorch.einsum('bi,ij,bj-&gt;b', a, b, c)\nwill return a vector of size b where the k-th coordinate is the sum of a[k,i] b[i,j] c[k,j]. This notation is particularly convenient when you have more dimensions because of batches. For example, if you have two batches of matrices and want to compute the matrix product per batch, you would could this:\ntorch.einsum('bik,bkj-&gt;bij', a, b)\nLet’s go back to our new matmul implementation using einsum and look at its speed:\n\n%timeit -n 20 t5 = matmul(m1,m2)\n\n19 µs ± 13.2 µs per loop (mean ± std. dev. of 7 runs, 20 loops each)\n\n\nAs you can see, not only is it practical, but it’s very fast. einsum is often the fastest way to do custom operations in PyTorch, without diving into C++ and CUDA. (But it’s generally not as fast as carefully optimized CUDA code, as you see from the results in “Matrix Multiplication from Scratch”.)\nNow that we know how to implement a matrix multiplication from scratch, we are ready to build our neural net—specifically its forward and backward passes—using just matrix multiplications.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Neural Net from the Foundations</span>"
    ]
  },
  {
    "objectID": "foundations.html#the-forward-and-backward-passes",
    "href": "foundations.html#the-forward-and-backward-passes",
    "title": "17  A Neural Net from the Foundations",
    "section": "17.2 The Forward and Backward Passes",
    "text": "17.2 The Forward and Backward Passes\nAs we saw in Chapter 4, to train a model, we will need to compute all the gradients of a given loss with respect to its parameters, which is known as the backward pass. The forward pass is where we compute the output of the model on a given input, based on the matrix products. As we define our first neural net, we will also delve into the problem of properly initializing the weights, which is crucial for making training start properly.\n\nDefining and Initializing a Layer\nWe will take the example of a two-layer neural net first. As we’ve seen, one layer can be expressed as y = x @ w + b, with x our inputs, y our outputs, w the weights of the layer (which is of size number of inputs by number of neurons if we don’t transpose like before), and b is the bias vector:\n\ndef lin(x, w, b): return x @ w + b\n\nWe can stack the second layer on top of the first, but since mathematically the composition of two linear operations is another linear operation, this only makes sense if we put something nonlinear in the middle, called an activation function. As mentioned at the beginning of the chapter, in deep learning applications the activation function most commonly used is a ReLU, which returns the maximum of x and 0.\nWe won’t actually train our model in this chapter, so we’ll use random tensors for our inputs and targets. Let’s say our inputs are 200 vectors of size 100, which we group into one batch, and our targets are 200 random floats:\n\nx = torch.randn(200, 100)\ny = torch.randn(200)\n\nFor our two-layer model we will need two weight matrices and two bias vectors. Let’s say we have a hidden size of 50 and the output size is 1 (for one of our inputs, the corresponding output is one float in this toy example). We initialize the weights randomly and the bias at zero:\n\nw1 = torch.randn(100,50)\nb1 = torch.zeros(50)\nw2 = torch.randn(50,1)\nb2 = torch.zeros(1)\n\nThen the result of our first layer is simply:\n\nl1 = lin(x, w1, b1)\nl1.shape\n\ntorch.Size([200, 50])\n\n\nNote that this formula works with our batch of inputs, and returns a batch of hidden state: l1 is a matrix of size 200 (our batch size) by 50 (our hidden size).\nThere is a problem with the way our model was initialized, however. To understand it, we need to look at the mean and standard deviation (std) of l1:\n\nl1.mean(), l1.std()\n\n(tensor(0.1381), tensor(9.8549))\n\n\nThe mean is close to zero, which is understandable since both our input and weight matrices have means close to zero. But the standard deviation, which represents how far away our activations go from the mean, went from 1 to 10. This is a really big problem because that’s with just one layer. Modern neural nets can have hundred of layers, so if each of them multiplies the scale of our activations by 10, by the end of the last layer we won’t have numbers representable by a computer.\nIndeed, if we make just 50 multiplications between x and random matrices of size 100×100, we’ll have:\n\nx = torch.randn(200, 100)\nfor i in range(50): x = x @ torch.randn(100,100)\nx[0:5,0:5]\n\ntensor([[nan, nan, nan, nan, nan],\n        [nan, nan, nan, nan, nan],\n        [nan, nan, nan, nan, nan],\n        [nan, nan, nan, nan, nan],\n        [nan, nan, nan, nan, nan]])\n\n\nThe result is nans everywhere. So maybe the scale of our matrix was too big, and we need to have smaller weights? But if we use too small weights, we will have the opposite problem—the scale of our activations will go from 1 to 0.1, and after 50 layers we’ll be left with zeros everywhere:\n\nx = torch.randn(200, 100)\nfor i in range(50): x = x @ (torch.randn(100,100) * 0.01)\nx[0:5,0:5]\n\ntensor([[0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0.],\n        [0., 0., 0., 0., 0.]])\n\n\nSo we have to scale our weight matrices exactly right so that the standard deviation of our activations stays at 1. We can compute the exact value to use mathematically, as illustrated by Xavier Glorot and Yoshua Bengio in “Understanding the Difficulty of Training Deep Feedforward Neural Networks”. The right scale for a given layer is \\(1/\\sqrt{n_{in}}\\), where \\(n_{in}\\) represents the number of inputs.\nIn our case, if we have 100 inputs, we should scale our weight matrices by 0.1:\n\nx = torch.randn(200, 100)\nfor i in range(50): x = x @ (torch.randn(100,100) * 0.1)\nx[0:5,0:5]\n\ntensor([[-0.1769, -0.0389,  0.5414,  0.5769,  0.1272],\n        [ 0.2133, -1.1071,  0.8511, -1.2352, -0.6003],\n        [ 0.4065, -2.1840,  2.3958, -2.3253, -0.9688],\n        [ 0.1720,  1.2012, -2.4649, -0.7765,  0.7338],\n        [-0.0977,  1.4870, -2.0249,  1.0367,  0.8047]])\n\n\nFinally some numbers that are neither zeros nor nans! Notice how stable the scale of our activations is, even after those 50 fake layers:\n\nx.std()\n\ntensor(1.5285)\n\n\nIf you play a little bit with the value for scale you’ll notice that even a slight variation from 0.1 will get you either to very small or very large numbers, so initializing the weights properly is extremely important.\nLet’s go back to our neural net. Since we messed a bit with our inputs, we need to redefine them:\n\nx = torch.randn(200, 100)\ny = torch.randn(200)\n\nAnd for our weights, we’ll use the right scale, which is known as Xavier initialization (or Glorot initialization):\n\nfrom math import sqrt\nw1 = torch.randn(100,50) / sqrt(100)\nb1 = torch.zeros(50)\nw2 = torch.randn(50,1) / sqrt(50)\nb2 = torch.zeros(1)\n\nNow if we compute the result of the first layer, we can check that the mean and standard deviation are under control:\n\nl1 = lin(x, w1, b1)\nl1.mean(),l1.std()\n\n(tensor(-0.0067), tensor(0.9904))\n\n\nVery good. Now we need to go through a ReLU, so let’s define one. A ReLU removes the negatives and replaces them with zeros, which is another way of saying it clamps our tensor at zero:\n\ndef relu(x): return x.clamp_min(0.)\n\nWe pass our activations through this:\n\nl2 = relu(l1)\nl2.mean(),l2.std()\n\n(tensor(0.3906), tensor(0.5769))\n\n\nAnd we’re back to square one: the mean of our activations has gone to 0.4 (which is understandable since we removed the negatives) and the std went down to 0.58. So like before, after a few layers we will probably wind up with zeros:\n\nx = torch.randn(200, 100)\nfor i in range(50): x = relu(x @ (torch.randn(100,100) * 0.1))\nx[0:5,0:5]\n\ntensor([[1.7712e-08, 0.0000e+00, 1.7827e-09, 0.0000e+00, 4.7123e-09],\n        [1.6280e-08, 0.0000e+00, 3.4217e-09, 0.0000e+00, 4.2597e-09],\n        [1.7071e-08, 0.0000e+00, 5.9012e-09, 0.0000e+00, 5.1323e-09],\n        [2.7019e-08, 0.0000e+00, 2.2739e-09, 0.0000e+00, 6.4754e-09],\n        [1.7600e-08, 0.0000e+00, 2.7536e-09, 0.0000e+00, 4.0279e-09]])\n\n\nThis means our initialization wasn’t right. Why? At the time Glorot and Bengio wrote their article, the popular activation in a neural net was the hyperbolic tangent (tanh, which is the one they used), and that initialization doesn’t account for our ReLU. Fortunately, someone else has done the math for us and computed the right scale for us to use. In “Delving Deep into Rectifiers: Surpassing Human-Level Performance” (which we’ve seen before—it’s the article that introduced the ResNet), Kaiming He et al. show that we should use the following scale instead: \\(\\sqrt{2 / n_{in}}\\), where \\(n_{in}\\) is the number of inputs of our model. Let’s see what this gives us:\n\nx = torch.randn(200, 100)\nfor i in range(50): x = relu(x @ (torch.randn(100,100) * sqrt(2/100)))\nx[0:5,0:5]\n\ntensor([[0.2880, 0.2231, 0.0000, 1.4916, 2.1533],\n        [0.2511, 0.1750, 0.0000, 1.3327, 1.8034],\n        [0.2895, 0.1873, 0.0000, 0.8633, 1.2818],\n        [0.2071, 0.1811, 0.0000, 1.4611, 2.0061],\n        [0.4338, 0.3052, 0.0101, 1.4161, 2.0849]])\n\n\nThat’s better: our numbers aren’t all zeroed this time. So let’s go back to the definition of our neural net and use this initialization (which is named Kaiming initialization or He initialization):\n\nx = torch.randn(200, 100)\ny = torch.randn(200)\n\n\nw1 = torch.randn(100,50) * sqrt(2 / 100)\nb1 = torch.zeros(50)\nw2 = torch.randn(50,1) * sqrt(2 / 50)\nb2 = torch.zeros(1)\n\nLet’s look at the scale of our activations after going through the first linear layer and ReLU:\n\nl1 = lin(x, w1, b1)\nl2 = relu(l1)\nl2.mean(), l2.std()\n\n(tensor(0.5656), tensor(0.8275))\n\n\nMuch better! Now that our weights are properly initialized, we can define our whole model:\n\ndef model(x):\n    l1 = lin(x, w1, b1)\n    l2 = relu(l1)\n    l3 = lin(l2, w2, b2)\n    return l3\n\nThis is the forward pass. Now all that’s left to do is to compare our output to the labels we have (random numbers, in this example) with a loss function. In this case, we will use the mean squared error. (It’s a toy problem, and this is the easiest loss function to use for what is next, computing the gradients.)\nThe only subtlety is that our outputs and targets don’t have exactly the same shape—after going though the model, we get an output like this:\n\nout = model(x)\nout.shape\n\ntorch.Size([200, 1])\n\n\nTo get rid of this trailing 1 dimension, we use the squeeze function:\n\ndef mse(output, targ): return (output.squeeze(-1) - targ).pow(2).mean()\n\nAnd now we are ready to compute our loss:\n\nloss = mse(out, y)\n\nThat’s all for the forward pass—let’s now look at the gradients.\n\n\nGradients and the Backward Pass\nWe’ve seen that PyTorch computes all the gradients we need with a magic call to loss.backward, but let’s explore what’s happening behind the scenes.\nNow comes the part where we need to compute the gradients of the loss with respect to all the weights of our model, so all the floats in w1, b1, w2, and b2. For this, we will need a bit of math—specifically the chain rule. This is the rule of calculus that guides how we can compute the derivative of a composed function:\n\\[(g \\circ f)'(x) = g'(f(x)) f'(x)\\]\n\nj: I find this notation very hard to wrap my head around, so instead I like to think of it as: if y = g(u) and u=f(x); then dy/dx = dy/du * du/dx. The two notations mean the same thing, so use whatever works for you.\n\nOur loss is a big composition of different functions: mean squared error (which is in turn the composition of a mean and a power of two), the second linear layer, a ReLU and the first linear layer. For instance, if we want the gradients of the loss with respect to b2 and our loss is defined by:\nloss = mse(out,y) = mse(lin(l2, w2, b2), y)\nThe chain rule tells us that we have: \\[\\frac{\\text{d} loss}{\\text{d} b_{2}} = \\frac{\\text{d} loss}{\\text{d} out} \\times \\frac{\\text{d} out}{\\text{d} b_{2}} = \\frac{\\text{d}}{\\text{d} out} mse(out, y) \\times \\frac{\\text{d}}{\\text{d} b_{2}} lin(l_{2}, w_{2}, b_{2})\\]\nTo compute the gradients of the loss with respect to \\(b_{2}\\), we first need the gradients of the loss with respect to our output \\(out\\). It’s the same if we want the gradients of the loss with respect to \\(w_{2}\\). Then, to get the gradients of the loss with respect to \\(b_{1}\\) or \\(w_{1}\\), we will need the gradients of the loss with respect to \\(l_{1}\\), which in turn requires the gradients of the loss with respect to \\(l_{2}\\), which will need the gradients of the loss with respect to \\(out\\).\nSo to compute all the gradients we need for the update, we need to begin from the output of the model and work our way backward, one layer after the other—which is why this step is known as backpropagation. We can automate it by having each function we implemented (relu, mse, lin) provide its backward step: that is, how to derive the gradients of the loss with respect to the input(s) from the gradients of the loss with respect to the output.\nHere we populate those gradients in an attribute of each tensor, a bit like PyTorch does with .grad.\nThe first are the gradients of the loss with respect to the output of our model (which is the input of the loss function). We undo the squeeze we did in mse, then we use the formula that gives us the derivative of \\(x^{2}\\): \\(2x\\). The derivative of the mean is just \\(1/n\\) where \\(n\\) is the number of elements in our input:\n\ndef mse_grad(inp, targ): \n    # grad of loss with respect to output of previous layer\n    inp.g = 2. * (inp.squeeze() - targ).unsqueeze(-1) / inp.shape[0]\n\nFor the gradients of the ReLU and our linear layer, we use the gradients of the loss with respect to the output (in out.g) and apply the chain rule to compute the gradients of the loss with respect to the input (in inp.g). The chain rule tells us that inp.g = relu'(inp) * out.g. The derivative of relu is either 0 (when inputs are negative) or 1 (when inputs are positive), so this gives us:\n\ndef relu_grad(inp, out):\n    # grad of relu with respect to input activations\n    inp.g = (inp&gt;0).float() * out.g\n\nThe scheme is the same to compute the gradients of the loss with respect to the inputs, weights, and bias in the linear layer:\n\ndef lin_grad(inp, out, w, b):\n    # grad of matmul with respect to input\n    inp.g = out.g @ w.t()\n    w.g = inp.t() @ out.g\n    b.g = out.g.sum(0)\n\nWe won’t linger on the mathematical formulas that define them since they’re not important for our purposes, but do check out Khan Academy’s excellent calculus lessons if you’re interested in this topic.\n\n\nSidebar: SymPy\nSymPy is a library for symbolic computation that is extremely useful library when working with calculus. Per the documentation:\n\nSymbolic computation deals with the computation of mathematical objects symbolically. This means that the mathematical objects are represented exactly, not approximately, and mathematical expressions with unevaluated variables are left in symbolic form.\n\nTo do symbolic computation, we first define a symbol, and then do a computation, like so:\n\nfrom sympy import symbols,diff\nsx,sy = symbols('sx sy')\ndiff(sx**2, sx)\n\n\\(\\displaystyle 2 sx\\)\n\n\nHere, SymPy has taken the derivative of x**2 for us! It can take the derivative of complicated compound expressions, simplify and factor equations, and much more. There’s really not much reason for anyone to do calculus manually nowadays—for calculating gradients, PyTorch does it for us, and for showing the equations, SymPy does it for us!\n\n\nEnd sidebar\nOnce we have have defined those functions, we can use them to write the backward pass. Since each gradient is automatically populated in the right tensor, we don’t need to store the results of those _grad functions anywhere—we just need to execute them in the reverse order of the forward pass, to make sure that in each function out.g exists:\n\ndef forward_and_backward(inp, targ):\n    # forward pass:\n    l1 = inp @ w1 + b1\n    l2 = relu(l1)\n    out = l2 @ w2 + b2\n    # we don't actually need the loss in backward!\n    loss = mse(out, targ)\n    \n    # backward pass:\n    mse_grad(out, targ)\n    lin_grad(l2, out, w2, b2)\n    relu_grad(l1, l2)\n    lin_grad(inp, l1, w1, b1)\n\nAnd now we can access the gradients of our model parameters in w1.g, b1.g, w2.g, and b2.g.\nWe have successfully defined our model—now let’s make it a bit more like a PyTorch module.\n\n\nRefactoring the Model\nThe three functions we used have two associated functions: a forward pass and a backward pass. Instead of writing them separately, we can create a class to wrap them together. That class can also store the inputs and outputs for the backward pass. This way, we will just have to call backward:\n\nclass Relu():\n    def __call__(self, inp):\n        self.inp = inp\n        self.out = inp.clamp_min(0.)\n        return self.out\n    \n    def backward(self): self.inp.g = (self.inp&gt;0).float() * self.out.g\n\n__call__ is a magic name in Python that will make our class callable. This is what will be executed when we type y = Relu()(x). We can do the same for our linear layer and the MSE loss:\n\nclass Lin():\n    def __init__(self, w, b): self.w,self.b = w,b\n        \n    def __call__(self, inp):\n        self.inp = inp\n        self.out = inp@self.w + self.b\n        return self.out\n    \n    def backward(self):\n        self.inp.g = self.out.g @ self.w.t()\n        self.w.g = self.inp.t() @ self.out.g\n        self.b.g = self.out.g.sum(0)\n\n\nclass Mse():\n    def __call__(self, inp, targ):\n        self.inp = inp\n        self.targ = targ\n        self.out = (inp.squeeze() - targ).pow(2).mean()\n        return self.out\n    \n    def backward(self):\n        x = (self.inp.squeeze()-self.targ).unsqueeze(-1)\n        self.inp.g = 2.*x/self.targ.shape[0]\n\nThen we can put everything in a model that we initiate with our tensors w1, b1, w2, b2:\n\nclass Model():\n    def __init__(self, w1, b1, w2, b2):\n        self.layers = [Lin(w1,b1), Relu(), Lin(w2,b2)]\n        self.loss = Mse()\n        \n    def __call__(self, x, targ):\n        for l in self.layers: x = l(x)\n        return self.loss(x, targ)\n    \n    def backward(self):\n        self.loss.backward()\n        for l in reversed(self.layers): l.backward()\n\nWhat is really nice about this refactoring and registering things as layers of our model is that the forward and backward passes are now really easy to write. If we want to instantiate our model, we just need to write:\n\nmodel = Model(w1, b1, w2, b2)\n\nThe forward pass can then be executed with:\n\nloss = model(x, y)\n\nAnd the backward pass with:\n\nmodel.backward()\n\n\n\nGoing to PyTorch\nThe Lin, Mse and Relu classes we wrote have a lot in common, so we could make them all inherit from the same base class:\n\nclass LayerFunction():\n    def __call__(self, *args):\n        self.args = args\n        self.out = self.forward(*args)\n        return self.out\n    \n    def forward(self):  raise Exception('not implemented')\n    def bwd(self):      raise Exception('not implemented')\n    def backward(self): self.bwd(self.out, *self.args)\n\nThen we just need to implement forward and bwd in each of our subclasses:\n\nclass Relu(LayerFunction):\n    def forward(self, inp): return inp.clamp_min(0.)\n    def bwd(self, out, inp): inp.g = (inp&gt;0).float() * out.g\n\n\nclass Lin(LayerFunction):\n    def __init__(self, w, b): self.w,self.b = w,b\n        \n    def forward(self, inp): return inp@self.w + self.b\n    \n    def bwd(self, out, inp):\n        inp.g = out.g @ self.w.t()\n        self.w.g = inp.t() @ self.out.g\n        self.b.g = out.g.sum(0)\n\n\nclass Mse(LayerFunction):\n    def forward (self, inp, targ): return (inp.squeeze() - targ).pow(2).mean()\n    def bwd(self, out, inp, targ): \n        inp.g = 2*(inp.squeeze()-targ).unsqueeze(-1) / targ.shape[0]\n\nThe rest of our model can be the same as before. This is getting closer and closer to what PyTorch does. Each basic function we need to differentiate is written as a torch.autograd.Function object that has a forward and a backward method. PyTorch will then keep trace of any computation we do to be able to properly run the backward pass, unless we set the requires_grad attribute of our tensors to False.\nWriting one of these is (almost) as easy as writing our original classes. The difference is that we choose what to save and what to put in a context variable (so that we make sure we don’t save anything we don’t need), and we return the gradients in the backward pass. It’s very rare to have to write your own Function but if you ever need something exotic or want to mess with the gradients of a regular function, here is how to write one:\n\nfrom torch.autograd import Function\n\nclass MyRelu(Function):\n    @staticmethod\n    def forward(ctx, i):\n        result = i.clamp_min(0.)\n        ctx.save_for_backward(i)\n        return result\n    \n    @staticmethod\n    def backward(ctx, grad_output):\n        i, = ctx.saved_tensors\n        return grad_output * (i&gt;0).float()\n\nThe structure used to build a more complex model that takes advantage of those Functions is a torch.nn.Module. This is the base structure for all models, and all the neural nets you have seen up until now inherited from that class. It mostly helps to register all the trainable parameters, which as we’ve seen can be used in the training loop.\nTo implement an nn.Module you just need to:\n\nMake sure the superclass __init__ is called first when you initialize it.\nDefine any parameters of the model as attributes with nn.Parameter.\nDefine a forward function that returns the output of your model.\n\nAs an example, here is the linear layer from scratch:\n\nimport torch.nn as nn\n\nclass LinearLayer(nn.Module):\n    def __init__(self, n_in, n_out):\n        super().__init__()\n        self.weight = nn.Parameter(torch.randn(n_out, n_in) * sqrt(2/n_in))\n        self.bias = nn.Parameter(torch.zeros(n_out))\n    \n    def forward(self, x): return x @ self.weight.t() + self.bias\n\nAs you see, this class automatically keeps track of what parameters have been defined:\n\nlin = LinearLayer(10,2)\np1,p2 = lin.parameters()\np1.shape,p2.shape\n\n(torch.Size([2, 10]), torch.Size([2]))\n\n\nIt is thanks to this feature of nn.Module that we can just say opt.step() and have an optimizer loop through the parameters and update each one.\nNote that in PyTorch, the weights are stored as an n_out x n_in matrix, which is why we have the transpose in the forward pass.\nBy using the linear layer from PyTorch (which uses the Kaiming initialization as well), the model we have been building up during this chapter can be written like this:\n\nclass Model(nn.Module):\n    def __init__(self, n_in, nh, n_out):\n        super().__init__()\n        self.layers = nn.Sequential(\n            nn.Linear(n_in,nh), nn.ReLU(), nn.Linear(nh,n_out))\n        self.loss = mse\n        \n    def forward(self, x, targ): return self.loss(self.layers(x).squeeze(), targ)\n\nIn the last chapter, we will start from such a model and see how to build a training loop from scratch and refactor it to what we’ve been using in previous chapters.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Neural Net from the Foundations</span>"
    ]
  },
  {
    "objectID": "foundations.html#conclusion",
    "href": "foundations.html#conclusion",
    "title": "17  A Neural Net from the Foundations",
    "section": "17.3 Conclusion",
    "text": "17.3 Conclusion\nIn this chapter we explored the foundations of deep learning, beginning with matrix multiplication and moving on to implementing the forward and backward passes of a neural net from scratch. We then refactored our code to show how PyTorch works beneath the hood.\nHere are a few things to remember:\n\nA neural net is basically a bunch of matrix multiplications with nonlinearities in between.\nPython is slow, so to write fast code we have to vectorize it and take advantage of techniques such as elementwise arithmetic and broadcasting.\nTwo tensors are broadcastable if the dimensions starting from the end and going backward match (if they are the same, or one of them is 1). To make tensors broadcastable, we may need to add dimensions of size 1 with unsqueeze or a None index.\nProperly initializing a neural net is crucial to get training started. Kaiming initialization should be used when we have ReLU nonlinearities.\nThe backward pass is the chain rule applied multiple times, computing the gradients from the output of our model and going back, one layer at a time.\nWhen subclassing nn.Module (if not using fastai’s Module) we have to call the superclass __init__ method in our __init__ method and we have to define a forward function that takes an input and returns the desired result.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Neural Net from the Foundations</span>"
    ]
  },
  {
    "objectID": "foundations.html#questionnaire",
    "href": "foundations.html#questionnaire",
    "title": "17  A Neural Net from the Foundations",
    "section": "17.4 Questionnaire",
    "text": "17.4 Questionnaire\n\nWrite the Python code to implement a single neuron.\nWrite the Python code to implement ReLU.\nWrite the Python code for a dense layer in terms of matrix multiplication.\nWrite the Python code for a dense layer in plain Python (that is, with list comprehensions and functionality built into Python).\nWhat is the “hidden size” of a layer?\nWhat does the t method do in PyTorch?\nWhy is matrix multiplication written in plain Python very slow?\nIn matmul, why is ac==br?\nIn Jupyter Notebook, how do you measure the time taken for a single cell to execute?\nWhat is “elementwise arithmetic”?\nWrite the PyTorch code to test whether every element of a is greater than the corresponding element of b.\nWhat is a rank-0 tensor? How do you convert it to a plain Python data type?\nWhat does this return, and why? tensor([1,2]) + tensor([1])\nWhat does this return, and why? tensor([1,2]) + tensor([1,2,3])\nHow does elementwise arithmetic help us speed up matmul?\nWhat are the broadcasting rules?\nWhat is expand_as? Show an example of how it can be used to match the results of broadcasting.\nHow does unsqueeze help us to solve certain broadcasting problems?\nHow can we use indexing to do the same operation as unsqueeze?\nHow do we show the actual contents of the memory used for a tensor?\nWhen adding a vector of size 3 to a matrix of size 3×3, are the elements of the vector added to each row or each column of the matrix? (Be sure to check your answer by running this code in a notebook.)\nDo broadcasting and expand_as result in increased memory use? Why or why not?\nImplement matmul using Einstein summation.\nWhat does a repeated index letter represent on the left-hand side of einsum?\nWhat are the three rules of Einstein summation notation? Why?\nWhat are the forward pass and backward pass of a neural network?\nWhy do we need to store some of the activations calculated for intermediate layers in the forward pass?\nWhat is the downside of having activations with a standard deviation too far away from 1?\nHow can weight initialization help avoid this problem?\nWhat is the formula to initialize weights such that we get a standard deviation of 1 for a plain linear layer, and for a linear layer followed by ReLU?\nWhy do we sometimes have to use the squeeze method in loss functions?\nWhat does the argument to the squeeze method do? Why might it be important to include this argument, even though PyTorch does not require it?\nWhat is the “chain rule”? Show the equation in either of the two forms presented in this chapter.\nShow how to calculate the gradients of mse(lin(l2, w2, b2), y) using the chain rule.\nWhat is the gradient of ReLU? Show it in math or code. (You shouldn’t need to commit this to memory—try to figure it using your knowledge of the shape of the function.)\nIn what order do we need to call the *_grad functions in the backward pass? Why?\nWhat is __call__?\nWhat methods must we implement when writing a torch.autograd.Function?\nWrite nn.Linear from scratch, and test it works.\nWhat is the difference between nn.Module and fastai’s Module?\n\n\nFurther Research\n\nImplement ReLU as a torch.autograd.Function and train a model with it.\nIf you are mathematically inclined, find out what the gradients of a linear layer are in mathematical notation. Map that to the implementation we saw in this chapter.\nLearn about the unfold method in PyTorch, and use it along with matrix multiplication to implement your own 2D convolution function. Then train a CNN that uses it.\nImplement everything in this chapter using NumPy instead of PyTorch.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>A Neural Net from the Foundations</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practical Deep Learning for Coders",
    "section": "",
    "text": "Preface\nThis is a preview version of Deep Learning for Coders with Fastai and PyTorch: AI Applications Without a PhD. Note that chapters shown in italics in the sidebar are only available as a preview of the first few paragraphs. The full content of all chapters is available for free as Jupyter Notebooks here with only basic formatting. A nicely typeset version can be purchased from Amazon.\n\nHere’s a list of all the full chapters available here:\n\n1  Your Deep Learning Journey: Your Deep Learning Journey\n4  Under the Hood: Training a Digit Classifier: Under the Hood: Training a Digit Classifier\n13  Convolutional Neural Networks: Convolutional Neural Networks\n14  ResNets: ResNets\n16  The Training Process: The Training Process\n17  A Neural Net from the Foundations: A Neural Net from the Foundations\n\nThis book is designed to go with our free deep learning course, available at course.fast.ai.\nOnce you’ve finished the first eight chapters of the book, or completed course.fast.ai, you’ll be ready for our new course, From Deep Learning Foundations to Stable Diffusion, which starts on Oct 11th 2022 (Australian time; Oct 10th US time). You can sign up here. If you’re an open source author you may qualify for a scholarship – details here.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "book2.html",
    "href": "book2.html",
    "title": "2  From Model to Production",
    "section": "",
    "text": "2.1 The Practice of Deep Learning\nWe’ve seen that deep learning can solve a lot of challenging problems quickly and with little code. As a beginner, there’s a sweet spot of problems that are similar enough to our example problems that you can very quickly get extremely useful results. However, deep learning isn’t magic! The same 6 lines of code won’t work for every problem anyone can think of today. Underestimating the constraints and overestimating the capabilities of deep learning may lead to frustratingly poor results, at least until you gain some experience and can solve the problems that arise. Conversely, overestimating the constraints and underestimating the capabilities of deep learning may mean you do not attempt a solvable problem because you talk yourself out of it.\nWe often talk to people who underestimate both the constraints and the capabilities of deep learning. Both of these can be problems: underestimating the capabilities means that you might not even try things that could be very beneficial, and underestimating the constraints might mean that you fail to consider and react to important issues.\nThe best thing to do is to keep an open mind. If you remain open to the possibility that deep learning might solve part of your problem with less data or complexity than you expect, then it is possible to design a process where you can find the specific capabilities and constraints related to your particular problem as you work through the process. This doesn’t mean making any risky bets — we will show you how you can gradually roll out models so that they don’t create significant risks, and can even backtest them prior to putting them in production.\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>*From Model to Production*</span>"
    ]
  },
  {
    "objectID": "book3.html",
    "href": "book3.html",
    "title": "3  AI and Data Ethics",
    "section": "",
    "text": "Sidebar: Acknowledgement: Dr. Rachel Thomas\nThis chapter was co-authored by Dr. Rachel Thomas, the cofounder of fast.ai, and founding director of the Center for Applied Data Ethics at the University of San Francisco. It largely follows a subset of the syllabus she developed for the Introduction to Data Ethics course.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>AI and Data Ethics</span>"
    ]
  },
  {
    "objectID": "book3.html#key-examples-for-data-ethics",
    "href": "book3.html#key-examples-for-data-ethics",
    "title": "3  AI and Data Ethics",
    "section": "3.1 Key Examples for Data Ethics",
    "text": "3.1 Key Examples for Data Ethics\nWe are going to start with three specific examples that illustrate three common ethical issues in tech:\n\nRecourse processes—Arkansas’s buggy healthcare algorithms left patients stranded.\nFeedback loops—YouTube’s recommendation system helped unleash a conspiracy theory boom.\nBias—When a traditionally African-American name is searched for on Google, it displays ads for criminal background checks.\n\nIn fact, for every concept that we introduce in this chapter, we are going to provide at least one specific example. For each one, think about what you could have done in this situation, and what kinds of obstructions there might have been to you getting that done. How would you deal with them? What would you look out for?\n\nBugs and Recourse: Buggy Algorithm Used for Healthcare Benefits\nThe Verge investigated software used in over half of the US states to determine how much healthcare people receive, and documented their findings in the article “What Happens When an Algorithm Cuts Your Healthcare”. After implementation of the algorithm in Arkansas, hundreds of people (many with severe disabilities) had their healthcare drastically cut. For instance, Tammy Dobbs, a woman with cerebral palsy who needs an aid to help her to get out of bed, to go to the bathroom, to get food, and more, had her hours of help suddenly reduced by 20 hours a week. She couldn’t get any explanation for why her healthcare was cut. Eventually, a court case revealed that there were mistakes in the software implementation of the algorithm, negatively impacting people with diabetes or cerebral palsy. However, Dobbs and many other people reliant on these healthcare benefits live in fear that their benefits could again be cut suddenly and inexplicably.\n\n\nFeedback Loops: YouTube’s Recommendation System\nFeedback loops can occur when your model is controlling the next round of data you get. The data that is returned quickly becomes flawed by the software itself.\nFor instance, YouTube has 1.9 billion users, who watch over 1 billion hours of YouTube videos a day. Its recommendation algorithm (built by Google), which was designed to optimize watch time, is responsible for around 70% of the content that is watched. But there was a problem: it led to out-of-control feedback loops, leading the New York Times to run the headline “YouTube Unleashed a Conspiracy Theory Boom. Can It Be Contained?”. Ostensibly recommendation systems are predicting what content people will like, but they also have a lot of power in determining what content people even see.\n\n\nBias: Professor Latanya Sweeney “Arrested”\nDr. Latanya Sweeney is a professor at Harvard and director of the university’s data privacy lab. In the paper “Discrimination in Online Ad Delivery” (see &lt;&gt;) she describes her discovery that Googling her name resulted in advertisements saying “Latanya Sweeney, arrested?” even though she is the only known Latanya Sweeney and has never been arrested. However when she Googled other names, such as “Kirsten Lindquist,” she got more neutral ads, even though Kirsten Lindquist has been arrested three times.\n\nBeing a computer scientist, she studied this systematically, and looked at over 2000 names. She found a clear pattern where historically Black names received advertisements suggesting that the person had a criminal record, whereas, white names had more neutral advertisements.\nThis is an example of bias. It can make a big difference to people’s lives—for instance, if a job applicant is Googled it may appear that they have a criminal record when they do not.\n\n\nWhy Does This Matter?\nOne very natural reaction to considering these issues is: “So what? What’s that got to do with me? I’m a data scientist, not a politician. I’m not one of the senior executives at my company who make the decisions about what we do. I’m just trying to build the most predictive model I can.”\nThese are very reasonable questions. But we’re going to try to convince you that the answer is that everybody who is training models absolutely needs to consider how their models will be used, and consider how to best ensure that they are used as positively as possible. There are things you can do. And if you don’t do them, then things can go pretty badly.\nOne particularly hideous example of what happens when technologists focus on technology at all costs is the story of IBM and Nazi Germany. In 2001, a Swiss judge ruled that it was not unreasonable “to deduce that IBM’s technical assistance facilitated the tasks of the Nazis in the commission of their crimes against humanity, acts also involving accountancy and classification by IBM machines and utilized in the concentration camps themselves.”\nIBM, you see, supplied the Nazis with data tabulation products necessary to track the extermination of Jews and other groups on a massive scale. This was driven from the top of the company, with marketing to Hitler and his leadership team. Company President Thomas Watson personally approved the 1939 release of special IBM alphabetizing machines to help organize the deportation of Polish Jews. Pictured in &lt;&gt; is Adolf Hitler (far left) meeting with IBM CEO Tom Watson Sr. (second from left), shortly before Hitler awarded Watson a special “Service to the Reich” medal in 1937.\n\nBut this was not an isolated incident—the organization’s involvement was extensive. IBM and its subsidiaries provided regular training and maintenance onsite at the concentration camps: printing off cards, configuring machines, and repairing them as they broke frequently. IBM set up categorizations on its punch card system for the way that each person was killed, which group they were assigned to, and the logistical information necessary to track them through the vast Holocaust system. IBM’s code for Jews in the concentration camps was 8: some 6,000,000 were killed. Its code for Romanis was 12 (they were labeled by the Nazis as “asocials,” with over 300,000 killed in the Zigeunerlager, or “Gypsy camp”). General executions were coded as 4, death in the gas chambers as 6.\n\nOf course, the project managers and engineers and technicians involved were just living their ordinary lives. Caring for their families, going to the church on Sunday, doing their jobs the best they could. Following orders. The marketers were just doing what they could to meet their business development goals. As Edwin Black, author of IBM and the Holocaust (Dialog Press) observed: “To the blind technocrat, the means were more important than the ends. The destruction of the Jewish people became even less important because the invigorating nature of IBM’s technical achievement was only heightened by the fantastical profits to be made at a time when bread lines stretched across the world.”\nStep back for a moment and consider: How would you feel if you discovered that you had been part of a system that ended up hurting society? Would you be open to finding out? How can you help make sure this doesn’t happen? We have described the most extreme situation here, but there are many negative societal consequences linked to AI and machine learning being observed today, some of which we’ll describe in this chapter.\nIt’s not just a moral burden, either. Sometimes technologists pay very directly for their actions. For instance, the first person who was jailed as a result of the Volkswagen scandal, where the car company was revealed to have cheated on its diesel emissions tests, was not the manager that oversaw the project, or an executive at the helm of the company. It was one of the engineers, James Liang, who just did what he was told.\nOf course, it’s not all bad—if a project you are involved in turns out to make a huge positive impact on even one person, this is going to make you feel pretty great!\nOkay, so hopefully we have convinced you that you ought to care. But what should you do? As data scientists, we’re naturally inclined to focus on making our models better by optimizing some metric or other. But optimizing that metric may not actually lead to better outcomes. And even if it does help create better outcomes, it almost certainly won’t be the only thing that matters. Consider the pipeline of steps that occurs between the development of a model or an algorithm by a researcher or practitioner, and the point at which this work is actually used to make some decision. This entire pipeline needs to be considered as a whole if we’re to have a hope of getting the kinds of outcomes we want.\nNormally there is a very long chain from one end to the other. This is especially true if you are a researcher, where you might not even know if your research will ever get used for anything, or if you’re involved in data collection, which is even earlier in the pipeline. But no one is better placed to inform everyone involved in this chain about the capabilities, constraints, and details of your work than you are. Although there’s no “silver bullet” that can ensure your work is used the right way, by getting involved in the process, and asking the right questions, you can at the very least ensure that the right issues are being considered.\nSometimes, the right response to being asked to do a piece of work is to just say “no.” Often, however, the response we hear is, “If I don’t do it, someone else will.” But consider this: if you’ve been picked for the job, you’re the best person they’ve found to do it—so if you don’t do it, the best person isn’t working on that project. If the first five people they ask all say no too, even better!",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>AI and Data Ethics</span>"
    ]
  },
  {
    "objectID": "book3.html#integrating-machine-learning-with-product-design",
    "href": "book3.html#integrating-machine-learning-with-product-design",
    "title": "3  AI and Data Ethics",
    "section": "3.2 Integrating Machine Learning with Product Design",
    "text": "3.2 Integrating Machine Learning with Product Design\nPresumably the reason you’re doing this work is because you hope it will be used for something. Otherwise, you’re just wasting your time. So, let’s start with the assumption that your work will end up somewhere. Now, as you are collecting your data and developing your model, you are making lots of decisions. What level of aggregation will you store your data at? What loss function should you use? What validation and training sets should you use? Should you focus on simplicity of implementation, speed of inference, or accuracy of the model? How will your model handle out-of-domain data items? Can it be fine-tuned, or must it be retrained from scratch over time?\nThese are not just algorithm questions. They are data product design questions. But the product managers, executives, judges, journalists, doctors… whoever ends up developing and using the system of which your model is a part will not be well-placed to understand the decisions that you made, let alone change them.\nFor instance, two studies found that Amazon’s facial recognition software produced inaccurate and racially biased results. Amazon claimed that the researchers should have changed the default parameters, without explaining how this would have changed the biased results. Furthermore, it turned out that Amazon was not instructing police departments that used its software to do this either. There was, presumably, a big distance between the researchers that developed these algorithms and the Amazon documentation staff that wrote the guidelines provided to the police. A lack of tight integration led to serious problems for society at large, the police, and Amazon themselves. It turned out that their system erroneously matched 28 members of congress to criminal mugshots! (And the Congresspeople wrongly matched to criminal mugshots were disproportionately people of color, as seen in &lt;&gt;.)\n\nData scientists need to be part of a cross-disciplinary team. And researchers need to work closely with the kinds of people who will end up using their research. Better still is if the domain experts themselves have learned enough to be able to train and debug some models themselves—hopefully there are a few of you reading this book right now!\nThe modern workplace is a very specialized place. Everybody tends to have well-defined jobs to perform. Especially in large companies, it can be hard to know what all the pieces of the puzzle are. Sometimes companies even intentionally obscure the overall project goals that are being worked on, if they know that their employees are not going to like the answers. This is sometimes done by compartmentalising pieces as much as possible.\nIn other words, we’re not saying that any of this is easy. It’s hard. It’s really hard. We all have to do our best. And we have often seen that the people who do get involved in the higher-level context of these projects, and attempt to develop cross-disciplinary capabilities and teams, become some of the most important and well rewarded members of their organizations. It’s the kind of work that tends to be highly appreciated by senior executives, even if it is sometimes considered rather uncomfortable by middle management.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>AI and Data Ethics</span>"
    ]
  },
  {
    "objectID": "book3.html#topics-in-data-ethics",
    "href": "book3.html#topics-in-data-ethics",
    "title": "3  AI and Data Ethics",
    "section": "3.3 Topics in Data Ethics",
    "text": "3.3 Topics in Data Ethics\nData ethics is a big field, and we can’t cover everything. Instead, we’re going to pick a few topics that we think are particularly relevant:\n\nThe need for recourse and accountability\nFeedback loops\nBias\nDisinformation\n\nLet’s look at each in turn.\n\nRecourse and Accountability\nIn a complex system, it is easy for no one person to feel responsible for outcomes. While this is understandable, it does not lead to good results. In the earlier example of the Arkansas healthcare system in which a bug led to people with cerebral palsy losing access to needed care, the creator of the algorithm blamed government officials, and government officials blamed those who implemented the software. NYU professor Danah Boyd described this phenomenon: “Bureaucracy has often been used to shift or evade responsibility… Today’s algorithmic systems are extending bureaucracy.”\nAn additional reason why recourse is so necessary is because data often contains errors. Mechanisms for audits and error correction are crucial. A database of suspected gang members maintained by California law enforcement officials was found to be full of errors, including 42 babies who had been added to the database when they were less than 1 year old (28 of whom were marked as “admitting to being gang members”). In this case, there was no process in place for correcting mistakes or removing people once they’d been added. Another example is the US credit report system: in a large-scale study of credit reports by the Federal Trade Commission (FTC) in 2012, it was found that 26% of consumers had at least one mistake in their files, and 5% had errors that could be devastating. Yet, the process of getting such errors corrected is incredibly slow and opaque. When public radio reporter Bobby Allyn discovered that he was erroneously listed as having a firearms conviction, it took him “more than a dozen phone calls, the handiwork of a county court clerk and six weeks to solve the problem. And that was only after I contacted the company’s communications department as a journalist.”\nAs machine learning practitioners, we do not always think of it as our responsibility to understand how our algorithms end up being implemented in practice. But we need to.\n\n\nFeedback Loops\nWe explained in &lt;&gt; how an algorithm can interact with its environment to create a feedback loop, making predictions that reinforce actions taken in the real world, which lead to predictions even more pronounced in the same direction. As an example, let’s again consider YouTube’s recommendation system. A couple of years ago the Google team talked about how they had introduced reinforcement learning (closely related to deep learning, but where your loss function represents a result potentially a long time after an action occurs) to improve YouTube’s recommendation system. They described how they used an algorithm that made recommendations such that watch time would be optimized.\nHowever, human beings tend to be drawn to controversial content. This meant that videos about things like conspiracy theories started to get recommended more and more by the recommendation system. Furthermore, it turns out that the kinds of people that are interested in conspiracy theories are also people that watch a lot of online videos! So, they started to get drawn more and more toward YouTube. The increasing number of conspiracy theorists watching videos on YouTube resulted in the algorithm recommending more and more conspiracy theory and other extremist content, which resulted in more extremists watching videos on YouTube, and more people watching YouTube developing extremist views, which led to the algorithm recommending more extremist content… The system was spiraling out of control.\nAnd this phenomenon was not contained to this particular type of content. In June 2019 the New York Times published an article on YouTube’s recommendation system, titled “On YouTube’s Digital Playground, an Open Gate for Pedophiles”. The article started with this chilling story:\n\n: Christiane C. didn’t think anything of it when her 10-year-old daughter and a friend uploaded a video of themselves playing in a backyard pool… A few days later… the video had thousands of views. Before long, it had ticked up to 400,000… “I saw the video again and I got scared by the number of views,” Christiane said. She had reason to be. YouTube’s automated recommendation system… had begun showing the video to users who watched other videos of prepubescent, partially clothed children, a team of researchers has found.\n\n\n: On its own, each video might be perfectly innocent, a home movie, say, made by a child. Any revealing frames are fleeting and appear accidental. But, grouped together, their shared features become unmistakable.\n\nYouTube’s recommendation algorithm had begun curating playlists for pedophiles, picking out innocent home videos that happened to contain prepubescent, partially clothed children.\nNo one at Google planned to create a system that turned family videos into porn for pedophiles. So what happened?\nPart of the problem here is the centrality of metrics in driving a financially important system. When an algorithm has a metric to optimize, as you have seen, it will do everything it can to optimize that number. This tends to lead to all kinds of edge cases, and humans interacting with a system will search for, find, and exploit these edge cases and feedback loops for their advantage.\nThere are signs that this is exactly what has happened with YouTube’s recommendation system. The Guardian ran an article called “How an ex-YouTube Insider Investigated its Secret Algorithm” about Guillaume Chaslot, an ex-YouTube engineer who created AlgoTransparency, which tracks these issues. Chaslot published the chart in &lt;&gt;, following the release of Robert Mueller’s “Report on the Investigation Into Russian Interference in the 2016 Presidential Election.”\n\nRussia Today’s coverage of the Mueller report was an extreme outlier in terms of how many channels were recommending it. This suggests the possibility that Russia Today, a state-owned Russia media outlet, has been successful in gaming YouTube’s recommendation algorithm. Unfortunately, the lack of transparency of systems like this makes it hard to uncover the kinds of problems that we’re discussing.\nOne of our reviewers for this book, Aurélien Géron, led YouTube’s video classification team from 2013 to 2016 (well before the events discussed here). He pointed out that it’s not just feedback loops involving humans that are a problem. There can also be feedback loops without humans! He told us about an example from YouTube:\n\n: One important signal to classify the main topic of a video is the channel it comes from. For example, a video uploaded to a cooking channel is very likely to be a cooking video. But how do we know what topic a channel is about? Well… in part by looking at the topics of the videos it contains! Do you see the loop? For example, many videos have a description which indicates what camera was used to shoot the video. As a result, some of these videos might get classified as videos about “photography.” If a channel has such a misclassified video, it might be classified as a “photography” channel, making it even more likely for future videos on this channel to be wrongly classified as “photography.” This could even lead to runaway virus-like classifications! One way to break this feedback loop is to classify videos with and without the channel signal. Then when classifying the channels, you can only use the classes obtained without the channel signal. This way, the feedback loop is broken.\n\nThere are positive examples of people and organizations attempting to combat these problems. Evan Estola, lead machine learning engineer at Meetup, discussed the example of men expressing more interest than women in tech meetups. taking gender into account could therefore cause Meetup’s algorithm to recommend fewer tech meetups to women, and as a result, fewer women would find out about and attend tech meetups, which could cause the algorithm to suggest even fewer tech meetups to women, and so on in a self-reinforcing feedback loop. So, Evan and his team made the ethical decision for their recommendation algorithm to not create such a feedback loop, by explicitly not using gender for that part of their model. It is encouraging to see a company not just unthinkingly optimize a metric, but consider its impact. According to Evan, “You need to decide which feature not to use in your algorithm… the most optimal algorithm is perhaps not the best one to launch into production.”\nWhile Meetup chose to avoid such an outcome, Facebook provides an example of allowing a runaway feedback loop to run wild. Like YouTube, it tends to radicalize users interested in one conspiracy theory by introducing them to more. As Renee DiResta, a researcher on proliferation of disinformation, writes:\n\n: Once people join a single conspiracy-minded [Facebook] group, they are algorithmically routed to a plethora of others. Join an anti-vaccine group, and your suggestions will include anti-GMO, chemtrail watch, flat Earther (yes, really), and “curing cancer naturally groups. Rather than pulling a user out of the rabbit hole, the recommendation engine pushes them further in.”\n\nIt is extremely important to keep in mind that this kind of behavior can happen, and to either anticipate a feedback loop or take positive action to break it when you see the first signs of it in your own projects. Another thing to keep in mind is bias, which, as we discussed briefly in the previous chapter, can interact with feedback loops in very troublesome ways.\n\n\nBias\nDiscussions of bias online tend to get pretty confusing pretty fast. The word “bias” means so many different things. Statisticians often think when data ethicists are talking about bias that they’re talking about the statistical definition of the term bias. But they’re not. And they’re certainly not talking about the biases that appear in the weights and biases which are the parameters of your model!\nWhat they’re talking about is the social science concept of bias. In “A Framework for Understanding Unintended Consequences of Machine Learning” MIT’s Harini Suresh and John Guttag describe six types of bias in machine learning, summarized in &lt;&gt; from their paper.\n\nWe’ll discuss four of these types of bias, those that we’ve found most helpful in our own work (see the paper for details on the others).\n\nHistorical bias\nHistorical bias comes from the fact that people are biased, processes are biased, and society is biased. Suresh and Guttag say: “Historical bias is a fundamental, structural issue with the first step of the data generation process and can exist even given perfect sampling and feature selection.”\nFor instance, here are a few examples of historical race bias in the US, from the New York Times article “Racial Bias, Even When We Have Good Intentions” by the University of Chicago’s Sendhil Mullainathan:\n\nWhen doctors were shown identical files, they were much less likely to recommend cardiac catheterization (a helpful procedure) to Black patients.\nWhen bargaining for a used car, Black people were offered initial prices $700 higher and received far smaller concessions.\nResponding to apartment rental ads on Craigslist with a Black name elicited fewer responses than with a white name.\nAn all-white jury was 16 percentage points more likely to convict a Black defendant than a white one, but when a jury had one Black member it convicted both at the same rate.\n\nThe COMPAS algorithm, widely used for sentencing and bail decisions in the US, is an example of an important algorithm that, when tested by ProPublica, showed clear racial bias in practice (&lt;&gt;).\n\nAny dataset involving humans can have this kind of bias: medical data, sales data, housing data, political data, and so on. Because underlying bias is so pervasive, bias in datasets is very pervasive. Racial bias even turns up in computer vision, as shown in the example of autocategorized photos shared on Twitter by a Google Photos user shown in &lt;&gt;.\n\nYes, that is showing what you think it is: Google Photos classified a Black user’s photo with their friend as “gorillas”! This algorithmic misstep got a lot of attention in the media. “We’re appalled and genuinely sorry that this happened,” a company spokeswoman said. “There is still clearly a lot of work to do with automatic image labeling, and we’re looking at how we can prevent these types of mistakes from happening in the future.”\nUnfortunately, fixing problems in machine learning systems when the input data has problems is hard. Google’s first attempt didn’t inspire confidence, as coverage by The Guardian suggested (&lt;&gt;).\n\nThese kinds of problems are certainly not limited to just Google. MIT researchers studied the most popular online computer vision APIs to see how accurate they were. But they didn’t just calculate a single accuracy number—instead, they looked at the accuracy across four different groups, as illustrated in &lt;&gt;.\n\nIBM’s system, for instance, had a 34.7% error rate for darker females, versus 0.3% for lighter males—over 100 times more errors! Some people incorrectly reacted to these experiments by claiming that the difference was simply because darker skin is harder for computers to recognize. However, what actually happened was that, after the negative publicity that this result created, all of the companies in question dramatically improved their models for darker skin, such that one year later they were nearly as good as for lighter skin. So what this actually showed is that the developers failed to utilize datasets containing enough darker faces, or test their product with darker faces.\nOne of the MIT researchers, Joy Buolamwini, warned: “We have entered the age of automation overconfident yet underprepared. If we fail to make ethical and inclusive artificial intelligence, we risk losing gains made in civil rights and gender equity under the guise of machine neutrality.”\nPart of the issue appears to be a systematic imbalance in the makeup of popular datasets used for training models. The abstract to the paper “No Classification Without Representation: Assessing Geodiversity Issues in Open Data Sets for the Developing World” by Shreya Shankar et al. states, “We analyze two large, publicly available image data sets to assess geo-diversity and find that these data sets appear to exhibit an observable amerocentric and eurocentric representation bias. Further, we analyze classifiers trained on these data sets to assess the impact of these training distributions and find strong differences in the relative performance on images from different locales.” &lt;&gt; shows one of the charts from the paper, showing the geographic makeup of what was, at the time (and still are, as this book is being written) the two most important image datasets for training models.\n\nThe vast majority of the images are from the United States and other Western countries, leading to models trained on ImageNet performing worse on scenes from other countries and cultures. For instance, research found that such models are worse at identifying household items (such as soap, spices, sofas, or beds) from lower-income countries. &lt;&gt; shows an image from the paper, “Does Object Recognition Work for Everyone?” by Terrance DeVries et al. of Facebook AI Research that illustrates this point.\n\nIn this example, we can see that the lower-income soap example is a very long way away from being accurate, with every commercial image recognition service predicting “food” as the most likely answer!\nAs we will discuss shortly, in addition, the vast majority of AI researchers and developers are young white men. Most projects that we have seen do most user testing using friends and families of the immediate product development group. Given this, the kinds of problems we just discussed should not be surprising.\nSimilar historical bias is found in the texts used as data for natural language processing models. This crops up in downstream machine learning tasks in many ways. For instance, it was widely reported that until last year Google Translate showed systematic bias in how it translated the Turkish gender-neutral pronoun “o” into English: when applied to jobs which are often associated with males it used “he,” and when applied to jobs which are often associated with females it used “she” (&lt;&gt;).\n\nWe also see this kind of bias in online advertisements. For instance, a study in 2019 by Muhammad Ali et al. found that even when the person placing the ad does not intentionally discriminate, Facebook will show ads to very different audiences based on race and gender. Housing ads with the same text, but picture either a white or a Black family, were shown to racially different audiences.\n\n\nMeasurement bias\nIn the paper “Does Machine Learning Automate Moral Hazard and Error” in American Economic Review, Sendhil Mullainathan and Ziad Obermeyer look at a model that tries to answer the question: using historical electronic health record (EHR) data, what factors are most predictive of stroke? These are the top predictors from the model:\n\nPrior stroke\nCardiovascular disease\nAccidental injury\nBenign breast lump\nColonoscopy\nSinusitis\n\nHowever, only the top two have anything to do with a stroke! Based on what we’ve studied so far, you can probably guess why. We haven’t really measured stroke, which occurs when a region of the brain is denied oxygen due to an interruption in the blood supply. What we’ve measured is who had symptoms, went to a doctor, got the appropriate tests, and received a diagnosis of stroke. Actually having a stroke is not the only thing correlated with this complete list—it’s also correlated with being the kind of person who actually goes to the doctor (which is influenced by who has access to healthcare, can afford their co-pay, doesn’t experience racial or gender-based medical discrimination, and more)! If you are likely to go to the doctor for an accidental injury, then you are likely to also go the doctor when you are having a stroke.\nThis is an example of measurement bias. It occurs when our models make mistakes because we are measuring the wrong thing, or measuring it in the wrong way, or incorporating that measurement into the model inappropriately.\n\n\nAggregation bias\nAggregation bias occurs when models do not aggregate data in a way that incorporates all of the appropriate factors, or when a model does not include the necessary interaction terms, nonlinearities, or so forth. This can particularly occur in medical settings. For instance, the way diabetes is treated is often based on simple univariate statistics and studies involving small groups of heterogeneous people. Analysis of results is often done in a way that does not take account of different ethnicities or genders. However, it turns out that diabetes patients have different complications across ethnicities, and HbA1c levels (widely used to diagnose and monitor diabetes) differ in complex ways across ethnicities and genders. This can result in people being misdiagnosed or incorrectly treated because medical decisions are based on a model that does not include these important variables and interactions.\n\n\nRepresentation bias\nThe abstract of the paper “Bias in Bios: A Case Study of Semantic Representation Bias in a High-Stakes Setting” by Maria De-Arteaga et al. notes that there is gender imbalance in occupations (e.g., females are more likely to be nurses, and males are more likely to be pastors), and says that: “differences in true positive rates between genders are correlated with existing gender imbalances in occupations, which may compound these imbalances.”\nIn other words, the researchers noticed that models predicting occupation did not only reflect the actual gender imbalance in the underlying population, but actually amplified it! This type of representation bias is quite common, particularly for simple models. When there is some clear, easy-to-see underlying relationship, a simple model will often simply assume that this relationship holds all the time. As &lt;&gt; from the paper shows, for occupations that had a higher percentage of females, the model tended to overestimate the prevalence of that occupation.\n\nFor example, in the training dataset 14.6% of surgeons were women, yet in the model predictions only 11.6% of the true positives were women. The model is thus amplifying the bias existing in the training set.\nNow that we’ve seen that those biases exist, what can we do to mitigate them?\n\n\n\nAddressing different types of bias\nDifferent types of bias require different approaches for mitigation. While gathering a more diverse dataset can address representation bias, this would not help with historical bias or measurement bias. All datasets contain bias. There is no such thing as a completely debiased dataset. Many researchers in the field have been converging on a set of proposals to enable better documentation of the decisions, context, and specifics about how and why a particular dataset was created, what scenarios it is appropriate to use in, and what the limitations are. This way, those using a particular dataset will not be caught off guard by its biases and limitations.\nWe often hear the question—“Humans are biased, so does algorithmic bias even matter?” This comes up so often, there must be some reasoning that makes sense to the people that ask it, but it doesn’t seem very logically sound to us! Independently of whether this is logically sound, it’s important to realize that algorithms (particularly machine learning algorithms!) and people are different. Consider these points about machine learning algorithms:\n\nMachine learning can create feedback loops:: Small amounts of bias can rapidly increase exponentially due to feedback loops.\nMachine learning can amplify bias:: Human bias can lead to larger amounts of machine learning bias.\nAlgorithms & humans are used differently:: Human decision makers and algorithmic decision makers are not used in a plug-and-play interchangeable way in practice.\nTechnology is power:: And with that comes responsibility.\n\nAs the Arkansas healthcare example showed, machine learning is often implemented in practice not because it leads to better outcomes, but because it is cheaper and more efficient. Cathy O’Neill, in her book Weapons of Math Destruction (Crown), described the pattern of how the privileged are processed by people, whereas the poor are processed by algorithms. This is just one of a number of ways that algorithms are used differently than human decision makers. Others include:\n\nPeople are more likely to assume algorithms are objective or error-free (even if they’re given the option of a human override).\nAlgorithms are more likely to be implemented with no appeals process in place.\nAlgorithms are often used at scale.\nAlgorithmic systems are cheap.\n\nEven in the absence of bias, algorithms (and deep learning especially, since it is such an effective and scalable algorithm) can lead to negative societal problems, such as when used for disinformation.\n\n\nDisinformation\nDisinformation has a history stretching back hundreds or even thousands of years. It is not necessarily about getting someone to believe something false, but rather often used to sow disharmony and uncertainty, and to get people to give up on seeking the truth. Receiving conflicting accounts can lead people to assume that they can never know whom or what to trust.\nSome people think disinformation is primarily about false information or fake news, but in reality, disinformation can often contain seeds of truth, or half-truths taken out of context. Ladislav Bittman was an intelligence officer in the USSR who later defected to the US and wrote some books in the 1970s and 1980s on the role of disinformation in Soviet propaganda operations. In The KGB and Soviet Disinformation (Pergamon) he wrote, “Most campaigns are a carefully designed mixture of facts, half-truths, exaggerations, and deliberate lies.”\nIn the US this has hit close to home in recent years, with the FBI detailing a massive disinformation campaign linked to Russia in the 2016 election. Understanding the disinformation that was used in this campaign is very educational. For instance, the FBI found that the Russian disinformation campaign often organized two separate fake “grass roots” protests, one for each side of an issue, and got them to protest at the same time! The Houston Chronicle reported on one of these odd events (&lt;&gt;).\n\n: A group that called itself the “Heart of Texas” had organized it on social media—a protest, they said, against the “Islamization” of Texas. On one side of Travis Street, I found about 10 protesters. On the other side, I found around 50 counterprotesters. But I couldn’t find the rally organizers. No “Heart of Texas.” I thought that was odd, and mentioned it in the article: What kind of group is a no-show at its own event? Now I know why. Apparently, the rally’s organizers were in Saint Petersburg, Russia, at the time. “Heart of Texas” is one of the internet troll groups cited in Special Prosecutor Robert Mueller’s recent indictment of Russians attempting to tamper with the U.S. presidential election.\n\n\nDisinformation often involves coordinated campaigns of inauthentic behavior. For instance, fraudulent accounts may try to make it seem like many people hold a particular viewpoint. While most of us like to think of ourselves as independent-minded, in reality we evolved to be influenced by others in our in-group, and in opposition to those in our out-group. Online discussions can influence our viewpoints, or alter the range of what we consider acceptable viewpoints. Humans are social animals, and as social animals we are extremely influenced by the people around us. Increasingly, radicalization occurs in online environments; influence is coming from people in the virtual space of online forums and social networks.\nDisinformation through autogenerated text is a particularly significant issue, due to the greatly increased capability provided by deep learning. We discuss this issue in depth when we delve into creating language models, in &lt;&gt;.\nOne proposed approach is to develop some form of digital signature, to implement it in a seamless way, and to create norms that we should only trust content that has been verified. The head of the Allen Institute on AI, Oren Etzioni, wrote such a proposal in an article titled “How Will We Prevent AI-Based Forgery?”: “AI is poised to make high-fidelity forgery inexpensive and automated, leading to potentially disastrous consequences for democracy, security, and society. The specter of AI forgery means that we need to act to make digital signatures de rigueur as a means of authentication of digital content.”\nWhilst we can’t hope to discuss all the ethical issues that deep learning, and algorithms more generally, brings up, hopefully this brief introduction has been a useful starting point you can build on. We’ll now move on to the questions of how to identify ethical issues, and what to do about them.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>AI and Data Ethics</span>"
    ]
  },
  {
    "objectID": "book3.html#identifying-and-addressing-ethical-issues",
    "href": "book3.html#identifying-and-addressing-ethical-issues",
    "title": "3  AI and Data Ethics",
    "section": "3.4 Identifying and Addressing Ethical Issues",
    "text": "3.4 Identifying and Addressing Ethical Issues\nMistakes happen. Finding out about them, and dealing with them, needs to be part of the design of any system that includes machine learning (and many other systems too). The issues raised within data ethics are often complex and interdisciplinary, but it is crucial that we work to address them.\nSo what can we do? This is a big topic, but a few steps towards addressing ethical issues are:\n\nAnalyze a project you are working on.\nImplement processes at your company to find and address ethical risks.\nSupport good policy.\nIncrease diversity.\n\nLet’s walk through each of these steps, starting with analyzing a project you are working on.\n\nAnalyze a Project You Are Working On\nIt’s easy to miss important issues when considering ethical implications of your work. One thing that helps enormously is simply asking the right questions. Rachel Thomas recommends considering the following questions throughout the development of a data project:\n\nShould we even be doing this?\nWhat bias is in the data?\nCan the code and data be audited?\nWhat are the error rates for different sub-groups?\nWhat is the accuracy of a simple rule-based alternative?\nWhat processes are in place to handle appeals or mistakes?\nHow diverse is the team that built it?\n\nThese questions may be able to help you identify outstanding issues, and possible alternatives that are easier to understand and control. In addition to asking the right questions, it’s also important to consider practices and processes to implement.\nOne thing to consider at this stage is what data you are collecting and storing. Data often ends up being used for different purposes than what it was originally collected for. For instance, IBM began selling to Nazi Germany well before the Holocaust, including helping with Germany’s 1933 census conducted by Adolf Hitler, which was effective at identifying far more Jewish people than had previously been recognized in Germany. Similarly, US census data was used to round up Japanese-Americans (who were US citizens) for internment during World War II. It is important to recognize how data and images collected can be weaponized later. Columbia professor Tim Wu wrote that “You must assume that any personal data that Facebook or Android keeps are data that governments around the world will try to get or that thieves will try to steal.”\n\n\nProcesses to Implement\nThe Markkula Center has released An Ethical Toolkit for Engineering/Design Practice that includes some concrete practices to implement at your company, including regularly scheduled sweeps to proactively search for ethical risks (in a manner similar to cybersecurity penetration testing), expanding the ethical circle to include the perspectives of a variety of stakeholders, and considering the terrible people (how could bad actors abuse, steal, misinterpret, hack, destroy, or weaponize what you are building?).\nEven if you don’t have a diverse team, you can still try to pro-actively include the perspectives of a wider group, considering questions such as these (provided by the Markkula Center):\n\nWhose interests, desires, skills, experiences, and values have we simply assumed, rather than actually consulted?\nWho are all the stakeholders who will be directly affected by our product? How have their interests been protected? How do we know what their interests really are—have we asked?\nWho/which groups and individuals will be indirectly affected in significant ways?\nWho might use this product that we didn’t expect to use it, or for purposes we didn’t initially intend?\n\n\nEthical lenses\nAnother useful resource from the Markkula Center is its Conceptual Frameworks in Technology and Engineering Practice. This considers how different foundational ethical lenses can help identify concrete issues, and lays out the following approaches and key questions:\n\nThe rights approach:: Which option best respects the rights of all who have a stake?\nThe justice approach:: Which option treats people equally or proportionately?\nThe utilitarian approach:: Which option will produce the most good and do the least harm?\nThe common good approach:: Which option best serves the community as a whole, not just some members?\nThe virtue approach:: Which option leads me to act as the sort of person I want to be?\n\nMarkkula’s recommendations include a deeper dive into each of these perspectives, including looking at a project through the lenses of its consequences:\n\nWho will be directly affected by this project? Who will be indirectly affected?\nWill the effects in aggregate likely create more good than harm, and what types of good and harm?\nAre we thinking about all relevant types of harm/benefit (psychological, political, environmental, moral, cognitive, emotional, institutional, cultural)?\nHow might future generations be affected by this project?\nDo the risks of harm from this project fall disproportionately on the least powerful in society? Will the benefits go disproportionately to the well-off?\nHave we adequately considered “dual-use”?\n\nThe alternative lens to this is the deontological perspective, which focuses on basic concepts of right and wrong:\n\nWhat rights of others and duties to others must we respect?\nHow might the dignity and autonomy of each stakeholder be impacted by this project?\nWhat considerations of trust and of justice are relevant to this design/project?\nDoes this project involve any conflicting moral duties to others, or conflicting stakeholder rights? How can we prioritize these?\n\nOne of the best ways to help come up with complete and thoughtful answers to questions like these is to ensure that the people asking the questions are diverse.\n\n\n\nThe Power of Diversity\nCurrently, less than 12% of AI researchers are women, according to a study from Element AI. The statistics are similarly dire when it comes to race and age. When everybody on a team has similar backgrounds, they are likely to have similar blindspots around ethical risks. The Harvard Business Review (HBR) has published a number of studies showing many benefits of diverse teams, including:\n\n“How Diversity Can Drive Innovation”\n“Teams Solve Problems Faster When They’re More Cognitively Diverse”\n“Why Diverse Teams Are Smarter”, and\n“Defend Your Research: What Makes a Team Smarter? More Women”\n\nDiversity can lead to problems being identified earlier, and a wider range of solutions being considered. For instance, Tracy Chou was an early engineer at Quora. She wrote of her experiences, describing how she advocated internally for adding a feature that would allow trolls and other bad actors to be blocked. Chou recounts, “I was eager to work on the feature because I personally felt antagonized and abused on the site (gender isn’t an unlikely reason as to why)… But if I hadn’t had that personal perspective, it’s possible that the Quora team wouldn’t have prioritized building a block button so early in its existence.” Harassment often drives people from marginalized groups off online platforms, so this functionality has been important for maintaining the health of Quora’s community.\nA crucial aspect to understand is that women leave the tech industry at over twice the rate that men do, according to the Harvard Business Review (41% of women working in tech leave, compared to 17% of men). An analysis of over 200 books, white papers, and articles found that the reason they leave is that “they’re treated unfairly; underpaid, less likely to be fast-tracked than their male colleagues, and unable to advance.”\nStudies have confirmed a number of the factors that make it harder for women to advance in the workplace. Women receive more vague feedback and personality criticism in performance evaluations, whereas men receive actionable advice tied to business outcomes (which is more useful). Women frequently experience being excluded from more creative and innovative roles, and not receiving high-visibility “stretch” assignments that are helpful in getting promoted. One study found that men’s voices are perceived as more persuasive, fact-based, and logical than women’s voices, even when reading identical scripts.\nReceiving mentorship has been statistically shown to help men advance, but not women. The reason behind this is that when women receive mentorship, it’s advice on how they should change and gain more self-knowledge. When men receive mentorship, it’s public endorsement of their authority. Guess which is more useful in getting promoted?\nAs long as qualified women keep dropping out of tech, teaching more girls to code will not solve the diversity issues plaguing the field. Diversity initiatives often end up focusing primarily on white women, even though women of color face many additional barriers. In interviews with 60 women of color who work in STEM research, 100% had experienced discrimination.\nThe hiring process is particularly broken in tech. One study indicative of the dysfunction comes from Triplebyte, a company that helps place software engineers in companies, conducting a standardized technical interview as part of this process. They have a fascinating dataset: the results of how over 300 engineers did on their exam, coupled with the results of how those engineers did during the interview process for a variety of companies. The number one finding from Triplebyte’s research is that “the types of programmers that each company looks for often have little to do with what the company needs or does. Rather, they reflect company culture and the backgrounds of the founders.”\nThis is a challenge for those trying to break into the world of deep learning, since most companies’ deep learning groups today were founded by academics. These groups tend to look for people “like them”—that is, people that can solve complex math problems and understand dense jargon. They don’t always know how to spot people who are actually good at solving real problems using deep learning.\nThis leaves a big opportunity for companies that are ready to look beyond status and pedigree, and focus on results!\n\n\nFairness, Accountability, and Transparency\nThe professional society for computer scientists, the ACM, runs a data ethics conference called the Conference on Fairness, Accountability, and Transparency. “Fairness, Accountability, and Transparency” which used to go under the acronym FAT but now uses to the less objectionable FAccT. Microsoft has a group focused on “Fairness, Accountability, Transparency, and Ethics” (FATE). In this section, we’ll use “FAccT” to refer to the concepts of Fairness, Accountability, and Transparency.\nFAccT is another lens that you may find useful in considering ethical issues. One useful resource for this is the free online book Fairness and Machine Learning: Limitations and Opportunities by Solon Barocas, Moritz Hardt, and Arvind Narayanan, which “gives a perspective on machine learning that treats fairness as a central concern rather than an afterthought.” It also warns, however, that it “is intentionally narrow in scope… A narrow framing of machine learning ethics might be tempting to technologists and businesses as a way to focus on technical interventions while sidestepping deeper questions about power and accountability. We caution against this temptation.” Rather than provide an overview of the FAccT approach to ethics (which is better done in books such as that one), our focus here will be on the limitations of this kind of narrow framing.\nOne great way to consider whether an ethical lens is complete is to try to come up with an example where the lens and our own ethical intuitions give diverging results. Os Keyes, Jevan Hutson, and Meredith Durbin explored this in a graphic way in their paper “A Mulching Proposal: Analysing and Improving an Algorithmic System for Turning the Elderly into High-Nutrient Slurry”. The paper’s abstract says:\n\n: The ethical implications of algorithmic systems have been much discussed in both HCI and the broader community of those interested in technology design, development and policy. In this paper, we explore the application of one prominent ethical framework - Fairness, Accountability, and Transparency - to a proposed algorithm that resolves various societal issues around food security and population aging. Using various standardised forms of algorithmic audit and evaluation, we drastically increase the algorithm’s adherence to the FAT framework, resulting in a more ethical and beneficent system. We discuss how this might serve as a guide to other researchers or practitioners looking to ensure better ethical outcomes from algorithmic systems in their line of work.\n\nIn this paper, the rather controversial proposal (“Turning the Elderly into High-Nutrient Slurry”) and the results (“drastically increase the algorithm’s adherence to the FAT framework, resulting in a more ethical and beneficent system”) are at odds… to say the least!\nIn philosophy, and especially philosophy of ethics, this is one of the most effective tools: first, come up with a process, definition, set of questions, etc., which is designed to resolve some problem. Then try to come up with an example where that apparent solution results in a proposal that no one would consider acceptable. This can then lead to a further refinement of the solution.\nSo far, we’ve focused on things that you and your organization can do. But sometimes individual or organizational action is not enough. Sometimes, governments also need to consider policy implications.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>AI and Data Ethics</span>"
    ]
  },
  {
    "objectID": "book3.html#role-of-policy",
    "href": "book3.html#role-of-policy",
    "title": "3  AI and Data Ethics",
    "section": "3.5 Role of Policy",
    "text": "3.5 Role of Policy\nWe often talk to people who are eager for technical or design fixes to be a full solution to the kinds of problems that we’ve been discussing; for instance, a technical approach to debias data, or design guidelines for making technology less addictive. While such measures can be useful, they will not be sufficient to address the underlying problems that have led to our current state. For example, as long as it is incredibly profitable to create addictive technology, companies will continue to do so, regardless of whether this has the side effect of promoting conspiracy theories and polluting our information ecosystem. While individual designers may try to tweak product designs, we will not see substantial changes until the underlying profit incentives change.\n\nThe Effectiveness of Regulation\nTo look at what can cause companies to take concrete action, consider the following two examples of how Facebook has behaved. In 2018, a UN investigation found that Facebook had played a “determining role” in the ongoing genocide of the Rohingya, an ethnic minority in Mynamar described by UN Secretary-General Antonio Guterres as “one of, if not the, most discriminated people in the world.” Local activists had been warning Facebook executives that their platform was being used to spread hate speech and incite violence since as early as 2013. In 2015, they were warned that Facebook could play the same role in Myanmar that the radio broadcasts played during the Rwandan genocide (where a million people were killed). Yet, by the end of 2015, Facebook only employed four contractors that spoke Burmese. As one person close to the matter said, “That’s not 20/20 hindsight. The scale of this problem was significant and it was already apparent.” Zuckerberg promised during the congressional hearings to hire “dozens” to address the genocide in Myanmar (in 2018, years after the genocide had begun, including the destruction by fire of at least 288 villages in northern Rakhine state after August 2017).\nThis stands in stark contrast to Facebook quickly hiring 1,200 people in Germany to try to avoid expensive penalties (of up to 50 million euros) under a new German law against hate speech. Clearly, in this case, Facebook was more reactive to the threat of a financial penalty than to the systematic destruction of an ethnic minority.\nIn an article on privacy issues, Maciej Ceglowski draws parallels with the environmental movement:\n\n: This regulatory project has been so successful in the First World that we risk forgetting what life was like before it. Choking smog of the kind that today kills thousands in Jakarta and Delhi was https://en.wikipedia.org/wiki/Pea_soup_fog[once emblematic of London]. The Cuyahoga River in Ohio used to http://www.ohiohistorycentral.org/w/Cuyahoga_River_Fire[reliably catch fire]. In a particularly horrific example of unforeseen consequences, tetraethyl lead added to gasoline https://en.wikipedia.org/wiki/Lead%E2%80%93crime_hypothesis[raised violent crime rates] worldwide for fifty years. None of these harms could have been fixed by telling people to vote with their wallet, or carefully review the environmental policies of every company they gave their business to, or to stop using the technologies in question. It took coordinated, and sometimes highly technical, regulation across jurisdictional boundaries to fix them. In some cases, like the https://en.wikipedia.org/wiki/Montreal_Protocol[ban on commercial refrigerants] that depleted the ozone layer, that regulation required a worldwide consensus. We’re at the point where we need a similar shift in perspective in our privacy law.\n\n\n\nRights and Policy\nClean air and clean drinking water are public goods which are nearly impossible to protect through individual market decisions, but rather require coordinated regulatory action. Similarly, many of the harms resulting from unintended consequences of misuses of technology involve public goods, such as a polluted information environment or deteriorated ambient privacy. Too often privacy is framed as an individual right, yet there are societal impacts to widespread surveillance (which would still be the case even if it was possible for a few individuals to opt out).\nMany of the issues we are seeing in tech are actually human rights issues, such as when a biased algorithm recommends that Black defendants have longer prison sentences, when particular job ads are only shown to young people, or when police use facial recognition to identify protesters. The appropriate venue to address human rights issues is typically through the law.\nWe need both regulatory and legal changes, and the ethical behavior of individuals. Individual behavior change can’t address misaligned profit incentives, externalities (where corporations reap large profits while offloading their costs and harms to the broader society), or systemic failures. However, the law will never cover all edge cases, and it is important that individual software developers and data scientists are equipped to make ethical decisions in practice.\n\n\nCars: A Historical Precedent\nThe problems we are facing are complex, and there are no simple solutions. This can be discouraging, but we find hope in considering other large challenges that people have tackled throughout history. One example is the movement to increase car safety, covered as a case study in “Datasheets for Datasets” by Timnit Gebru et al. and in the design podcast 99% Invisible. Early cars had no seatbelts, metal knobs on the dashboard that could lodge in people’s skulls during a crash, regular plate glass windows that shattered in dangerous ways, and non-collapsible steering columns that impaled drivers. However, car companies were incredibly resistant to even discussing the idea of safety as something they could help address, and the widespread belief was that cars are just the way they are, and that it was the people using them who caused problems.\nIt took consumer safety activists and advocates decades of work to even change the national conversation to consider that perhaps car companies had some responsibility which should be addressed through regulation. When the collapsible steering column was invented, it was not implemented for several years as there was no financial incentive to do so. Major car company General Motors hired private detectives to try to dig up dirt on consumer safety advocate Ralph Nader. The requirement of seatbelts, crash test dummies, and collapsible steering columns were major victories. It was only in 2011 that car companies were required to start using crash test dummies that would represent the average woman, and not just average men’s bodies; prior to this, women were 40% more likely to be injured in a car crash of the same impact compared to a man. This is a vivid example of the ways that bias, policy, and technology have important consequences.",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>AI and Data Ethics</span>"
    ]
  },
  {
    "objectID": "book3.html#conclusion",
    "href": "book3.html#conclusion",
    "title": "3  AI and Data Ethics",
    "section": "3.6 Conclusion",
    "text": "3.6 Conclusion\nComing from a background of working with binary logic, the lack of clear answers in ethics can be frustrating at first. Yet, the implications of how our work impacts the world, including unintended consequences and the work becoming weaponized by bad actors, are some of the most important questions we can (and should!) consider. Even though there aren’t any easy answers, there are definite pitfalls to avoid and practices to follow to move toward more ethical behavior.\nMany people (including us!) are looking for more satisfying, solid answers about how to address harmful impacts of technology. However, given the complex, far-reaching, and interdisciplinary nature of the problems we are facing, there are no simple solutions. Julia Angwin, former senior reporter at ProPublica who focuses on issues of algorithmic bias and surveillance (and one of the 2016 investigators of the COMPAS recidivism algorithm that helped spark the field of FAccT) said in a 2019 interview:\n\n: I strongly believe that in order to solve a problem, you have to diagnose it, and that we’re still in the diagnosis phase of this. If you think about the turn of the century and industrialization, we had, I don’t know, 30 years of child labor, unlimited work hours, terrible working conditions, and it took a lot of journalist muckraking and advocacy to diagnose the problem and have some understanding of what it was, and then the activism to get laws changed. I feel like we’re in a second industrialization of data information… I see my role as trying to make as clear as possible what the downsides are, and diagnosing them really accurately so that they can be solvable. That’s hard work, and lots more people need to be doing it.\n\nIt’s reassuring that Angwin thinks we are largely still in the diagnosis phase: if your understanding of these problems feels incomplete, that is normal and natural. Nobody has a “cure” yet, although it is vital that we continue working to better understand and address the problems we are facing.\nOne of our reviewers for this book, Fred Monroe, used to work in hedge fund trading. He told us, after reading this chapter, that many of the issues discussed here (distribution of data being dramatically different than what a model was trained on, the impact feedback loops on a model once deployed and at scale, and so forth) were also key issues for building profitable trading models. The kinds of things you need to do to consider societal consequences are going to have a lot of overlap with things you need to do to consider organizational, market, and customer consequences—so thinking carefully about ethics can also help you think carefully about how to make your data product successful more generally!",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>AI and Data Ethics</span>"
    ]
  },
  {
    "objectID": "book3.html#questionnaire",
    "href": "book3.html#questionnaire",
    "title": "3  AI and Data Ethics",
    "section": "3.7 Questionnaire",
    "text": "3.7 Questionnaire\n\nDoes ethics provide a list of “right answers”?\nHow can working with people of different backgrounds help when considering ethical questions?\nWhat was the role of IBM in Nazi Germany? Why did the company participate as it did? Why did the workers participate?\nWhat was the role of the first person jailed in the Volkswagen diesel scandal?\nWhat was the problem with a database of suspected gang members maintained by California law enforcement officials?\nWhy did YouTube’s recommendation algorithm recommend videos of partially clothed children to pedophiles, even though no employee at Google had programmed this feature?\nWhat are the problems with the centrality of metrics?\nWhy did Meetup.com not include gender in its recommendation system for tech meetups?\nWhat are the six types of bias in machine learning, according to Suresh and Guttag?\nGive two examples of historical race bias in the US.\nWhere are most images in ImageNet from?\nIn the paper “Does Machine Learning Automate Moral Hazard and Error” why is sinusitis found to be predictive of a stroke?\nWhat is representation bias?\nHow are machines and people different, in terms of their use for making decisions?\nIs disinformation the same as “fake news”?\nWhy is disinformation through auto-generated text a particularly significant issue?\nWhat are the five ethical lenses described by the Markkula Center?\nWhere is policy an appropriate tool for addressing data ethics issues?\n\n\nFurther Research:\n\nRead the article “What Happens When an Algorithm Cuts Your Healthcare”. How could problems like this be avoided in the future?\nResearch to find out more about YouTube’s recommendation system and its societal impacts. Do you think recommendation systems must always have feedback loops with negative results? What approaches could Google take to avoid them? What about the government?\nRead the paper “Discrimination in Online Ad Delivery”. Do you think Google should be considered responsible for what happened to Dr. Sweeney? What would be an appropriate response?\nHow can a cross-disciplinary team help avoid negative consequences?\nRead the paper “Does Machine Learning Automate Moral Hazard and Error”. What actions do you think should be taken to deal with the issues identified in this paper?\nRead the article “How Will We Prevent AI-Based Forgery?” Do you think Etzioni’s proposed approach could work? Why?\nComplete the section “Analyze a Project You Are Working On” in this chapter.\nConsider whether your team could be more diverse. If so, what approaches might help?",
    "crumbs": [
      "Getting Started",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>AI and Data Ethics</span>"
    ]
  },
  {
    "objectID": "book5.html",
    "href": "book5.html",
    "title": "5  Image Classification",
    "section": "",
    "text": "Now that you understand what deep learning is, what it’s for, and how to create and deploy a model, it’s time for us to go deeper! In an ideal world deep learning practitioners wouldn’t have to know every detail of how things work under the hood… But as yet, we don’t live in an ideal world. The truth is, to make your model really work, and work reliably, there are a lot of details you have to get right, and a lot of details that you have to check. This process requires being able to look inside your neural network as it trains, and as it makes predictions, find possible problems, and know how to fix them.\nSo, from here on in the book we are going to do a deep dive into the mechanics of deep learning. What is the architecture of a computer vision model, an NLP model, a tabular model, and so on? How do you create an architecture that matches the needs of your particular domain? How do you get the best possible results from the training process? How do you make things faster? What do you have to change as your datasets change?\nWe will start by repeating the same basic applications that we looked at in the first chapter, but we are going to do two things:\n\nMake them better.\nApply them to a wider variety of types of data.\n\nIn order to do these two things, we will have to learn all of the pieces of the deep learning puzzle. This includes different types of layers, regularization methods, optimizers, how to put layers together into architectures, labeling techniques, and much more. We are not just going to dump all of these things on you, though; we will introduce them progressively as needed, to solve actual problems related to the projects we are working on.\n\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>*Image Classification*</span>"
    ]
  },
  {
    "objectID": "book6.html",
    "href": "book6.html",
    "title": "6  Other Computer Vision Problems",
    "section": "",
    "text": "6.1 Multi-Label Classification\nMulti-label classification refers to the problem of identifying the categories of objects in images that may not contain exactly one type of object. There may be more than one kind of object, or there may be no objects at all in the classes that you are looking for.\nFor instance, this would have been a great approach for our bear classifier. One problem with the bear classifier that we rolled out in Chapter 2 was that if a user uploaded something that wasn’t any kind of bear, the model would still say it was either a grizzly, black, or teddy bear—it had no ability to predict “not a bear at all.” In fact, after we have completed this chapter, it would be a great exercise for you to go back to your image classifier application, and try to retrain it using the multi-label technique, then test it by passing in an image that is not of any of your recognized classes.\nIn practice, we have not seen many examples of people training multi-label classifiers for this purpose—but we very often see both users and developers complaining about this problem. It appears that this simple solution is not at all widely understood or appreciated! Because in practice it is probably more common to have some images with zero matches or more than one match, we should probably expect in practice that multi-label classifiers are more widely applicable than single-label classifiers.\nFirst, let’s see what a multi-label dataset looks like, then we’ll explain how to get it ready for our model. You’ll see that the architecture of the model does not change from the last chapter; only the loss function does. Let’s start with the data.\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>*Other Computer Vision Problems*</span>"
    ]
  },
  {
    "objectID": "book7.html",
    "href": "book7.html",
    "title": "7  Training a State-of-the-Art Model",
    "section": "",
    "text": "7.1 Imagenette\nWhen fast.ai first started there were three main datasets that people used for building and testing computer vision models:\nThe problem was that the smaller datasets didn’t actually generalize effectively to the large ImageNet dataset. The approaches that worked well on ImageNet generally had to be developed and trained on ImageNet. This led to many people believing that only researchers with access to giant computing resources could effectively contribute to developing image classification algorithms.\nWe thought that seemed very unlikely to be true. We had never actually seen a study that showed that ImageNet happen to be exactly the right size, and that other datasets could not be developed which would provide useful insights. So we thought we would try to create a new dataset that researchers could test their algorithms on quickly and cheaply, but which would also provide insights likely to work on the full ImageNet dataset.\nAbout three hours later we had created Imagenette. We selected 10 classes from the full ImageNet that looked very different from one another. As we had hoped, we were able to quickly and cheaply create a classifier capable of recognizing these classes. We then tried out a few algorithmic tweaks to see how they impacted Imagenette. We found some that worked pretty well, and tested them on ImageNet as well—and we were very pleased to find that our tweaks worked well on ImageNet too!\nThere is an important message here: the dataset you get given is not necessarily the dataset you want. It’s particularly unlikely to be the dataset that you want to do your development and prototyping in. You should aim to have an iteration speed of no more than a couple of minutes—that is, when you come up with a new idea you want to try out, you should be able to train a model and see how it goes within a couple of minutes. If it’s taking longer to do an experiment, think about how you could cut down your dataset, or simplify your model, to improve your experimentation speed. The more experiments you can do, the better!\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>*Training a State-of-the-Art Model*</span>"
    ]
  },
  {
    "objectID": "book7.html#imagenette",
    "href": "book7.html#imagenette",
    "title": "7  Training a State-of-the-Art Model",
    "section": "",
    "text": "ImageNet:: 1.3 million images of various sizes around 500 pixels across, in 1,000 categories, which took a few days to train\nMNIST:: 50,000 28×28-pixel grayscale handwritten digits\nCIFAR10:: 60,000 32×32-pixel color images in 10 classes",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>*Training a State-of-the-Art Model*</span>"
    ]
  },
  {
    "objectID": "book8.html",
    "href": "book8.html",
    "title": "8  Collaborative Filtering Deep Dive",
    "section": "",
    "text": "One very common problem to solve is when you have a number of users and a number of products, and you want to recommend which products are most likely to be useful for which users. There are many variations of this: for example, recommending movies (such as on Netflix), figuring out what to highlight for a user on a home page, deciding what stories to show in a social media feed, and so forth. There is a general solution to this problem, called collaborative filtering, which works like this: look at what products the current user has used or liked, find other users that have used or liked similar products, and then recommend other products that those users have used or liked.\nFor example, on Netflix you may have watched lots of movies that are science fiction, full of action, and were made in the 1970s. Netflix may not know these particular properties of the films you have watched, but it will be able to see that other people that have watched the same movies that you watched also tended to watch other movies that are science fiction, full of action, and were made in the 1970s. In other words, to use this approach we don’t necessarily need to know anything about the movies, except who like to watch them.\nThere is actually a more general class of problems that this approach can solve, not necessarily involving users and products. Indeed, for collaborative filtering we more commonly refer to items, rather than products. Items could be links that people click on, diagnoses that are selected for patients, and so forth.\nThe key foundational idea is that of latent factors. In the Netflix example, we started with the assumption that you like old, action-packed sci-fi movies. But you never actually told Netflix that you like these kinds of movies. And Netflix never actually needed to add columns to its movies table saying which movies are of these types. Still, there must be some underlying concept of sci-fi, action, and movie age, and these concepts must be relevant for at least some people’s movie watching decisions.\nFor this chapter we are going to work on this movie recommendation problem. We’ll start by getting some data suitable for a collaborative filtering model.\n\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>*Collaborative Filtering Deep Dive*</span>"
    ]
  },
  {
    "objectID": "book9.html",
    "href": "book9.html",
    "title": "9  Tabular Modeling Deep Dive",
    "section": "",
    "text": "9.1 Categorical Embeddings\nIn tabular data some columns may contain numerical data, like “age,” while others contain string values, like “sex.” The numerical data can be directly fed to the model (with some optional preprocessing), but the other columns need to be converted to numbers. Since the values in those correspond to different categories, we often call this type of variables categorical variables. The first type are called continuous variables.\nAt the end of 2015, the Rossmann sales competition ran on Kaggle. Competitors were given a wide range of information about various stores in Germany, and were tasked with trying to predict sales on a number of days. The goal was to help the company to manage stock properly and be able to satisfy demand without holding unnecessary inventory. The official training set provided a lot of information about the stores. It was also permitted for competitors to use additional data, as long as that data was made public and available to all participants.\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>*Tabular Modeling Deep Dive*</span>"
    ]
  },
  {
    "objectID": "book9.html#categorical-embeddings",
    "href": "book9.html#categorical-embeddings",
    "title": "9  Tabular Modeling Deep Dive",
    "section": "",
    "text": "jargon: Continuous and Categorical Variables: Continuous variables are numerical data, such as “age,” that can be directly fed to the model, since you can add and multiply them directly. Categorical variables contain a number of discrete levels, such as “movie ID,” for which addition and multiplication don’t have meaning (even if they’re stored as numbers).",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>*Tabular Modeling Deep Dive*</span>"
    ]
  },
  {
    "objectID": "book10.html",
    "href": "book10.html",
    "title": "10  NLP Deep Dive: RNNs",
    "section": "",
    "text": "In Chapter 1 we saw that deep learning can be used to get great results with natural language datasets. Our example relied on using a pretrained language model and fine-tuning it to classify reviews. That example highlighted a difference between transfer learning in NLP and computer vision: in general in NLP the pretrained model is trained on a different task.\nWhat we call a language model is a model that has been trained to guess what the next word in a text is (having read the ones before). This kind of task is called self-supervised learning: we do not need to give labels to our model, just feed it lots and lots of texts. It has a process to automatically get labels from the data, and this task isn’t trivial: to properly guess the next word in a sentence, the model will have to develop an understanding of the English (or other) language. Self-supervised learning can also be used in other domains; for instance, see “Self-Supervised Learning and Computer Vision” for an introduction to vision applications. Self-supervised learning is not usually used for the model that is trained directly, but instead is used for pretraining a model used for transfer learning.\n\njargon: Self-supervised learning: Training a model using labels that are embedded in the independent variable, rather than requiring external labels. For instance, training a model to predict the next word in a text.\n\nThe language model we used in Chapter 1 to classify IMDb reviews was pretrained on Wikipedia. We got great results by directly fine-tuning this language model to a movie review classifier, but with one extra step, we can do even better. The Wikipedia English is slightly different from the IMDb English, so instead of jumping directly to the classifier, we could fine-tune our pretrained language model to the IMDb corpus and then use that as the base for our classifier.\nEven if our language model knows the basics of the language we are using in the task (e.g., our pretrained model is in English), it helps to get used to the style of the corpus we are targeting. It may be more informal language, or more technical, with new words to learn or different ways of composing sentences. In the case of the IMDb dataset, there will be lots of names of movie directors and actors, and often a less formal style of language than that seen in Wikipedia.\nWe already saw that with fastai, we can download a pretrained English language model and use it to get state-of-the-art results for NLP classification. (We expect pretrained models in many more languages to be available soon—they might well be available by the time you are reading this book, in fact.) So, why are we learning how to train a language model in detail?\nOne reason, of course, is that it is helpful to understand the foundations of the models that you are using. But there is another very practical reason, which is that you get even better results if you fine-tune the (sequence-based) language model prior to fine-tuning the classification model. For instance, for the IMDb sentiment analysis task, the dataset includes 50,000 additional movie reviews that do not have any positive or negative labels attached. Since there are 25,000 labeled reviews in the training set and 25,000 in the validation set, that makes 100,000 movie reviews altogether. We can use all of these reviews to fine-tune the pretrained language model, which was trained only on Wikipedia articles; this will result in a language model that is particularly good at predicting the next word of a movie review.\n\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "The Details",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>*NLP Deep Dive: RNNs*</span>"
    ]
  },
  {
    "objectID": "book11.html",
    "href": "book11.html",
    "title": "11  Data Munging with fastai’s Mid-Level API",
    "section": "",
    "text": "11.1 Going Deeper into fastai’s Layered API\nThe fastai library is built on a layered API. In the very top layer there are applications that allow us to train a model in five lines of codes, as we saw in Chapter 1. In the case of creating DataLoaders for a text classifier, for instance, we used the line:\nThe factory method TextDataLoaders.from_folder is very convenient when your data is arranged the exact same way as the IMDb dataset, but in practice, that often won’t be the case. The data block API offers more flexibility.\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>*Data Munging with fastai's Mid-Level API*</span>"
    ]
  },
  {
    "objectID": "book11.html#going-deeper-into-fastais-layered-api",
    "href": "book11.html#going-deeper-into-fastais-layered-api",
    "title": "11  Data Munging with fastai’s Mid-Level API",
    "section": "",
    "text": "from fastai.text.all import *\n\ndls = TextDataLoaders.from_folder(untar_data(URLs.IMDB), valid='test')",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>*Data Munging with fastai's Mid-Level API*</span>"
    ]
  },
  {
    "objectID": "book12.html",
    "href": "book12.html",
    "title": "12  A Language Model from Scratch",
    "section": "",
    "text": "12.1 The Data\nWhenever we start working on a new problem, we always first try to think of the simplest dataset we can that will allow us to try out methods quickly and easily, and interpret the results. When we started working on language modeling a few years ago we didn’t find any datasets that would allow for quick prototyping, so we made one. We call it Human Numbers, and it simply contains the first 10,000 numbers written out in English.\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>*A Language Model from Scratch*</span>"
    ]
  },
  {
    "objectID": "book12.html#the-data",
    "href": "book12.html#the-data",
    "title": "12  A Language Model from Scratch",
    "section": "",
    "text": "j: One of the most common practical mistakes I see even amongst highly experienced practitioners is failing to use appropriate datasets at appropriate times during the analysis process. In particular, most people tend to start with datasets that are too big and too complicated.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>*A Language Model from Scratch*</span>"
    ]
  },
  {
    "objectID": "book15.html",
    "href": "book15.html",
    "title": "15  Application Architectures Deep Dive",
    "section": "",
    "text": "15.1 Computer Vision\nFor computer vision application we use the functions vision_learner and unet_learner to build our models, depending on the task. In this section we’ll explore how to build the Learner objects we used in Parts 1 and 2 of this book.",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>*Application Architectures Deep Dive*</span>"
    ]
  },
  {
    "objectID": "book15.html#computer-vision",
    "href": "book15.html#computer-vision",
    "title": "15  Application Architectures Deep Dive",
    "section": "",
    "text": "vision_learner\nLet’s take a look at what happens when we use the vision_learner function. We begin by passing this function an architecture to use for the body of the network. Most of the time we use a ResNet, which you already know how to create, so we don’t need to delve into that any further. Pretrained weights are downloaded as required and loaded into the ResNet.\nThen, for transfer learning, the network needs to be cut. This refers to slicing off the final layer, which is only responsible for ImageNet-specific categorization. In fact, we do not slice off only this layer, but everything from the adaptive average pooling layer onwards. The reason for this will become clear in just a moment. Since different architectures might use different types of pooling layers, or even completely different kinds of heads, we don’t just search for the adaptive pooling layer to decide where to cut the pretrained model. Instead, we have a dictionary of information that is used for each model to determine where its body ends, and its head starts.\n\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>*Application Architectures Deep Dive*</span>"
    ]
  },
  {
    "objectID": "book18.html",
    "href": "book18.html",
    "title": "18  CNN Interpretation with CAM",
    "section": "",
    "text": "18.1 CAM and Hooks\nThe class activation map (CAM) was introduced by Bolei Zhou et al. in “Learning Deep Features for Discriminative Localization”. It uses the output of the last convolutional layer (just before the average pooling layer) together with the predictions to give us a heatmap visualization of why the model made its decision. This is a useful tool for interpretation.\nMore precisely, at each position of our final convolutional layer, we have as many filters as in the last linear layer. We can therefore compute the dot product of those activations with the final weights to get, for each location on our feature map, the score of the feature that was used to make a decision.\nWe’re going to need a way to get access to the activations inside the model while it’s training. In PyTorch this can be done with a hook. Hooks are PyTorch’s equivalent of fastai’s callbacks. However, rather than allowing you to inject code into the training loop like a fastai Learner callback, hooks allow you to inject code into the forward and backward calculations themselves. We can attach a hook to any layer of the model, and it will be executed when we compute the outputs (forward hook) or during backpropagation (backward hook). A forward hook is a function that takes three things—a module, its input, and its output—and it can perform any behavior you want. (fastai also provides a handy HookCallback that we won’t cover here, but take a look at the fastai docs; it makes working with hooks a little easier.)\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>*CNN Interpretation with CAM*</span>"
    ]
  },
  {
    "objectID": "book19.html",
    "href": "book19.html",
    "title": "19  A fastai Learner from Scratch",
    "section": "",
    "text": "This final chapter (other than the conclusion and the online chapters) is going to look a bit different. It contains far more code and far less prose than the previous chapters. We will introduce new Python keywords and libraries without discussing them. This chapter is meant to be the start of a significant research project for you. You see, we are going to implement many of the key pieces of the fastai and PyTorch APIs from scratch, building on nothing other than the components that we developed in Chapter 17! The key goal here is to end up with your own Learner class, and some callbacks—enough to be able to train a model on Imagenette, including examples of each of the key techniques we’ve studied. On the way to building Learner, we will create our own version of Module, Parameter, and parallel DataLoader so you have a very good idea of what those PyTorch classes do.\nThe end-of-chapter questionnaire is particularly important for this chapter. This is where we will be pointing you in the many interesting directions that you could take, using this chapter as your starting point. We suggest that you follow along with this chapter on your computer, and do lots of experiments, web searches, and whatever else you need to understand what’s going on. You’ve built up the skills and expertise to do this in the rest of this book, so we think you are going to do great!\nLet’s begin by gathering (manually) some data.\n\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>*A fastai Learner from Scratch*</span>"
    ]
  },
  {
    "objectID": "book20.html",
    "href": "book20.html",
    "title": "20  Concluding Thoughts",
    "section": "",
    "text": "Congratulations! You’ve made it! If you have worked through all of the notebooks to this point, then you have joined the small, but growing group of people that are able to harness the power of deep learning to solve real problems. You may not feel that way yet—in fact you probably don’t. We have seen again and again that students that complete the fast.ai courses dramatically underestimate how effective they are as deep learning practitioners. We’ve also seen that these people are often underestimated by others with a classic academic background. So if you are to rise above your own expectations and the expectations of others, what you do next, after closing this book, is even more important than what you’ve done to get to this point.\nThe most important thing is to keep the momentum going. In fact, as you know from your study of optimizers, momentum is something that can build upon itself! So think about what you can do now to maintain and accelerate your deep learning journey. Figure 20.1 can give you a few ideas.\n\n\n\n\n\n\nFigure 20.1: What to do next\n\n\n\n\nThis is just a preview of this chapter. The rest of this chapter is not available here, but you read the source notebook which has the same content (but with less nice formatting).",
    "crumbs": [
      "From the Foundations",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>*Concluding Thoughts*</span>"
    ]
  }
]